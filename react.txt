链接: http://pan.baidu.com/s/1sl7vMwd 密码: e47m
1.react是什么？
	》一个用于创建 可复用 可聚合 的web组件的 js库
	》只提供了前端MVC框架中的 V 并不是一个完整的前端MVC框架
	》React根Web Components 不冲突
	》React的特点就是轻
	》组件化的开发思路
2.为什么要使用react？
	》组件化 不需要写一大堆html模板
	》将js逻辑与html标签紧密相连 并且 极易理解 
	》单向数据流--》***数据一旦更新 就直接重新渲染整个app***
	》虚拟DOM树
3.jsx是什么？
	》js的xml语法扩展，采用熟悉且易于理解的语法来定义DOM树
4.应用场景
	》复杂场景下的高性能
	》重用组件库，组件组合
	》懒
5.react官网--》https://facebook.github.io/react/
	》jsx 是JavaScriptXml  是js的语法糖
		//编写jsx的语法
			//引入jsx解析库
			<script src='JSXTransformer.js'></script>
			//编写jsx语法
			<script type=text/jsx>
				function testJsx(){
					//{}表示执行js
					return (<div className='testClass' style={{backgroundColor:red}}>test Jsx</div>);
				}
			</script>
		//使用react的功能 引入react.js文件
		<script src='react.js'></script>
	》使用class属性  采用className
	》内联样式即添加style属性  值为一个样式对像  {backgroundColor:red}
	》react生命周期
		React.renderComponent()
			  |
		       Mounted(React Components被render解析生成对应的DOM节点并被插入浏览器的DOM结构的一个过程)
			  |
			 Update(一个mounted的React Components被重新render的过程 只有当state确实发生改变并影响DOM结构的时候才会重新render)-----React.unmountAndReleaseReactRootNode()-->Unmounted(一个mounted的React Components对应的DOM节点被从DOM结构中移除的过程)
	        setState()    |
	     Or setProps()|--render()

	     每一个状态React都封装了对应的hook(钩子)函数
	     》Mounting
			getDefaultProps()
				|
			getInitialState()
				|
			componentWillMount()--hook函数  Mounting前被调用
				|
			      render
				|
			componentDidMount()--hook函数  Mounted后被调用
			
			var Hello=React.createClass({//参数传入一个对象
				/**
					state的作用：
						》初始化组件相应的数据
				*/
				getInitialState:function(){//该函数需要返回一个对象  执行顺序 1
					alert('init');
					return {//初始化state的值
						opacity:1.0,
						fontSize:'12px'
					}
				},
				render:function(){//执行顺序 3
					//获取初始化状态中的值getInitialState  this.state.属性名 此处style属性可以写成style={this.state}
					return <div style={{opacity:this.state.opacity,fontSize:this.state.fontSize}}>Hello {this.props.name}</div>;
				},
				componentWillMount:function(){//执行顺序 2
					alert('will');
				},
				componentDidMount:function(){//执行顺序 4
					alert('did');
					//修改state的值 setState
					var _self=this;//表示Hello实例对象
					//1s之后修改state的值
					window.setTimeout(function(){
						_self.setState({
							opacity:.5,
							fontSize:'44px'
						});
					},1000);
				}
			});
			//调用组件中 定义的属性即组件中使用到的props
			React.render(<Hello name='World' />,document.getElementById('container'));
			//props 与 state的差异
				props往往是通过组件调用方通过调用组件时指定的 一般指定了是不会改变的
				state是私属于当前组件的，其值是可变的
	     》Updating
		    setProps:
			componentWillReceiveProps// hook函数 接收新的props时  被调用  其参数 新的props对象
		    setState:	  |
		        shouldComponentUpdate // hook函数 用于判断是否执行更新操作 返回true or false 参数两个：新的props对象，新的state对象
			   true|      |false(不更新)
			  componentWillUpdate //更新前 hook函数
				  |
				render
				  |
		         componentDidUpdate//更新后  hook函数
		    //上面的四个函数  很少被重写
	     》Unmounting
			componentWillUnmount --hook函数
	》react的事件监听
		所有的事件驼峰式命名绑定事件即可  如：onClick  onChange等  事件处理函数一般绑定在参数对象的上
		通过ref属性为某个元素标记，通过this.refs.属性名找到该组件  通过React.findDOMNode(this.refs.tip)找到DOM节点
		<div id="container"></div>
		<script type="text/jsx">
			/**
			 * button组件
			 */
			var ButtonComponent=React.createClass({
			    clickHandler:function(event){
				var target=React.findDOMNode(this.refs.tip);
				if(target.style.display === 'none')target.style.display='inline';
				else target.style.display='none';
				//阻止事件默认事件与冒泡
				event.stopPropagation();
				event.preventDefault();
			    },
			    render:function(){
				return <div><button onClick={this.clickHandler}>显示隐藏</button><span ref="tip">测试click事件</span></div>;
			    }
			});
			/**
			 * input组件
			 */
			var InputComponent=React.createClass({
			    getInitialState:function(){//初始化state的值
				return {
				    inputContent:''
				}
			    },
			    inputHandler:function(event){
				this.setState({
				    inputContent:event.target.value
				});
				event.stopPropagation();
				event.preventDefault();
			    },
			    render:function(){
				return <div>
					<input type="text" onChange={this.inputHandler}/>
					<span>{this.state.inputContent}</span>
				       </div>
			    }
			});
			React.render(
				<div>
				    <ButtonComponent />
				    <br/>
				    <br/>
				    <InputComponent/>
				</div>
			,document.getElementById('container'));
	        </script>
	》react 调试工具 react Developer tools  https://chrome.google.com/webstore
	》翻墙 LOCO加速器  http://locovpn.online/
		yshaow@126.com
		ysw0314
	》项目流程
		》github上创建新的中心库
		》拷贝中心库地址 git clone 地址 ，进入相应的目录 通过yeoman 创建基于react-webpack的项目结构
		》添加兼容前缀  npm install autoprefixer-loader --save-dev
			在css-loader之后添加 autoprefixer-loader?{browsers:["last 2 version"]}
		》提交代码
			git add -A//添加所有文件
			//提交
			git config --global user.email "yshaow@126.com"
			git config --global user.name "小五"
			git commit -m "init project structure"
			//push到远程
			git push
			username:yshaow
			password:
》React路由
	路由就是在应用上定义一些可以访问的地址
	》安装react-router
	》引入路由
		import {Router,Route,Link,IndexRoute,Redirect} from 'react-router';
		import createBrowserHistory from 'history/createBrowserHistory'
		const history = createBrowserHistory();
		/**********React路由**********/
		class App extends React.Component{
		  render (){
		    return (
		      <div>
			  <div>
			      /*添加路由的连接 to表示目标地址  即路由的path*/
			    <Link to='/'>首页</Link>
			    <Link to='/tv' query={{orderBy:'date'}}>电视</Link>/*query查询符  如：url?orderBy=date*/
			  </div>
			  {this.props.children}
		      </div>
		    );
		  }
		}
		class TV extends React.Component{
		  constructor(props){
		    super(props);
		    //获取查询符的值
		    let { query }=this.props.location;//得到query对象
		  }
		  render (){
		    return (
		      <div>
			  {this.props.children}
		      </div>
		    );
		  }
		}
		class Show extends React.Component{
		  //为了使用props属性  添加构造函数
		  constructor(props){
		    super(props);
		    //获取路由中传递的参数
		    let id=this.props.params;//参数对象
		  }
		  render (){
		    return (
		      <h3>节目{this.props.params.id}</h3>
		    );
		  }
		}
		class Home extends React.Component{
		  render(){
		    return (
		      <div>首页内容</div>
		    );
		  }
		}
		class ShowIndex extends React.Component{
		  render(){
		    return (
		      <div>电视节目列表</div>
		    );
		  }
		}
		function handleEnter(){
		  console.log('进入了！');
		}
		function handleLeave(){
		  console.log('离开了！');
		}
		/*定义路由*/
		ReactDOM.render(
		    //定义路由
		  (
		    <Router history={history}>
			/*定义路由
			*   path:定义路由地址
			*   component:定义路由对应的组件
			* */
			<div>
			  <Route path='/' component={App}>
			    <IndexRoute component={Home}/>/*显示默认的组件 当this.props.children无内容的时候  显示*/
			    <Route path='tv' component={TV}>
			      <IndexRoute component={ShowIndex}/>
			      <Route  path='shows/:id' component={Show}/*传递参数id*/
				  onEnter={handleEnter}/*进入该路由做的事情*/
				  onLeave={handleLeave}/*离开该路由做的事情*/
				/>
			      <Redirect from='shows/:id' to='/shows/:id'/>/*重定向 from：用户的访问地址  to:系统重定向的地址*/
			    </Route>
			  </Route>
			</div>
		    </Router>
		  )
		  ,document.getElementById('app'));
》React中的数据流-Redux
	》数据流
		数据流是我们的行为与响应的抽象
	》为什么要用数据流
		使用数据流帮助我们明确了行为对应的响应
	》React与数据流的关系
		React是纯V层的框架(只负责视图)，需要数据流进行支撑
	》主流数据流框架
		Flux：官方的，单向的 重量级的
		reFlux：
		Redux：简单的 单一状态树
	》Redux简介
		安装 npm install react-redux redux
		资料：http://redux.js.org(英文) http://cn.redux.js.org(中文)
		action:行为的抽象  普通的js对象 一般由方法生成，但必须有一个type属性(唯一的)
		reducer:是响应的抽象 是一个纯方法 传入旧状态state和active 返回新状态state 对象
		store:action作用于store  reducer根据store响应  store是唯一的 store包括了完整的state state完全可预测
	》组件分类
					container			component
		目的		如何工作(数据获取，状态更新)		如何显示(样式，布局)
	是否在Redux数据流中		是					否
	读取数据		从Redux获取state			从props获取数据
	修改数据		向Redux派发actions			从props调用回调函数
	实现方式		由react-Redux生成			手写
	》项目目录结构分析
		actions: 行为
		components:组件
		containers:组件
		reducers: 响应
			
/**文档解析**/
****初级入门****
http://www.css88.com/react/docs/installation.html
https://facebook.github.io/react/
1.安装
	》创建一个新的应用
		npm install -g create-react-app
		create-react-app my-app
		cd my-app
		npm start
	》在已存在的应用中使用react
		》包管理工具
			》Yarn
				yarn init
				yarn add react react-dom
			》npm
				npm init
				npm install --save react react-dom
		》使用CDN
			开发版：
				<script src="https://unpkg.com/react@15/dist/react.js"></script>
				<script src="https://unpkg.com/react-dom@15/dist/react-dom.js"></script>
			生产版：
				<script src="https://unpkg.com/react@15/dist/react.min.js"></script>
				<script src="https://unpkg.com/react-dom@15/dist/react-dom.min.js"></script>
2.jsx介绍
	const elem=<h1>Hello,world!</h1>--这种标签语法既不是字符串也不是html 即JSX 它是js的扩展
	jsx中可以写任何js表达式 通过{}包裹
		const elem=(<h1>Hello,{formatName(user)}</h1>)
	jsx的属性：
		》字符串值
			const elem=<div tabIndex='0'></div>
		》js表达式
			const elem=<img src={user.url}/>//有花括号的时候不要放置引号
	jsx的子元素：
		》如果它是一个空的标签 你需要像xml一样关闭它
			const elem=<img src={user.url}/>
		》如果它包含多个子元素
			const elem=(
				<div>
					<h1>hello</h1>
					<h3>world</h3>
				</div>
			)
			注意：一旦jsx渲染到html中时，ReactDOM使用camelCase(驼峰命名)规则来解析其属性名
			如：class 即jsx中的className tabindex 变成tabIndex
	babel通过React.createElement()编译jsx
		const elem=(
			<h1 className='greeting'>
				hello,world!
			</h1>
		)
		const elem=React.createElement(
			'h1',//type
			{className:'greeting'},//props
			'hello,world!'//children
		)
3.元素渲染
	使用ReactDOM.render()渲染React元素到DOM根节点中
		<div id='root'></div>
		const elem=<h1>Hello,world</h1>
		ReactDOM.render(
			elem,
			document.getElementById('root');
		);
	更新已经渲染的元素需要重新渲染：
		setTimeout(function(){
			elem=<h1>哈哈</h1>
			ReactDOM.render(//重新渲染
				elem,
				document.getElementById('root');
			);
		},1000);
4.组件和props属性
	组件就像js函数，它们接受任意的输入参数(props)并返回React元素的描述(jsx)。
	注意：***组件名的首字母必须大写***
	》一个最简单的方式：通过js函数定义组件
		function Welcome(props){
			return <h1>Hello,{props.name}</h1>
		}
		//方式1
		ReactDOM.render(Welcome({name:"羊少"}),document.getElementById('app'));
		//方式2
		ReactDOM.render(<Welcome name='小五'/>,document.getElementById('app'));
	》通过Es6的class定义一个组件
		class Welcome extends React.Component{
			render(){
				return <h1>Hello,{this.props.name}</h1>
			}
		}
		ReactDOM.render(<Welcome name='小刘'/>,document.getElementById('app'));
	》混合组件
		function App(){
			return (
				<div>
					<welcome name='Sara'/>
					<welcome name='Cahal'/>
					<Welcome name='aa'></Welcome>
				</div>
			)
		}
		ReactDOM.render(<App></App>,document.getElementById('app'));
		注意：组件一定要返回一个单个的根元素，这也是为什么这里我们要用<div>包裹<Welcome/>的原因
	》提取组件
		function Comment(props){
			return (
				<div className='Comment'>
					<div className='UserInfo'>
						<img className='Avatar'
							src={props.author.avatarUrl}
							alt={props.author.name}
						/>
						<div className='UserInfo-name'>
							{props.author.name}
						</div>
					</div>
					<div className='Comment-text'>
						{props.text}
					</div>
					<div className='Comment-date'>
						{formatDate(props.date)}
					</div>
				</div>
			);
		}
		//提取组件
		function Avatar(props){
			return (
				<img 
					className='Avatar'
					src={props.user.avatarUrl}
					alt={props.user.name}
				/>
			)
		}
		function UserInfo(props){
			return (
				<div className='UserInfo'>
					<Avatar user={props.user}/>
					<div className='UserInfo-name'>
						{props.user.name}
					</div>
				</div>
			);
		}
		//最终Comment组件
		function Comment(props){
			return (
				<div className='Comment'>
					<Userinfo user={props.author} />
					<div className="Comment-text">
						{props.text}
					</div>
					<div className="Comment-date">
						{formatDate(props.date)}
					</div>
				</div>
			);
		}
	》Props是只读的
		无论你是通过函数或者class声明组件，他都不能改变自己的props属性
		虽然React是灵活的但是它有一个严格的单线程规则
5.state与生命周期
	state属性和props相似的，但是它是私有的并且完全的被当前组件控制。
	state属性是React组件类提供的一种特色，仅仅通过class声明组件可用
	步奏：
		》创建一个 ES6 的class 并继承 React.Component
		》添加一个单个的空白方法 名称为render()
		》把函数组件的内容填充到render()中
		》把props换成this.props
		》删除声明的函数组件
		class Clock extends React.Component{
			constructor(){
				super(props);//类组件构造函数总是需要基于基础的构造函数
				this.state={date:new Date()}//初始化state属性 在类组件中 唯一设置state属性值的地方 构造函数
			}
			render(){
				return (
					<div>
						<h1>Hello,world!</h1>
						<h2>It is {this.state.date.toLocaleTimeString()}.</h2>
					</div>
				);
			}
			componentDidMount(){//当渲染结束 调用的hook方法
				//启动定时器
				this.timerID=setInterval(
					()=>this.tick(),1000
				);
			}
			componentWillUnmount(){//当组件销毁是调用的hook方法
				//清除定时器
				clearInterval(this.timerID);
			}
			tick(){//改变state的值
				this.setState({//setState用于修改state属性值 参数是一个对象
					date:new Date();
				});
			}
		}
		ReactDOM.render(<Clock />,document.getElementById('root'));
		》生命周期函数
			在应用中有许多组件，它当组件被销毁的时候，释放资源是非常重要的
			componentDidMount//当渲染结束 调用的hook方法
			componentWillUnmount//当组件销毁是调用的hook方法
		》异步更新state值
			this.props和this.state可能被异步的更新
			//错误的
			this.setState({
				counter:this.state.counter + this.props.increment,
			});
			第二种setState的方式是接受一个函数  第一个函数值为上一次state的值，第二个参数为现在更新后的props的值
			//正确的
			this.setState((prevState,props)=>({
				counter:prevState.counter + props.increment
			}));
		》state更新是合并的
			当setState被调用的时候，React合并你提供的对象和当前state对象
		》state不接受任何组件的设置与修改，除了它自己  数据流是单向的 向下的
6.事件处理
	React的元素事件和DOM元素事件的区别：
		》前者是camelCase驼峰命名，后者是lowercase 全部小写
		》前者直接{函数名}(jsx中)，后者是字符串"函数名"(html中)
			React：
				<button onClick={activateLasers}></button>
			html:
				<button onclick='activateLasers'></button>
		》前者：不能够直接返回false来阻止默认行为，一定要用preventDefault,html中就可以
			html:
				<a href='#' onclick='console.log("The link was clicked");return false'>click me</a>
			React:
				function ActionLink(){
					function handleClick(e){//e 是React进一步的封装  所以你不用担心跨浏览器的兼容
						e.preventDefault();
						console.log("The link was clicked");
					}
					return (
						<a href='#' onClick={handleClick}>click me</a>
					);
				}
	用ES6 class定义组件的时候，通常是一个事件对应于此类的一个方法
		class Toggle extends React.Component{
			constructor(props){
				super(props);
				this.state={isToggleOn:true}
				//绑定this 方式1
				this.handleClick=this.handleClick.bind(this);
			}
			//方式1 方式3
			handleClick(){
				this.setState(prevState=>({
					isToggleOn:!prevState.isToggleOn
				}))
			}
			//方式2
			handleClick=()=>{
				this.setState(prevState=>({
					isToggleOn:!prevState.isToggleOn
				}))
			}
			render(){
				return (
					//方式1  方式2
					<button onClick={this.handleClick}>
						{this.state.isToggleOn?'ON':"OFF"}
					</button>
					//方式3
					<button onClick={(e)=>this.handleClick(e)}>
						{this.state.isToggleOn?'ON':"OFF"}
					</button>
				);
			}
		}
		注意：
			在js中class的方法默认是没有绑定this的，如果你忘记了绑定this.handleClick。在实际调用的时候
			this为undefined
7.条件渲染
	React中的条件渲染和js中的条件是一样的。利用js控制元素的创建。然后让React去更新
		function UserGreeting(props){
			return <h1>Welcome back!</h1>
		}
		function GuestGreeting(props){
			return <h1>Please sign up.</h1>
		}
		//条件
		function Greeting(props){
			const isLoggedIn=props.isLoggedIn;
			if(isLoggedIn) return <UserGreeting />;
			return <GuestGreeting />;
		}
		ReactDOM.render(<Greeting isLoggedIn={false} />,document.getElementById('root'));
	》元素变量
		你能够通过遍历来存储元素(组件)，可以通过该变量是否改变去更新渲染
		function LoginButton(props){
			return (
				<button onClick={props.onClick}>Login</button>
			);
		}
		function LogoutButton(props){
			return (
				<button onClick={props.onClick}>Logout</button>
			);
		}
		class LoginControl extends React.Component{
			constructor(props){
				super(props);
				this.state={isLoggedIn:false};
			}
			handleLoginClick=()=>{
				this.setState({isLoggedIn:true});
			}
			handleLogoutClick(){
				this.setState({isLoggedIn:false});
			}
			render(){
				const isLoggedIn=this.state.isLoggedIn;
				let button=null;//元素变量
				if(isLoggedIn)button=<LogoutButton onClick={(e)=>this.handleLogoutClick(e)} />;
				else button=<LoginButton onClick={this.handleLoginClick} />;
				return (
					<div>
						<greeting isLoggedIn={isLoggedIn}></greeting>
						{button}//使用元素变量
					</div>
				);
			}
		}
	》行内if逻辑 && 操作符
		function Mailbox(props){
			const unreadMessage=props.unreadMessages;
			return (
				<div>
					<h1>Hello !</h1>
					{
						unreadMessages.length >0 &&
						<h2>
							You have {unreadMessages.length} unread message.
						</h2>
					}
				</div>
			);
		}
		const messages=['React','Re:React','Re:Re:React'];
		ReactDOM.render(
			<Mailbox unreadMessages={messages} />,
			document.getElementById('root')
		);
	》行内if-else  条件操作符
		condition ? true :false.
		render (){
			const isLoggedIn=this.state.isLoggedIn;
			return (
				<idv>
					The user is <b>{isLoggedIN ?'currently':'not'}</b>logged in.
				</idv>
			);
		}

		render(){
			const isLoggedIn=this.state.isLoggedIn;
			return (
				<div>
					{
						isLoggedIn ?(
							<LogoutButton onClick={this.handleLogoutClick} />
						):(
							<LoginButton onClick={this.handleLoginClick} />
						)
					}
				</div>
			);
		}
	》阻止组件渲染
		由于一些原因你可能想让一个组件隐藏自己 即使它是被另一个组件已经渲染的。通过return null 来替代 它的渲染输出即可
		function WarningBanner(props){
			if(!props.warn){
				return null;
			}
			return (
				<div className='warning'>Warning !</div>
			);
		}
		class Page extends React.Component{
			constructor(props){
				super(props);
				this.state={showWarning:true}
			}
			handleToggleClick=()=>{
				this.setState(prevState => (
					{showWarning: !prevState.showWarning}
				))
			}
			render(){
				return (
					<div>
						<WarningBanner warn={this.state.showWarning} />
						<button onClick={this.handleToggleClick}>{this.state.showWarning ?'Hide' :' Show'}</button>
					</div>
				);
			}
		}
		ReactDOM.render(
			<Page />,
			document.getElementById('root')
		);
8.列表与keys
	在React中，遍历元素(组件)数组在列表里面和js中是一样的，你能够建立元素集合并且在jsx中通过{}引入**该集合**
		const number=[1,2,3];
		const listItems=numbers.map(val=><li>{val}</li>);
		ReactDOM.render(
			<ul>{listItems}</ul>,
			document.getElementById('root')
		)
	》基于列表的组件
		function NumberList(props){
			const numbers=props.numbers;
			const listItems=numbers.map(val=><li key={val.toString()}>{val}</li>);//提供key属性
			return (
				<ul>{listItems}</ul>
			);
		}
		const numbers=[1,2,3];
		ReactDOM.render(
			<NumberList numbers={numbers} />,
			document.getElementById('root');
		);
		//当运行这段代码时，你将得到一个警告：在列表中key应该被提供。当创建一个列表元素的时候需要
		提供一个唯一字符串属性key
	》keys
		keys可以帮助React分辨这些列表项的改变 添加 移除。所以keys应该被给
		通常情况下是使用数据中的id值来表示key 这样可以唯一的标记
			const todoItems=todos.map(todo=>
				<li key={todo.id}>{todo.text}</li>
			);
			//当没有一个固定的id来标记时，你可以使用数组的index作为key的值
				const todoItems=todos.map((todo,index)=>
					<li key={index}>{todo.text}</li>
				);
			//不推荐利用索引作为key值，因为如果这些列表项被重写，这将是缓慢的
	》提取组件的keys
		keys只有在有内容的数组环境中被使用才有意义。例如如果你提取一个列表组件，你应该保持列表项的元素有key，而不是这些列表项的根元素。
		//一个好的规则是元素调用map的时候需要keys
	》key一定要唯一在兄弟元素之间
		keys在兄弟元素之间需要唯一，然而它们不需要全局唯一，在两个不同的数组中时我们可以利用相同的keys
		function Blog(props){
			const sidebar=(
				<ul>
					{props.posts.map(post=>
						<li key={post.id}>{post.title}</li>
					)}
				</ul>
			);
			const content=props.posts.map(post=>
				<div key={post.id}>
					<h3>{post.title}</h3>
					<p>{post.content}</p>
				</div>
			)
			return (
				<div>
					{sidebar}
					<hr/>
					{content}
				</div>
			);
		}
		const posts = [
		  {id: 1, title: 'Hello World', content: 'Welcome to learning React!'},
		  {id: 2, title: 'Installation', content: 'You can install React from npm.'}
		];
		ReactDOM.render(
		  <Blog posts={posts} />,
		  document.getElementById('root')
		);
		//注意 keys是React的标记，但是它们不会被放入你的组件。如果你需要相同的值在你的组件，就用不同的属性去设置值
			const content=posts.map(post =>
				<Post 
					key={post.id}
					id={post.id}
					title={post.title}
				/>
			);
			//Post组件中能够阅读this.props.id，但是不能阅读this.props.key
	》在jsx中使用map()
		function NumberList(props){
			const numbers=props.numbers;
			const listItems=numbers.map(val=>
				<ListItem key={number.toString()} value={number}/>
			);
			return (
				<ul>{listItems}</ul>
			);
		}
		//jsx中使用map
		function NumberList(props){
			const numbers=props.numbers;
			return (
				<ul>
					{
						numbers.map(number=>
							<ListItem key={number.toString()} value={number} />
						)
					}
				</ul>
			);
		}
9.form表单
	控制组件--form表单的数据通过React控制
		在React中，易变的数据保持存储在组件的state组件中，仅仅通过setState()更新数据
			class NameForm extends React.Component{
				constructor(props){
					super(props);
					this.state={value:''}//初始化值
				}
				handleChange=(event)=>{//input的处理函数
					this.setState({value:event.target.value});
				}
				handleSubmit=(event)=>{//提交的处理函数
					console.log(this.state.value);
					event.preventDefault;
				}
				render(){
					return (
						<form onSubmit={this.handleSubmit}>
							<label>
								Name:<input type='text' value={this.state.value} onChange={this.handleChange}/>
							</label>
							<input type='submit' value='Submit'/>
						</form>
					);
				}
			}
		//textarea标签
			在React中，该标签利用value属性绑定内容
				render(){
					return (
						<form onSubmit={this.handleSubmit}>
							<label>
								<textarea value={this.state.value} onChange={this.handleChange}/>
							</label>
							<input type='submit' value='Submit'/>
						</form>
					);
				}
		//select标签
			html中：
				<select>
					  <option value="grapefruit">Grapefruit</option>
					  <option value="lime">Lime</option>
					  <option selected value="coconut">Coconut</option>
					  <option value="mango">Mango</option>
				</select>
				//Coconut选项默认选中，因为selected属性，React中利用在select标签中设置value属性来替代selected属性
				class FlavorForm extends React.Component{
					constructor(props){
						super(props);
						this.state={value:'coconut'}//初始化选中值
					}
					handleChange=(event)=>{
						this.setState({value:event.target.value});
					}
					handleSubmit=(event)=>{
						console.log(this.state.value);
						event.preventDefault();
					}
					render(){
						return (
							<form onSubmit={this.handleSubmit}>
								<select value={this.state.value} onChange={this.handleChange}>
									<option value="grapefruit">Grapefruit</option>
								        <option value="lime">Lime</option>
								        <option value="coconut">Coconut</option>
								        <option value="mango">Mango</option>
								</select>
								<input type='submit' value='Submit'/>
							</form>
						);
					}
				}
				//所有的form的功能元素都和上面一样 通过value属性来实现其数据的绑定
		//处理多个input元素
			当需要处理多个元素时，可以添加name属性，让处理函数基于event.target.name来改变state中对应的值
			class Reservation extends React.Component{
				constructor(props){
					super(props);
					this.state={
						isGoing:true,
						numberOfGuests:2
					}
				}
				handleInputChange=(event)=>{
					const target=event.target;
					const value=target.type === 'checkbox' ? target.checked : target.value;
					const name=target.name;
					this.setState({
						[name]:value
					});
				}
				render (){
					return (
						<form>
							<label>
								<input name='isGoing' type='checkbox' checked={this.state.isGoing} onChange={this.handleInputChange}/>
							</label>
							<label>
								<input	name='numberOfGuests' type='number' value={this.state.numberOfGuests} onChange={this.handleInputChange}/>
							</label>
						</form>
					);
				}
			}
10.挂起state
	通常 多个组件需要一些相同的变化的数据，推荐在最近的相同祖先上挂起共享的state属性
		function BoilingVerdict(props){
			if(props.celsius >= 100){
				return <p>The water would boil.</p>
			}
			return <p>The water would not boil.</p>
		}
		class Calcultor extends React.Component{
			constructor(props){
				super(props);
				this.state={temperature:''}
			}
			handleChange=(e)=>{
				this.setState({
					temperature:e.target.value
				});
			}
			render(){
				return (
					<fieldset>
						<legend>Enter temperature in Celsius:</legend>
						<input 
							value={temperature}
							onChange={this.handleChange}
						/>
						<BoilingVerdict celsius={parseFloat(temperature)}/>
					</fieldset>
				);
			}
		}
		const scaleNames={
			c:'Celsius',
			f:'Fahrenheit'
		}
		class TemperatureInput extends React.Component{
			constructor(props){
				super(props);
				this.state={temperature:''}
			}
			handleChange=(e)=>{
				this.setState({temperature:e.target.value});
			}
			render(){
				const temperature=this.state.temperature;
				const scale=this.props.scale;
				return (
					<fieldset>
						<legend>Enter temperature in {scaleNames[scale]}:</legend>
						<input value={temperature}
							onChange={this.handleChange}
						/>
					</fieldset>
				);
			}
		}
		//重写Calculator组件
		class Calculator extends React.Component{
			render(){
				return (
					<div>
						<TemperatureInput scale="c" />
						<TemperatureInput scale="f" />
					</div>
				);
			}
		}
		//书写转换函数
		function toCelsius(fahrenheit){
			return (fahrenheit - 32)*5/9;
		};
		function toFahrenheit(celsius){
			return (celsius * 9/5)+32;
		}
		function tryConvert(temperature,convert){
			const input =parseFloat(temperature);
			if(Number.isNaN(input)){
				return '';
			}
			const output =convert (input);
			const rounded=Math.round(output * 1000)/1000;
			return rounded.toString();
		}
		//挂起state
		class TemperatureInput extends React.Component{
			constructor(props){
				super(props);
				this.state={temperature:''}
			}
			handleChange=(e)=>{
				/*this.setState({
					temperature:e.target.value
				}); */
				this.props.onTemperatureChange(e.target.value);
			}
			render(){//挂起
				//const temperature=this.state.temperature;
				const temperature=this.props.temperature;
				const scale=this.props.scale;
				return (
					<fieldset>
						<legend>Enter temperature in {scaleNames[scale]}:</legend>
						<input value={temperature}
							onChange={this.handleChange}
						/>
					</fieldset>
				);
			}
		}
		class Calculator extends React.Component{
			constructor(props){
				super(props);
				this.state={temperature:'',scale:'c'}
			}
			handleCelsiusChange=(temperature)=>{
				this.setState({scale:'c',temperature});
			}
			handleFahrenheitChange=(temperature)=>{
				this.setState({scale:'f',temperature});
			}
			render(){
				const scale=this.state.scale;
				const temperature=this.state.temperature;
				const celsius = scale === 'f' ? tryConvert(temperature, toCelsius) : temperature;
				const fahrenheit = scale === 'c' ? tryConvert(temperature, toFahrenheit) : temperature;
				return (
					<div>
						<TemperatureInput  
							scale='c'
							temperature={celsius}
							onTemperatureChange={this.handleCelsiusChange} 
						/>
						<TemperatureInput  
							scale='f'
							temperature={fahrenheit}
							onTemperatureChange={this.handleFahrenheitChange} 
						/>
						<BoilingVerdict celsius={parseFloat(celsius)} />
					</div>
				);
			}
		}
		//state挂起  主要是在子组件中去影响父组件中的state值，即通过props属性想子组件传入父组件对应的函数，在子组件中调用即可
11.合成 VS 继承
	React有一个强大的合成模块，推荐在组件之间利用合成功能去替代继承
	//合成  包含
		推荐组件使用特殊的children属性去放置其孩子元素在该组件输出的时候
		function FancyBorder(props){
			return (
				<div className={'FancyBorder FancyBorder-'+props.color}>
					{props.children}//获取该组件的子元素
				</div>
			);
		}
		function WelcomeDialog(){
			return (
				<fancyborder color='blue'>
					<h1 className='Dialog-title'>Welcome</h1>
					<p className='Dialog-message'>Thank you for visiting our spacecraft!</p>
				</fancyborder>
			);
		}
		//这只是较小的相同，有时候你需要多样的 在组件中，你可以用自己的约定 去替代 children属性
			function SplitPane(props){
				return (
					<div className='SplitPane'>
						<div className='SplitPane-left'>
							{props.left}
						</div>
						<div className='SplitPane-right'>
							{props.right}
						</div>
					</div>
				);
			}
			function App(){
				return (
					<splitpane 
						left={ <Contacts />}
						right={ <Chat /> }
					/>
				);
			}
			//React元素像 <Contacts />仅仅是一个对象，所以它们能够像props的其他数据一样被解析
		//特殊化
			function Dialog(props){
				return (
					<Fancyborder color='blue'>
						<h1 className='Dialog-title'>{props.title}</h1>
						<p className='Dialog-message'>{props.message}</p>
					</Fancyborder>
				);
			}
			function WelcomeDialog(){
				return (
					<Dialog 
						title='Welcome'
						message='Thank you for visiting our spacecraft!'
					/>
				);
			}
	//继承
		我们利用React创建许多组件，但是我们没有发现任何案例中我们推荐创建组件的继承体系
		props和组件的合成 赋予了我们灵活的构建组件的表现与行为。组件可以接受**任意类型**的props属性
12.React的编程思想
    React是js构建大型，高性能Web应用的首选。
    》步骤1：将UI拆解到组件层次结构中
        单一职责原则：即一个组件理想情况下只处理一件事。如果一个组件持续膨胀，就应该将其拆分为多个更小的组件中。
    》步骤2：用React构建一个静态的版本
    》步骤3：确定UI state状态的最小(但完整)
        》是否通过props属性从父级传入？如果是这样，它可能不是state状态。
        》是否永远不会发生变化？如果是这样，它可能不是state状态。
        》是否可以由组件中其他的state状态或props计算得出？如果是这样，则它不是state状态。
    》步骤4：确定state状态的位置 -- 需要用到state数据的所有组件的父组件
        》用户输入的搜索文本
        》复选框的值
    》添加反向数据流
        子组件更新父级组件的state状态。
*****高级指南*****
1.深入jsx
    》实际上，jsx仅仅是为React.createElement(component,props,...children)函数提供了语法糖。
        //通过React.createElement创建组件
        React.createElement(
            MyButton,
            {color:"blue",shadowSize:2},
            "Click Me"
        )
        //通过jsx
        <MyButton color='blue' shadowSize={2}>Click Me</MyButton>
        /**********如果没有子节点 可以使用自关闭标签***********/
        //jsx
        <div className="sidebar"/>
        //createElement
        React.createElement("div",{className:"sidebar"},null);
	》指定 React元素的类型
	    jsx标签的第一部分决定了React元素的类型
	    大写类型表示jsx标签是指React组件，这些标签被编译成对命名变量的直接引用，所以如果使用jsx<Foo/>表达式，则Foo必须在范围内。

	    》react必须在范围内
	        由于jsx编译时调用React.createElement，所以React库必须始终在jsx代码的范围内。
	        如：

	        import React from 'react'
	        import CustomButton from './CustomButton'
	        //这两个导入都是必须的代码，即React并没有在CustomButton的js中直接引用
	        function WarningButton(){
	            return <CustomButton color='red'/>//编译时 return React.createElement(CustomButton,{color:"red",null});
	        }
	       注意：如果你不使用js绑定器并从<script>标签加载React，则它已经作为了React全局范围。
	    》对jsx使用点符号
	        在jsx中使用点符号表示引用React组件
	        import React from 'react'

	        const MyComponents = {
	            DatePicker(props){
	                return <div>Hello!</div>
	            }
	        }

	        function BlueDatePicker(){
	            return <MyComponents.DatePicker color="blue"/>
	        }
	    》自定义的组件名首位必须大写
	        当元素名称以小写字母开头时，它会引用一个内置的组件，如<div>或<span>将"div"或"span"传递给
	        React.createElement。
	        名称以大写字母开头，如<Foo/>编译时React.createElement(Foo)并对应于您的js文件中定义或导入的组件。

	        即：<hello />解析成普通的html标签，<Hello/>解析成组件标记

	        注意：建议用大写字母命名组件，如果组件以小写字母开头，请在jsx中使用之前将其分配给大写的变量。
	》在运行时根据名称选择组件
	    不能使用通用表达式来选择组件名称作为React组件，如果想使用通用表达式来指定组件，需要将其分配给大写的变量。
        const MyComponent = {
             test1(props){
                 return <div>测试jsx中的 "{props.ope}" 操作</div>
             },
            test2(){
                 return <div>test1</div>
            },
            test3(){
                return <div>test2</div>
            }
         }

        function Test2(props){
             //return <MyComponent[props.storyType] /> //错误

             //正确
             const CurrComponent = MyComponent[props.storyType];
             return <CurrComponent/>
         }
    》jsx中的属性
        》js表达式作为props
            可以使用js表达式作为属性值，在{}中书写。
            <MyComponent foo={ 1+2+3 }/>
            //if条件与for循环不是表达式在js中，所以不能直接被使用在jsx中
        》string作为属性值
            <Hello msg="hello"/>等价于<Hello msg={"hello"}/>

            <Hello msg="&lt;3"/>等价于<Hello msg={"<3"}/>
        》Props默认是true
            <Hello autocomplete/>等价于<Hello autocomplete={true}/>
        》属性的传播
            若有个props作为一个对象，当需要在jsx中解析时，可以使用...作为传播符将其解析成属性对象

            function App(){
                return <Greeting firstName="Ben" lastName="Hector"/>
            }
            等价于
            function App(){
                const props = {firstName="Ben",lastName="Hector"};
                return <Greeting {...props}/>
            }
    》jsx中的children
        在jsx的标签之间的内容有一个特殊的属性表示：props.children
        》string
            <Hello> Hello world! </Hello>
            //props.children表示"Hello world!"
            //注意jsx移除了开始与结束的空格
        》JSX children
            可以提供更多的jsx元素作为children，表示嵌套组件
            <MyContainer>
                <MyComponent /> //--children
            </MyContainer>
        》不同类型的children
            可以混合不同类型的作为children
            <div>
                Here is a list
                <ul>
                    <li>Item</li>
                </ul>
            </div>
        》js表达式作为children
            可以使用任何js表达式作为children，并通过{}包裹
            <Hello>foo</Hello>
            等价于
            <Hello>{"foo"}</Hello>

            //这种情况通过被使用在渲染一个list时
            function Item(props){
                return <li>{props.message}</li>;
            }
            function TodoList(){
                const todos= ['item1','item2','item3'];
                return <ul>
                            {
                                todos.map(msg => <Item key={msg} message={msg}/>)
                            }
                       </ul>
            }

            //js表达式能够和其他类型的children混合使用
            <div>Hello {props.addressee}</div>
        》Functions 作为children
            function Repeat(props){
                let items = [];
                for(let i=0;i<props.numTimes;i++){
                    items.push(props.children(i));
                }
                return <div>{items}</div>
            }

            function ListOfThings(){
                return <Repeat numTimes={10}>
                            {
                                index => <div key={index}> This is item {index} in the list!</div>
                            }
                       </Repeat>
            }
        》Booleans Null Undefined 是被忽略的
            false true null undefined是合法的children，只是他们不会被渲染。
            <div/>
            等价于
            <div>{false || null || true || undefined}</div>
2.使用PropType进行类型检测
    随着应用程序的增长，可以通过类型检测捕获大量错误。对于某些应用程序，可以使用像Flow或TypeScript这样的js扩展
    来对整个应用程序进行类型检查，但即使你不使用他们，React也有一些内置的类型检测功能。要在组件上运行类型检测，
    可以分配特殊的propTypes属性。
    import PropTypes from 'prop-types';
    class Greeting extends React.Component{
        render(){
            return <h1>Hello,{this.props.name}</h1>
        }
    }
    Greeting.propTypes = {
        name:PropTypes.string
    }
    //PropTypes导出一系列验证器，可用于确保你接受的数据有效，当提供无效的prop时，控制台将显示警告，出于性能
    //原因，propTypes仅在开发模式下进行检查

    》PropTypes中的验证
        import PropTypes from 'prop-types';
        MyComponent.propTypes = {
          optionalArray: PropTypes.array,
          optionalBool: PropTypes.bool,
          optionalFunc: PropTypes.func,
          optionalNumber: PropTypes.number,
          optionalObject: PropTypes.object,
          optionalString: PropTypes.string,
          optionalSymbol: PropTypes.symbol,

          // PropTypes.node包括： numbers, strings, elements or an array or fragment等类型
          optionalNode: PropTypes.node,

          // React元素
          optionalElement: PropTypes.element,

         //验证是否为实例
          optionalMessage: PropTypes.instanceOf(Message),

         //限制prop的属性值为指定列表中的一个
          optionalEnum: PropTypes.oneOf(['News', 'Photos']),

          //对于同一属性添加多个验证
          optionalUnion: PropTypes.oneOfType([
            PropTypes.string,
            PropTypes.number,
            PropTypes.instanceOf(Message)
          ]),

          // 某种类型的数组 如：number类型的数组
          optionalArrayOf: PropTypes.arrayOf(PropTypes.number),

          // 指定对象属性值的类型 如number
          optionalObjectOf: PropTypes.objectOf(PropTypes.number),

          // 分别指定对象属性的类型
          optionalObjectWithShape: PropTypes.shape({
            color: PropTypes.string,
            fontSize: PropTypes.number
          }),

          //指定是否必传某个props
          requiredFunc: PropTypes.func.isRequired,

          //任意的数据类型 + 必传
          requiredAny: PropTypes.any.isRequired,
          //自定义验证器
          customProp: function(props, propName, componentName) {
            if (!/matchme/.test(props[propName])) {
              return new Error(
                'Invalid prop `' + propName + '` supplied to' +
                ' `' + componentName + '`. Validation failed.'
              );
            }
          },

          // 可以为 `arrayOf` and `objectOf`提供自定义验证器的回调函数
          customArrayProp: PropTypes.arrayOf(function(propValue, key, componentName, location, propFullName) {
            if (!/matchme/.test(propValue[key])) {
              return new Error(
                'Invalid prop `' + propFullName + '` supplied to' +
                ' `' + componentName + '`. Validation failed.'
              );
            }
          })
        };
    》需要单一的child
        通过PropTypes.element可以实现单个child
        class MyComponent extends React.Component{
            render(){
                return <div>{ this.props.children }</div>
            }
        }
        MyComponent.propTypes = {
            children:PropTypes.element.isRequired//单一 必传的child
        }
    》默认prop的值
        你能给指定默认的属性值通过defaultProps属性
        class Greeting extends React.Component{
            render(){
                return <h1>Hello,{this.props.name}</h1>
            }
        }
        //指定默认值
        Greeting.defaultProps = {
            name:"Stranger"
        }
        //当组件没有传入相应的props时 defaultProps确保其有值，propTypes的验证发生在defaultProps解析后，所以propTypes也适用于defaultProps。
3. Refs与DOM
    在React数据流中，props仅仅是父子组件通信的一种方式，为了改变child，需要重新渲染新的props属性。
    然而在一些情况下，你需要改变child范围之外的数据流，这个child被改变通过React组件实例或DOM元素，为了
    满足这些场景，React提供了另一种方式。
    》Refs的优点
        管理焦点 文本选择或视屏播放
        触发动效
        集成第三方DOM库
        //注意：应避免在任何场景下都使用refs
    》不要过度使用refs
        通常，拥有该状态的适当位置是在层次结构中处于较高的级别
    》为DOM元素添加ref
        React提供了一个特殊的属性为你能够附加任何组件，这个ref属性需要一个回调函数，并且回调函数将在组件被
        挂载或销毁是立即执行
        当ref属性在html元素上使用时，它的回调接受**根DOM元素**作为参数传入。
        class CustomTextInput extends React.Component{
            constructor(props){
                super(props);
            }

            focusTextInput(){
                this.textInput.focus();
            }

            render(){
                return <div>
                            <input type="text" ref={ input => {this.textInput = input} }/>//传入当前元素
                            <input type="button" value="FOCUS" onClick={e => this.focusTextInput(e)}/>
                        </div>
            }
        }
    》为类组件添加ref
        当在自定义组件类上使用ref时，ref回调接受的参数时当前挂载的组件实例。
        class AutoFocusTextInput extends React.Component{
            componentDidMount(){
                this.currObj.focusTextInput();
            }

            render(){
                return <CustomTextInput ref={obj =>{this.currObj = obj;}}/>
            }
        }
    》Refs与函数组件
        你可能不会为函数组件使用ref属性，因为他们没有实例
        》当你在函数组件上使用ref时，无效需要将其转变成class组件，就像你需要使用生命hook与state一样
            function MyFunctionComponent(){
                return <input type="text" value="aaa"/>;
            }
            class Parent extends React.Component{
                render(){
                    return <MyFunctionComponent ref={obj=>{console.log(obj);/*null*/}}/>
                }
            }
        》只要引用DOM元素与类组件时，ref属性就可以在函数组件内部使用
            function CustomTextInputFun(props){
                let textInput = null;

                function handleClick(){
                    textInput.focus();
                }

                return <div>
                            <input type="text" ref={ elem=>{textInput=elem} }/>
                            <input type="button" value="FOCUSFUN" onClick={handleClick}/>
                        </div>
            }
    》将DOM的refs暴露给父组件
        在少数情况下，可能需要在父组件中获取子组件DOM节点。正常情况这种方式是不推荐的，因为它破坏了组件的封装，
        但它偶尔对于聚焦、量度大小或定位子组件DOM的位置是有用的。

        当为子组件添加ref时，这不是一个理想的解决方案，因为你仅仅能拿到组件的实例而不是DOM节点，并且，它是无效的
        对于函数组件。

        推荐在child组件中使用一个特殊prop属性，这个child组件提供一个任意名称的函数，并附加DOM节点作为ref属性。
        父节点通过中间组件将他自己的ref回调传递给child的DOM节点

            function CustomTextInputA(props){
                return <div>
                            <input type="text" ref={props.inputRef}/>
                        </div>
            }

            class ParentA extends React.Component{
                render(){
                    return <CustomTextInputA inputRef={ el=> this.inputElement = el}/>
                }

                componentDidMount(){
                    console.log(this.inputElement);
                }
            }
            //这种模式的另一个好处就是**无限制组件的深度**
            function CustomTextInputA(props){
                return <div>
                            <input type="text" ref={props.inputRef}/>
                        </div>
            }

            class ParentA extends React.Component{
                render(){
                    return <CustomTextInputA inputRef={ this.props.inputRef}/>
                }
            }

            class GrandParent extends React.Component{
                render(){
                    return <ParentA inputRef = { el=>this.inputElement = el}/>
                }

                componentDidMount(){
                    console.log(this.inputElement);
                }
            }
            //如果你不能控制子组件的实现，还有一种不推荐的做法：利用findDOMNode()
    》String类型的Refs
            class StringRefChild extends React.Component{
                render(){
                    return <div ref={"testStr"}>String Refs</div>
                }

                componentDidMount(){
                    console.log(this.refs.testStr);
                }
            }
            //由于一些遗留问题的存在，这种方式并不推荐，在后面的版本中可能被遗弃，推荐用前面的回调替代这种方式
    》注意：
        如果ref回调 被定义为一个行内元素，它将被调用两次，第一次返回null 第二次返回DOM元素，这是因为每次渲染时都有
        一个新的实例被创建，所以React需要清除旧的ref 设置新的ref，通过class的方式绑定回调函数，可以避免这种情况。
4. 没有被控制的组件
    在大多数，推荐使用控制组件定义表单，在控制组件中，表单数据被React组件处理。
    相反的是不受控制的组件，这里的表单数据被DOM自己处理。
    //没有被控制的组件案例
        class NameForm extends React.Component{
            constructor(props){
                super(props);
            }

            handleSubmit(e){
                e.preventDefault();

                console.log(this.input.value);
            }

            render(){
                return <form onSubmit={ e=> this.handleSubmit(e) }>
                            <label>Name: <input type="text" ref={ el => this.input = el }/></label>
                            <input type="submit" value="提交"/>
                        </form>
            }
        }
    //由于不受控制的组件保持了DOM的真实来源，当使用不受控制组件时，它更容易集成React与非React的代码，
    //如果你想快速开发时，它是有较少的代码，否则你应该使用受控制的组件。

    》默认值
        在React渲染的生命周期中，这个form中的value属性将覆盖DOM中的value值。在不受控制的组件中，你想React
        有一个初始值，但在后面的更新不受控制，为了解决，你需要用defaultValue属性替代DOM的value属性。
        <label>Name: <input type="text" defaultValue="Blob" ref={ el => this.input = el }/></label>

        <input type='checkbox'/>与<input type='radio' /> 提供defaultChecked
        <select>与<textarea> 提供defaultValue
5. 优化性能
    React内部采用了几个先进的技术为了减少DOM UI更新的开销。对于许多应用来说，使用React将会比较快速，而不需要做更多的工作为了
    优化性能。
    然而有几种方式可是使得react应用更加快速。
    》使用生产环境
        在开发环境中有许多警告，这在开发环境非常有用，但是会使得React更大、更慢，所以当部署代码的时候应该使用生产环境。
        使用React Developer工具检查 https://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi
        》使用npm run build
        》压缩js npm install --save-dev uglify-js-brunch
            brunch build -p
        》webpack
            new webpack.DefinePlugin({
              'process.env': {
                NODE_ENV: JSON.stringify('production')
              }
            }),
            new webpack.optimize.UglifyJsPlugin()
    》分析Chrome的性能卡
    》避免和解
        需要更新DOM 显示返回true，不需要更新返回false
        shouldComponentUpdate(nextProps, nextState) {
          return true;
        }
        //案例
        class CounterButton extends React.Component{
            constructor(props){
                super(props);
                this.state = {count:1}
            }

            shouldComponentUpdate(nextProps,nextState){//值改变了就更DOM 否则不更新DOM
                console.log(this.state,nextState);
                if(this.props.color !== nextProps.color){
                    return true;
                }

                if(this.state.count !== nextState.count){
                    return true;
                }

                return false;
            }

            render(){
                return <button color={this.props.color} onClick={() => this.setState(state => ({count:state.count +1}))}>
                        Count: {this.state.count}</button>
            }
        }
        //等同于
        class CounterButton extends React.PureComponent{//React.PureComponent类是对上面的封装，只需要继承即可达到效果
            constructor(props){
                super(props);
                this.state = {count:1}
            }

            render(){
                return <button color={this.props.color} onClick={() => this.setState(state => ({count:state.count+1}))}>
                        Count: {this.state.count}</button>;
            }
        }
        //大多数情况，应该使用React.PureComponent 而不是自己写shouldComponentUpdate。因为他仅仅是一个浅浅比较，如果这个prop或state突变时，
        //这个浅比较将失效所以你不能利用他
        class ListOfWords extends React.PureComponent{
            render(){
                return <div>{this.props.words.join(',')}</div>
            }
        }
        class WordAdder extends React.Component{
            constructor(props){
                super(props);
                this.state = {words:['food']}
            }

            handleClick(){
                const words = this.state.words;
                words.push('a');
                this.setState({words});
                console.log(words);
            }

            render(){
                return <div>
                            <button onClick={ e => this.handleClick(e) }>添加单词</button>
                            <ListOfWords words = {this.state.words}/>
                        </div>
            }
        }
        //上面的代码：PureComponent将在旧值与新值之间做一个简单的比较，一旦在handleClick中突变words数组
        //这个旧值和新值将匹配为相等，尽管数组中的值已经改变，ListOfWords也不会更新并重新渲染

        》不突变数据的功能
            避免上面问题最简单的方式：避免突变props或state。
            /***********针对数组**************/
            handleClick(){
                    this.setState(prevState => ({
                        words:prevState.words.concat(['a'])
                    }));
            }
            //ES6的实现
                    this.setState( prevState => ({
                        words:[...prevState.words,'b','c']
                    }));
            /***********针对对象**************/
            也可以使用类似的方式，改变对象数据而避免对象突变
            function updateColorMap(colormap){//突变
                colormap.right = 'blue'
            }
            //避免突变
            function updateColorMap(colormap){
                return Object.assign({},colormap,{right:"blue"});
            }
            或
            function updateColorMap(colormap){
                return {...colormap,right:"blue"};
            }
            》使用不可变的数据结构 -- https://github.com/facebook/immutable-js
                Immutable.js是另一种方式为了解决这个问题，他为共享数据结构提供了不变的，持久的集合。
                不变的：一旦创建，集合不能够在另一个时间点被修改
                持久的：新的集合能够从以前的集合中被创建，并且可以通过设置突变来创建。以前的集合在新的集合创建后也是有效的。
                结构共享：创建新的集合时尽量采用和旧集合相同的结构，减少复制，提高性能。

                不变使得追踪改变更容易，一个改变总是创建一个新的对象，我们只需要追踪引用地址是否改变即可。
                如：
                const x = {foo:"bar"};
                const y = x;
                y.foo = "baz";
                x===y//true
                //使用immutable.js
                const SomeRecord = Immutable.Record({ foo: null });
                const x = new SomeRecord({ foo: 'bar' });
                const y = x.set('foo', 'baz');
                const z = x.set('foo', 'bar');
                x === y; // false
                x === z; // true
6.无ES6的react
        通常你使用js的class定义一个React组件
        import React from 'react'
        class Greeting extends React.Component{
            render(){
                return <h1>Hello,{this.props.name}</h1>
            }
        }
        export default Greeting

        import WithoutEs6 from './withoutES6'
        ReactDom.render(<WithoutEs6 name="无ES6"/>,document.getElementById('app'))

        //当不使用ES6时，可以使用create-react-class模块来代替
        var createReactClass = require('create-react-class');
        var React = require('react');
        var Greeting = createReactClass({
            render:function(){
                return <h1>Hello,{this.props.name}</h1>
            }
        });

        module.exports = {
            Greeting:Greeting
        }

        const WithoutEs6 = require('./withoutES6');
        ReactDom.render(<WithoutEs6.Greeting name="无ES6"/>,document.getElementById('app'));

        /*************声明默认props************/
        //ES6 -- 使用函数和class组件的defaultProps属性
        import React from 'react'
        class Greeting extends React.Component{
            render(){
                return <h1>Hello,{this.props.name}</h1>
            }
        }
        Greeting.defaultProps = {
            name:"Mary"
        }
        export default Greeting
        //无ES6 -- 使用create-react-class时，需要定义getDefaultProps函数并返回对象
        var React = require('react');
        var createReactClass = require('create-react-class');
        var Greeting = createReactClass({
            render:function(){
                return <h1>Hello,{this.props.name}</h1>
            },
            getDefaultProps:function(){
                return {
                    name:"无ES6的默认props"
                }
            }
        });
        module.exports = {
            Greeting:Greeting
        }
        /*************初始化state************/
        //ES6 -- 定义初始化state在构造器中
        import React from 'react'
        class Counter extends React.Component{
            constructor(props){
                super(props);
                this.state = {count:props.initCount}
            }
            render(){
                return <h1>Hello,{this.state.count}</h1>
            }
        }
        export default Counter;
        //无ES6 -- create-react-class提供了getInitialState方法用于初始化state 返回state对象
        var React = require('react');
        var createReactClass = require('create-react-class');
        var Counter = createReactClass({
            render:function(){
                return <h1>Hello,{this.state.count}</h1>
            },
            getInitialState:function(){
                return {
                    count:this.props.initCount
                }
            }
        });
        module.exports = {
            Counter:Counter
        }
        /*************自动绑定************/
        //ES6 -- 用E6类定义的React组件，组件的方法遵循ES6类的规则，这意味着他们不会自动绑定this作为实例。
                你需要在构造器中明确的用.bind(this)绑定this。
        import React from 'react'
        class SayHello extends React.Component{
            constructor(props){
                super(props);
                this.state = {msg:"Hello!"};
                //绑定this
                this.handleClick = this.handleClick.bind(this);
            }

            handleClick(){
                alert(this.state.msg);
            }

            render(){
                return <button onClick={ this.handleClick }>HELLO</button>
            }
        }
        export default SayHello;

        //create-react-class -- 它是不需要明确绑定的，因为他自动绑定this到全部的方法中
        var React = require('react');
        var createReactClass = require('create-react-class');
        var SayHello = createReactClass({
            getInitialState:function(){
                return {
                    msg:"Hello! 无ES6"
                }
            },
            handleClick:function(){
                alert(this.state.msg);
            },
            render:function(){
                return <button onClick={ this.handleClick }>HELLO</button>
            }
        });
        module.exports = {
            hello:SayHello
        }
        //这意味着ES6对于事件处理 会额外多一些代码，但是对于大型项目 它会有较好的性能。

        //如果样本代码(额外的事件绑定this)对你没有吸引力，你可以使用Babel的Class语法提案
        class SayHello extends React.Component{
            constructor(props){
                super(props);
                this.state = {msg:"Hello!"}
            }

            handleClick = ()=>{//提案，使用箭头函数绑定this -- 该语法还在实验阶段
                alert(this.state.msg);
            }

            render(){
                return <button onClick={this.handleClick}>HELLO</button>
            }
        }
        //注意：上面语法是提案，如果你想更安全可以采用下面的方式
            》在构造器中绑定this
            》在事件中用箭头函数  onClick = { e => this.handleClick(e) }
            》继续使用createReactClass

        /*************Mixins************/
        注意：启用ES6没有任何的混合宏支持，因此，当使用ES6的类时，是不支持混合宏的。
        我在使用混合宏中发现了很多问题，并且不推荐使用混合宏。

        有时候不同的组件可能会共享一些相同的功能 -- 这叫cross-cutting concerns。createReactClass允许使用遗留的mixins系统。
        案例：
            var React = require('react');
            var createReactClass = require('create-react-class');

            //定义共享混合宏
            var SetIntervalMixin = {
                componentWillMount:function(){//挂载hook
                    this.intervals = []
                },
                setInterval:function(){
                    this.intervals.push(setInterval.apply(null,arguments));
                },
                componentWillUnmount:function(){
                    this.intervals.forEach(clearInterval);
                }
            }
            //声明组件
            var TickTock = createReactClass({
                mixins:[SetIntervalMixin],//使用混合宏
                getInitialState:function(){
                    return {seconds:0}
                },
                componentDidMount:function(){
                    this.setInterval(this.tick,1000);
                },
                tick:function(){
                    this.setState({
                        seconds:this.state.seconds +1
                    });
                },
                render:function(){
                    return <p>React has been running for {this.state.seconds} seconds</p>
                }
            });
            module.exports ={
                TickTock:TickTock
            }
            //如果一个组件定义了多个混合宏，并且几个混合宏定义了相同的生命hook函数。所有的生命hook将被调用。在混合宏
            //中定义的hook方法将按顺序被调用(同一自定义函数名不能在多个mixins中定义多次)
7.无JSX的React
        JSX不是使用React必须的，当你在你的构建环境中不想编译时，使用没有jsx的react是比较方便的。
        每个jsx仅仅是调用React.createElement(component,props,...children)的语法糖。所以在使用jsx
        的任何地方也可以直接使用js(即上面的API)。
        案例：
            /**********使用jsx***********/
            class Hello extends React.Component{
                render(){
                    return <div>Hello {this.props.toWhat}</div>
                }
            }
            /**********不使用jsx***********/
            class Hello extends React.Component{
                render(){
                    return React.createElement('div',null,`Hello ${ this.props.toWhat }`);//${ es6取变量 }
                }
            }

            ReactDom.render(
                React.createElement(WidthoutJsx,{toWhat:"无JSX"},null),
                document.getElementById('app')
            )
            //在线jsx转js：https://babeljs.io/repl/

            React.createElement(component,props,...children)中的component可以是String,继承React.Component的class或者
            没有state的函数组件。

            简写：
            const e = React.createElement;
            ReactDOM.render(
                e("div",null,'hello world'),
                document.getElementById('root')
            );
            //另外，可以参考一些社区项目，如： react-hyperscript(https://github.com/mlmorg/react-hyperscript)
            //与hyperscript-helpers(https://github.com/ohanhi/hyperscript-helpers)。他们提供了更简单的语法。
8.一致性比较 Reconciliation
        React提供声明式API，因此在每次更新中不需要关心具体的更改内容。这使得编写应用更加容易，但是这样使得对React
        内部具体实现并不了解，这里介绍了React的"diffing"算法中我们做出的抉择，以使得组件的更新是可预测的并且可以
        适用于高性能应用。
        》动机
            当你使用React，在任何一个单点时刻你可以认为render()函数的作用是创建React元素树。在下一个state或props更新时，
            render()函数将会返回一个不同的React元素树。接下来的问题是React将如何高效的更新UI来匹配最近时刻的React元素树。

            目前存在大量通用的方法能够以最少的操作将一个树转换成另一棵树，然而这个算法是复杂度为o(n^3),其中n为树的元素个数。

            React基于以下两个假设实现了时间复杂度为o(n)的算法：
                》不同类型的两个元素将会产生不同的树
                》开发人员可以使用一个key prop来指示在不同的渲染中那个那些元素可以保持稳定。
        》Diffing算法
            当比较不同的两个树，React首先比较两个根元素，根据根的类型不同，他有不同的行为。
            》元素类型不相同
                无论什么时候，当根元素类型不同时，React将会销毁原先的树并重写构建的新树。从<a>到<img>
                或从<Article>到<Comment>，从<Button>到<div>--这些都将导致全部重新构建。

                当销毁原先的树时，之前的DOM节点将销毁，实例组件执行componentWillUnmount()。
                当构建新的一个树，新的DOM节点将会插入DOM中，组件将会执行componentWillMount()以及componentDidMount()。与之前旧的树相关的state都会丢失。

                根节点以下的任何组件都会被卸载(unmounted),其state状态都会丢失。如：
                    <div>
                        <Counter />
                    </div>
                    到
                    <span>
                        <Counter/>
                    </span>
                    //这回销毁旧的Counter，重新加载一个新的Counter
            》DOM元素类型相同
                当比较两个相同类型的React DOM元素时，React检测他们的属性(attributes),保留相同的底层DOM节点，只更新发生改变的属性。
                如：
                    <div className='before' title='stuff'/>
                    <div className='after' title='stuff'/>
                    //通过比较两个元素，React仅会修改DOM节点的className属性

                当更新style属性，React也仅仅只更新改变的属性
                如：
                    <div style={ { color:"red",fontWeight:"bold" } }/>
                    <div style={ { color:"green",fontWeight:"bold" } }/>
                    //当React对两个元素进行转换时，仅会修改color 而不会修改fontWeight。
                    //在处理完当前DOM节点后，React会递归处理子节点
            》相同类型的组件
                当一个组件更新的时候，组件实例保持不变，以便在渲染中保持state。React会更新组件实例的属性来匹配新的元素，
                并在元素实例上调用componentWillReceiveProps()和componentWillUpdate()。

                然后，render()方法会被调用，并且diff算法对上一次的结果和新的结果进行递归。
            》子元素递归
                默认情况下，当递归一个DOM节点的子节点时，React只需同时遍历所有的孩子基点，同时当他们不同时，生成一个改变。
                如：//当给子元素末尾添加一个元素，在两棵树之间的转化中 性能就不错
                <ul>
                    <li>first</li>
                    <li>second</li>
                </ul>
                到
                <ul>
                    <li>first</li>
                    <li>second</li>
                    <li>third</li>
                </ul>
                //React会比较两个<li>first</li>树与两个<li>second</li>,最后插入<li>third</li>树

                如：在开始处插入一个节点，性能将会很差
                <ul>
                    <li>Duke</li>
                    <li>Villanova</li>
                </ul>
                到
                <ul>
                    <li>Connecticut</li>
                    <li>Duke</li>
                    <li>Villanova</li>
                </ul>
                //React会改变每一个子节点而不会意思到需要保留<li>Duke</li>与<li>Villanova</li>，从而性能将降低。
            》Keys
                为了解决上面的问题，React支持一个key属性(attribute)。当子节点有了key，React使用这个key去比较原来的树的子节点和之后树的
                节点。(这也是为什么key不推荐使用数组索引的原因)
                如：
                    <ul>
                        <li key='2015'>Duke</li>
                        <li key="2016">Villanova</li>
                    </ul>
                    到
                    <ul>
                        <li key='2014'>Connecticut</li>
                        <li key='2015'>Duke</li>
                        <li key="2016">Villanova</li>
                    </ul>
                    //这样就可以解决上面的问题了 现在 React 知道有'2014' key 的元素是新的， key为'2015' 和'2016'的两个元素仅仅
                    //只是被移动而已。

                    //key只需要兄弟节点之间唯一就行，不需要全局唯一

                    //作为最后的手段，你可以将数组中的索引作为 key 。如果它们从不重新排序，它们工作也很好，但
                    //是如果存在重新排序，性能将会很差。
            》权衡利弊
                reconciliation算法仅仅是一个实现细节。React会在每个操作上重新渲染整个应用，最终的结果可能是相同的。
                我们经常细化启发式算法，以便优化性能。

                在当前实现中，你可以表达这样一个事实，子树已经在兄弟节点中被移除，但是你不必告诉被移到什么位置。这个算法
                将会重新渲染整个子树。

                因为React依赖这个启发式，如果他们背后的假设没有得到满足，性能将会受到影响：
                    》算法不会尝试匹配不同节点类型的子树。如果你发现在有类似输出的两个不同节点类型中相互切换，
                      你可能需要将其转化成同种类型，事实上，我们没有在其中发现问题。

                    》keys 应该是稳定的、可预测的并且是唯一的。不稳定的 key (类似于 Math.random() 函数的结果)
                      可能会产生非常多的组件实例并且 DOM 节点也会非必要性的重新创建。这将会造成极大的性能损失
                      和组件内state的丢失。
9.上下文 Context
    注意：从React v15.5开始，React.PropTypes助手函数已被弃用，建议使用prop-types库来定义contextTypes。

    在React中，通过你的React组件很容易追踪数据流。但你查看一个组件时，你可以找出那些属性(props)被传递，这使得你的应用非常容易理解。

    在某些场景下，你想在整个组件树种传递数据，但却不想手动地在每一层传递属性，你可以直接在React中使用强大的"context"解决上面问题。

    》为什么不使用上下文(Context)
        》绝大多数的应用程序不需要使用上下文Context
        》如果希望应用程序更加稳定，就不要使用上下文Context。这只是一个实验性的API，并且可能在未来的React版本中移除。
        》如果你不熟悉Redux(https://github.com/reactjs/redux)或Mobx(https://github.com/mobxjs/mobx)这类state管理库，就不要使用
          Context。在许多实际应用中，这些库和React绑定是一个很好的state管理。Redux相比Context是更好的解决方案。
        》如果你不是一个经验丰富的React的开发者，就不要使用Context，更好的方式是使用props和state。
    》使用Context -- 通过将 childContextTypes 和 getChildContext 设置上下文，通过contextTypes 和this.context获取上下文
        import PropTypes from 'prop-types'

        class Button extends React.Component{
            render(){
                //使用上下文 属性
                console.log(this,"button*********************");
                return <button style= { {background:this.context.color} }>{ this.props.children }</button>
            }
        }
        //设置上下文属性的类型
        Button.contextTypes = {//如果子组件想拿到父组件定义的上下文，必须定义这个上下文类型
            color:PropTypes.string
        }

        class Msg extends React.Component{
            render(){
                console.log(this,"Msg*********************");
                return <div>{this.props.text} <Button>Delete</Button></div>
            }
        }

        class MsgList extends React.Component{
            getChildContext(){//设置context React自动向下传递信息，并且子组件都可以通过定义contextTypes去访问它。
                              // 如果contextTypes没有定义，context将是一个空对象。
                return {color:"purple"}
            }

            render(){
                const children = this.props.msgs.map(msg => <Msg text={msg.text} key = {msg.text}/>);

                return <div>{children}</div>
            }
        }
        MsgList.childContextTypes = {//设置上下文时，这个必须定义
            color:PropTypes.string
        }
    》父子耦合
        Context可以构建API使得父组件和子组件进行相互通信。如React Router V4就是使用这种方式的一个库。
        import {BrowserRouter as Router,Route,Link} from 'react-router-dom';

        const BasicExample = ()=>{
            <Router>
                <div>
                    <ul>
                        <li><Link to='/'>Home</Link></li>
                        <li><Link to='/about'>About</Link></li>
                        <li><Link to='/topics'>Topics</Link></li>
                    </ul>

                    <hr/>
                    <Route exact path="/" component={Home} />
                    <Route path="/about" component={About} />
                    <Route path="/topics" component={Topics} />
                </div>
            </Router>
        }
        //从Router组件向下传递一些信息，每一个Link和Route都可以沟通回到包含容器Router
    》在生命周期方法中引用Context
        如果contextTypes在组件中定义，下列的生命hook方法将接受一个额外的参数，context对象
        》constructor(props, context)
        》componentWillReceiveProps(nextProps, nextContext)
        》shouldComponentUpdate(nextProps, nextState, nextContext)
        》componentWillUpdate(nextProps, nextState, nextContext)
        》componentDidUpdate(prevProps, prevState, prevContext)
    》在无状态的函数式组件中引用Context
        无状态的函数式组件也可以引用context，如果contextTypes作为函数的属性被定义，下面代码展示一个无状态的函数式Button组件
        function Button({children},context){//{children} 获取this.props中的children
            console.log(context);
            return <button style={ {background:context.color} }>{children}</button>
        }
        //设置上下文属性类型
        Button.contextTypes = {
            color:PropTypes.string
        }
    》更新Context
        React有一个API更新context，但是它打破类基本流程，不应该使用。
        getChildContext函数会在每次state或props改变时调用。为了更新context中的数据，使用this.setState触发本地状态的更新。
        这将触发一个context并且数据的改变可以被子元素收到。

        class MediaQuery extends React.Component{
            constructor(props){
                super(props);
                this.state = {type:"desktop"}
            }

            getChildContext(){//设置context
                return {type:this.state.type}
            }

            componentDidMount(){
                const checkMediaQuery = ()=>{
                    const type = window.matchMedia("(min-width:1025px)").matches ? "desktop" :"mobile";

                    //更新state
                    if(type !== this.state.type) this.setState({type});
                }

                //添加监听事件
                window.addEventListener('resize',checkMediaQuery);

                //执行一次检测函数
                checkMediaQuery();
            }

            render(){
                return <ShowCurrState />;
            }
        }
        MediaQuery.childContextTypes = {
            type:PropTypes.string
        }

        function ShowCurrState(props,context){
            return <div>{context.type}</div>
        }
        ShowCurrState.contextTypes = {
            type:PropTypes.string
        }
        注意：组件提供的context值的改变，后代元素如果shouldComponentUpdate返回false，那么context
        的值将不会更新。这使得使用context的组件完全失控，所以基本上没有可靠的办法更新context。这也是
        为什么不推荐使用Context的原因。
10. Web Components
    React和Web Component是为了解决不同的问题而建立的。Web Component为了可重用组件提供了强大的封装，然而React提供声明库
    可以使得DOM和数据保持同步。两者的目标是互补的。你可以在你的Web Component中自由使用React或者在React中使用Web Component
    或者都使用。

    大多数使用React的开发者不使用Web Component，但是你可能想要使用Web Component，尤其是你正在使用Web Component编写的第三方UI库的情况下。

    /****************在Web Component中使用React******************/
    //定义web component
    const proto = Object.create(HTMLElement.prototype,{
        attachedCallback:{
            value:function(){
                const mountPoint = document.createElement('span');
                this.createShadowRoot().appendChild(mountPoint);

                const name = this.getAttribute('name');
                const url = 'https://www.google.com/search?q=' + encodeURIComponent(name);
                ReactDOM.render(<a href= {url}>{name}</a>,mountPoint);
            }
        }
    });
    document.registerElement('x-search',{prototype:proto});

    /****************在React中使用Web Components******************/
    class HelloMsg extends React.Component{
        render(){
            return <div>Hello <x-search>{ this.props.name }</x-search>!</div>
        }
    }
    注意：web components通常会对外暴露一个必须的API，为了访问web component的命令式API，需要使用
    ref与DOM节点直接交互。如果你使用的是第三方的web component，最好的解决方案是编写React组件作为
    web component的包装器。
    由于web component发出的事件可能不会沿着React渲染树正确传播，因此在你的React组件中，需要手动的添加
    事件处理程序来处理这些事件。

    一个常见的问题 Web Component使用class而不是className:
    function BrickFlipbox(){
        return <brick-flibox class='demo'></brick-flibox>//brick-flibox是Web components
    }
11.高阶组件
    在React中，高阶组件是**重用组件逻辑**的一项高级技术。高阶组件并不是React API的一部分。高阶组件源自于React生态。
    其实，高阶组件是一个函数，能够接受一个组件并返回一个新的组件
    即：const EnhancedComponent = higherOrderComponent(WrappedComponent);
    组件是将props转化为UI，然而高阶组件是将一个组件转化为另一个组件。
    React在第三方组件库中非常常见的，如：Redux的connect和 Relay's createContainer等等。

    》在横切关注点中使用高阶组件
        注意：mixins也是处理横切关注点的一种方法。但是mixin的弊端比较大。

        组件是React中代码重用的最小单元，然而某些模式并不能直接适应传统的组件
        案例：
            /**
             * 接受外部数据源 渲染评论列表的组件
             */
            class CommentList extends React.Component{
                constructor(props){
                    super(props);

                    this.state = {
                        comments:Datasource.getComments()
                    };

                    this.handleChange = this.handleChange.bind(this);
                }

                componentDidMount(){
                    DataSource.addChangeListener(this.handleChange);
                }

                componentWillUnmount(){
                    DataSource.removeChangeListener(this.handleChange);
                }

                handleChange(){
                    this.setState({
                        comments:DataSource.getComments()
                    });
                }

                render(){
                    return <div>
                                {
                                    this.state.comments.map(comment => <Comment comment={comment} key={ comment.id} />)
                                }
                            </div>
                }
            }

            /**
             * 订阅单个博文的组件
             */
            class BlogPost extends React.Component{
                constructor(props){
                    super(props);

                    this.handleChange = this.handleChange.bind(this);

                    this.state = {
                        blogPost:DataSource.getBlogPost(props.id)
                    }
                }

                componentDidMount(){
                    DataSource.addChangeListener(this.handleChange);
                }

                componentWillUnmount(){
                    DataSource.removeChangeListener(this.handleChange);
                }

                handleChange(){
                    this.setState({
                        blogPost:DataSource.getBlogPost(this.props.id)
                    });
                }

                render(){
                    return <TextBlock text={ this.state.blogPost}/>
                }
            }

            /**
             * CommentList和BlogPost是等价的，除了它们调用DataSource的不同方法，有不同的输出。但它们大部分的实现是类似的
             *      组件mount结束后，都添加DataSource的change监听
             *      除了监听函数，无论什么时候dataSource改变之后，都会调用setState
             *      组件unmount之后，都会移除监听
             *
             * 把公共的部分抽象出来，使得我们在一个地方定义逻辑并且在我们的组件中共享 -- 这就是高阶组件的优点
             *      我们可以写一个函数，能够创建类似于CommentList和BlogPost这类订阅DataSource的新的组件。这个函数接收
             *      一个子组件作为参数，这个子组件接受订阅数据源作为props，调用withSubscription
             */
            const CommentListWidthSubscription = withSubscription(CommentList,DataSource => DataSource.getComments());
            const BlogPostWidthSubscription = withSubscription(BlogPost,(DataSource,props) => DataSource.getBlogPost(props.id));

            /**
             *
             * @param WrappedComponent 被包含的组件
             * @param selectData 函数--根据给定的DataSource和当前props取回我们需要的数据
             */
            function widthSubscription(WrappedComponent,selectData){

                return HigherComponents;
            }

            /**
             * 当 CommentListWidthSubscription与BlogPostWidthSubscription被渲染的时候，CommentList和BlogPost将会
             * 被传递data属性，其中包含从DataSource取回的最新数据
             */
            class HigherComponents extends React.Component{

                constructor(props){
                    super(props);
                    this.handleChange = this.handleChange.bind(this);
                    this.state = {
                        data:selectData(DataSource,props)
                    }
                }

                componentDidMount(){
                    DataSource.addChangeListener(this.handleChange);
                }

                componentWillUnmount(){
                    DataSource.removeChangeListener(this.handleChange);
                }

                handleChange(){
                    this.setState({
                        data:selectData(DataSource,this.props)
                    });
                }

                render(){
                    //被包裹的元素接收container的所有props和新的props，并使用其渲染输出。
                    //高阶组件并不关心数据将会如何或者为什么使用，并且被包裹的元素并不关心数据的源头
                    return <WrappedComponent data={this.state.data} {...this.props }/>;
                }
            }
            /**
             * 结果：高阶组件既不会修改输入组件，也不会通过继承来复制行为。相反，通过包裹的形式，高阶组件
             *       将原先的组件组合在container组件中。高阶组件是纯函数，没有副作用。
             */


            /*******************注意事项**********************/

            /**
             * 1.不要改变原始组件，而是使用组合
             *      在高阶组件中要避免修改组件原型
             */
            //如下：就修改了原型
            function LogProps(InputComponent){
                InputComponent.prototype.componentWillReceiveProps = function(nextProps){
                    console.log(nextProps);
                }
                return InputComponent;
            }
            //相比于修改，高阶组件最好是通过输入组件包裹在容器组件的方式来使用组合
            function LogProps(WrappedComponent){
                return class extends React.Component {
                    componentWillReceiveProps(nextProps){
                        console.log(nextProps);
                    }
                    render(){
                        return <WrappedComponent {...this.props}/>;
                    }
                }
            }
            //上面的高阶组件与之前的修改原型的版本有着相同的功能，但又避免了潜在的冲突可能
            //高阶组件和容器组件的模式有相同之处，容器组件是分离责任策略的一部分，这个分离策略是关于
            //高层次和低层次关注点之间的责任分离。容器管理着类似订阅和状态这类东西，和给组件传递属性来处理类似渲染UI这类事情。
            //高阶组件使用容器作为其实现的一部分。可以将高阶组件视为定义参数化容器组件。

            /**
             * 2.约定：给包裹组件传递不相关的属性Props -- 帮助确定高阶组件能够足够的灵活和可以被重用
             *      高阶组件可以向组件添加功能，它不应该大幅度地改变功能，期望的是高阶组件返回的组件和被包裹的组件具有相似的界面
             */
            //高阶组件应该通过props传递那些与特定功能无关的特性，大多数的高阶组件包含如下的render函数
            render(){
                //过滤掉与高阶函数功能相关的props属性
                const {extraProp,...passThroughProps} = this.props;
                //向包裹组件注入props属性，一般是高阶组件的state状态或实例方法
                const injectedProp = someStateOrInstanceMethod;
                //向包裹组件传递props顺序
                return <WrappedComponent injectedProp={injectedProp} {...passThroughProps}/>
            }

            /**
             * 3. 约定：最大化组合
             */
            //不是所有的高阶组件看起来都是一样的，有时候，它接受包裹组件作为单一参数
            const NavbarWithRouter = withRouter(Navbar);
            //通常情况下，高阶组件接受其他参数
            const CommentWidthRelay = Relay.createContainer(Comment,config);
            //高阶组件最常见的签名
            const ConnectedComment = connect(commentSelector,commentActions)//返回一个函数 -- 高阶组件
                                        (CommentList);//调用高阶组件

            /**
             * 4.约定：为了方便调式 包装显示名称
             *      由于高阶属性创建的容器组件在React开发者工具中显示通其他的组件相似，为了方便调式，选择一个显示名称display name,表示它是高阶组件的结果。
             */
            //最常见的方法是给被包裹元素包裹一个显示名称display name。因此如果你的高阶组件名字为widthSubscription,被包裹的元素名称为CommentList，那就选择名称为
            //WidthSubscription(CommentList)
            function widthSubscription(WrappedComponent){
                class WidthSubscription extends  React.Component{};

                WidthSubscription.displayName = `WidthSubscription(${getDisplayName(WrappedComponent)})`

                return WidthSubscription;
            }
            function getDisplayName(WrappedComponent){
                return WrappedComponent.displayName || WrappedComponent.name || "Component";
            }

            /**
             * 5. 警告
             */
            // 5.1不要再render函数中使用高阶组件
            /**
             * React的diff算法又称为reconciliation使用组件标识符来决定是否应该更新已有的子树或将其抛弃并安装新的子树。
             * 如果从render返回的组件等同于(===)之前的render函数返回的组件，React将会迭代地通过diff算法更新子树到新的子树
             * 如果不相等则先前的子树将会完全卸载
             */
            //通常情况下，不需要考虑这些，但是这对于高阶组件非常重要，因为这意味着你在组件的render方法不能通过高阶组件产生
            render(){
                //每次render函数调用都会创建一个新的EnhancedComponent实例
                const EnhancedComponent = enhance(MyComponent);
                //每一次都会使得子对象完全被移除
                return <EnhancedComponent />
            }
            //在组件定义外应用高阶组件，以便于生成的组件只会被创建一次，然后他的标识符在每次渲染中都是相同的。

            //5.2静态方法必须复制
            //当你将一个组件应用于高阶组件时，虽然原有的组件被容器组件所包裹，但这也意味着新的组件没有之前组件的静态函数
            //定义静态方法
            WrappedComponent.staticMethod = function(){}

            //使用高阶组件
            const EnhancedComponent = enhance(WrappedComponent);
            EnhancedComponent.staticMethod === 'undefined'//true

            //复制原有的静态方法
            function enhance(WrappedComponent){
                class Enhance extends React.Component{}

                //复制
                Enhance.staticMethod = WrappedComponent.staticMethod;

                return Enhance;
            }
            //然而，上面的代码需要明确的晓得什么方法需要复制，可以使用hoist-non-react-statics来自动复制非React的静态方法
            import hoistNonReactStatic from 'hoist-non-react-statics';
            function enhance(WrappedComponent) {
                class Enhance extends React.Component {/*...*/}
                hoistNonReactStatic(Enhance, WrappedComponent);
                return Enhance;
            }
            //另一个有效的方法是将静态方法与组件本身相分离
            //将：
            MyComponent.someFunction = someFunction;
            export default  MyComponent;
            //换成：
            export {someFunction};
            import MyComponent,{someFunction} from './MyComponent';

            //5.3 Refs不会被传递
            /**
             * 高阶组件会给被包裹的组件传递所有的属性，但是不会传递refs。因为ref不是一个属性，就像key一样，它是由React特殊处理的。如果
             * 你给高阶组件产生的组件一个元素添加ref，ref引用的是外层容器组件的实例，而不是被包裹的组件。
             *
             * 最好的解决方法是避免使用ref，props是更好的选择
             */
            function Field({inputRef,...rest}){
                return <input ref={inputRef} {rest}/>;
            }
            //在高阶组件中增强Field组件
            const EnhancedFiled = enhance(Field)；

            //通过props传递ref
            <EnhancedFiled inputRef = {input =>{
                this.input = input;
            }}/>
12.与其他库的整合
    如何将React与jquery以及Backbone等其他库的结合使用。
    》与DOM节点操作类插件的结合
        最简单的方式就是阻止React更新外部在操作的节点，那么你可以通过生成一个React根本不会去更新的元素来实现，如：空的<div/>
        如：
        class SomePlugin extends React.Component{
            componentDidMount(){
                this.$el = $(this.el);//把ref引用的元素传递给jquery
                this.$el.somePlugin();
            }

            componentWillUnmount(){
                this.$el.somePlugin('destroy');
            }

            render(){
                return <div ref= {el => this.el = el}/>//这个div是空的 React就不会去更新它了 jquery就可以随意的更新它了
            }
        }

        》集成Jquery Chosen插件
            function Example(){
                return <Chosen onChange={ val =>console.log(val)}>
                                <option>A</option>
                                <option>B</option>
                                <option>C</option>
                        </Chosen>
            }

            //通过jquery 的Chosen插件 集成一个React的插件
            class Chosen extends React.Component{
                render(){
                    return <div>
                                <select className='Chosen-select' ref={el => this.el = el}>{this.props.children}</select>
                            </div>
                }

                componentDidMount(){
                    this.$el = $(this.el);
                    this.$el.chosen();

                    this.handleChange = this.handleChange.bind(this);
                    this.$el.on('change',this.handleChange);
                }

                componentWillUnmount(){
                    this.$el.off('change',this.handleChange);
                    this.$el.chosen('destroy');
                }

                handleChange(e){
                    this.props.onChange(e.target.value);
                }

                componentDidUpdate(prevProps){//手动更新
                    if(prevProps.children !== this.props.children){
                        this.$el.trigger('chosen:updated');
                    }
                }
            }
    》在React中使用其他引擎加载页面
        》在React中使用"字符串替换"类的库
            如：
            //jquery
            $("#container").html("<button id='btn'>Say Hello</button>");
            $("#btn").click(function(){alert('Hello!')});
            //React
            function Button(){
                return <button id='btn'>Say Hello</button>
            }
            ReactDom.render(<Button />,document.getElementById('container'),function(){
                $('#btn').click(function(){
                    alert('Hello!');
                });
            });
            /*************************/
            function Button(props){
                return <button onClick={props.onClick}>Say Hello</button>
            }

            function HelloButton(){
                function handleClick(){
                    alert('Hello!');
                }
                return <Button onClick={handleClick}/>
            }
            ReactDOM.render(<HelloButton />,document.getElementById('container'));
        》在React中使用Backbone视图
            Backbone的视图是很典型的HTML字符串，或者说是通过模板生成的DOM元素的函数。
            function Paragraph(props){
                return <p>{ props.text }</p>
            }
            const ParagraphView = Backbone.View.extend({
                render(){
                    const text = this.model.get('text');
                    ReactDOM.render(<Paragraph text={text} />,this.el);
                    return this;
                }
                remove(){
                    ReactDOM.unmountComponentAtNode(this.el);
                    Backbone.View.prototype.remove.call(this);
                }
            });
        》在React中使用其他数据层库和框架
            一般来说推荐大家使用符合单向数据流的框架和库，如：React state、Flux、Redux等，但React
            的组件也可以支持其他处理数据流的框架和库。
            》在React组件中使用Backbone处理数据
                如果想在React中使用Backbone处理数据模型，最简单的实现方式就是监听多个事件，然后手动调用方法，强制更新页面。

                //Item组件负责显示数据
                class Item extends React.Component{
                    constructor(props){
                        super(props);
                        this.handleChange = this.handleChange.bind(this);
                    }

                    handleChange(){
                        this.forceUpdate();//强制更新
                    }

                    componentDidMount(){
                        this.props.model.on('change',this.handleChange);
                    }

                    componentWillUnmount(){
                        this.props.model.off('change',this.handleChange);
                    }

                    render (){
                        return <li>{ this.props.model.get('text') }</li>
                    }
                }
                //List组件用来显示来自Backbone的数据
                class List extends React.Component{
                    constructor(props){
                        super(props);
                        this.handleChange = this.handleChange.bind(this);
                    }

                    handleChange(){
                        this.forceUpdate();
                    }

                    componentDidMount(){
                        this.props.collection.on('add','remove',this.handleChange);
                    }

                    componentWillUnmount(){
                        this.props.collection.off('add','remove',this.handleChange);
                    }

                    render(){
                        return <ul>
                            {this.props.collection.map(model => <Item key={model.cid} model={model}/>)}
                        </ul>
                    }
                }
            》从Backbone的数据模型中提取数据
                function connectToBackboneModel(WrappedComponent) {
                  return class BackboneComponent extends React.Component {
                    constructor(props) {
                      super(props);
                      this.state = Object.assign({}, props.model.attributes);
                      this.handleChange = this.handleChange.bind(this);
                    }

                    componentDidMount() {
                      this.props.model.on('change', this.handleChange);
                    }

                    componentWillReceiveProps(nextProps) {
                      this.setState(Object.assign({}, nextProps.model.attributes));
                      if (nextProps.model !== this.props.model) {
                        this.props.model.off('change', this.handleChange);
                        nextProps.model.on('change', this.handleChange);
                      }
                    }

                    componentWillUnmount() {
                      this.props.model.off('change', this.handleChange);
                    }

                    handleChange(model) {
                      this.setState(model.changedAttributes());
                    }

                    render() {
                      const propsExceptModel = Object.assign({}, this.props);
                      delete propsExceptModel.model;
                      return <WrappedComponent {...propsExceptModel} {...this.state} />;
                    }
                  }
                }

                function NameInput(props) {
                  return (
                    <p>
                      <input value={props.firstName} onChange={props.handleChange} />
                      <br />
                      My name is {props.firstName}.
                    </p>
                  );
                }

                const BackboneNameInput = connectToBackboneModel(NameInput);

                function Example(props) {
                  function handleChange(e) {
                    model.set('firstName', e.target.value);
                  }

                  return (
                    <BackboneNameInput
                      model={props.model}
                      handleChange={handleChange}
                    />
                  );
                }

                const model = new Backbone.Model({ firstName: 'Frodo' });
                ReactDOM.render(
                  <Example model={model} />,
                  document.getElementById('root')
                );
            //对于任何处理数据模型的库或框架，都可以在React中通过生命周期函数订阅它的变化事件，你还可以把这些数据直接复制到
            //React组件的state中。
13.可访问性
    可访问性的原因：
        web可访问性(a11y)是所有人都可以使用站点的设计与创建。可访问性的支持是辅助技术解析web页面的必要条件
        React是支持建立可访问性站点的，通常使用HTML标准。
    》标准与指导方针
        WCAG
             Web Content Accessibility Guidelines提供了关于创建可访问站点的指导方针。
             WCAG checklists提供了一个概述：
                WCAG checklist from Wuhcag
                WCAG checklist from WebAIM
                Checklist from The A11Y Project
        WAI-ARIA
             Web Accessibility Initiative - Accessible Rich Internet Applications文档包含了构建可访问js工具的技术。
             注意：所有的aria-*的html属性在jsx中是支持的。尽管大多数DOM属性在React中是camelCased(驼峰命名)，这些属性应该被小写。
             <input
                type='text'
                aria-label={labelText}
                aria-required='true'
                onChange = {onchangeHandle}
                value={inputValue}
                name='name'
             />
    》可访问的表单
        》Labeling
            所有的表单控件，如<input />等都需要一个可访问的labeled。我们需要提供一个描述性的labels，并且这些labels也会暴露
            给屏幕阅读者。
            尽管这些HTML标准能够直接用于React。但是label标签的for属性在JSX中被重写为htmlFor：
            <label htmlFor='namedInput'>Name:</label> <input id='namedInput' type='text' name='name'/>
        》焦点控制
            》键盘焦点和焦点轮廓
                键盘焦点指：DOM中被选中并接收键盘输入的当前元素。我们把它看成一个焦点轮廓。
            》用编程的方式管理焦点
                render(){
                    return <input type='text'
                        ref={ input => this.textInput =input}
                    />
                }
                focus(){
                    this.textInput.focus();
                }
/**********************API************************/
1. React
    React是React库的入口，如果你使用<script>标签来加载React，这些顶级API都在React这个全局变量上。
    如果你在npm下使用Es6，通过import React from 'react'。如果在npm下使用Es5通过var React = require('react');

    》组件
        React组件允许你将UI拆分为独立的可重用的模块，并且每一个模块逻辑也是独立的。React组件可以通过扩展React.Component
        或React.PureComponent来定义。
        》React.Component -- React组件使用Es6类定义时的基类
            class Greeting extends React.Component{
                render(){
                    return <h1>Hello,{ this.props.name }</h1>
                }
            }

        》React.PureComponent
            React.PureComponent与React.Component完全相同，但是前者在shouldComponentUpdate()中实现时，使用了props与state的浅比较。
            如果你的React的组件的render()函数在给定相同的props和state情况下，渲染相同的结果，在某些情况下，可以使用
            React.PureComponent来提高性能。
            注意：
                React.PureComponent的shouldComponentUpdate仅对对象进行浅比较。如果这些包含复杂的数据结构，它可能会在更深层数据
                差异比较时发生判断偏差。所以扩展PureComponent只能用于具有简单的props和state的组件，或者在知道深层数据结构已更改时
                使用forceUpdate()来强制更新组件。或者考虑使用不可变对象来帮助嵌套数据的快速比较。
                React.PureComponent的shouldComponentUpdate方法跳过了整个组件子树的props更新。所以确保来所有的子组件也是"pure"。

        注意：如果不使用ES6的类，可以使用create-react-class模块来替代。
    》创建React元素
        每个JSX元素都是调用React.createElement()的语法糖。
        》React.createElement(type,[props],[...children])
            创建并返回一个新的给定类型的React元素。这个type类型参数可以是一个标签名的字符串("div")，或者是React的组件类型(类或者函数)。

            React.DOM提供了一个方便的包装为DOM组件的React.createElement的方法。如React.DOM.a(...)是React.createElement('a',...)的方法包装。
            它们是被认为是遗留的API，推荐使用JSX或React.createElement()。

            使用JSX编写的代码将被转成使用React.createElement。如果使用JSX，则可以不必显示直接调用React.createElement()。

        》React.createFactory(type)
            返回一个函数，该函数生成给定类型的React元素。
            type参数可以是标签名字符串("div")，或React组件类型(类或函数)。

            这个函数被认为是遗留的API，推荐使用jsx或React.createElement()。
    》转换元素
        》React.cloneElement(element,[props],[...children])
            使用element作为起点，克隆并返回一个新的React元素。所产生的元素将具有原始元素的props，新的props为浅层合并，新的子元素将
            取代现有的子元素，key和ref将被保留。
            等效于：
            <element.type {...element.props} {...props}>{children}</element.type>
            然而它会保留ref，这意味着，如果你通过他上面的ref获取自己的子节点，你将不会有机会从你的祖先获取它，你只会获得绑定在你的新元素上
            的相同ref。

            这个API引入是作为废弃的React.addons.cloneWithProps() 替代品。

        》React.isValidElement(object)
            验证对象是否是一个React元素，返回true或false

        》React.Children
            React.Children提供了处理this.props.children这种不透明数据结构的实用程序。
            》React.Children.map(children,function[(thisArg)])
                对包含在children中的每个*直接*子元素调用一个函数，使用this设置thisArg。如果children是一个键片段或数组，
                它将被遍历，该函数永远不会传递容器对象。如果children是null或undefined，返回null或undefined而不是一个数组。
            》React.Children.forEach(children,function[(thisArg)])
                和上面map一样，但是不返回新的数组
            》React.Children.count(children)
                返回children中的组件总数，等于传递给map或forEach的回调被调用的次数。
            》React.Children.only(children)
                返回children中的唯一子集，否则抛出异常。
            》React.Children.toArray(children)
                将children不透明数据结构作为一个平面数组返回，并且key分配给每个子集。如果你想在渲染方法中操作children集合
                特别是想在传递它之间重新排序或切割this.props.children，这是很有用的。

                注意：React.Children.toArray() 更改 keys 去防止嵌套数组的语法当扁平化子节点列表。 也就是说，toArray为返回数
                        组中的每个key赋予前缀，以便将每个元素的 key 范围限定为包含它的输入数组。
2.React.Component
    》概述
        React.Component是一个抽象的基类，所以直接引用React.Component没有意义，相反通常会将其子类化，
        并且至少需要定义一个render()方法。
    》组件的生命周期
        每个组件都有几个"生命周期方法"，你可以重写这些方法，以在过程中的特定事件运行代码。前缀为will的方法在一些事情
        发生之前调用，而前缀为did的方法在一些事情发生后被调用。

        》Mounting
            当组件实例被创建并将其插入DOM时，调用下面hook：
            》constructor(props)
                在React组件被mounted前，该组件的constructor将被调用。当实现React.Component子类的constructor方法时，**应该在其他任何语句
                之前调用super(props)**,否则，this.props将在构造器中是undefined的，这将导致bug。

                constructor是初始化state的正确地方，如果不初始化state，并且不绑定方法，则不需要为React组件实现构造函数。

                //可以根据props来初始化state
                constructor(props){
                    super(props);
                    this.state = {
                        color:props.initalColor
                    }
                }
                //注意：state不会随着任何props更新而更新。通常不应该将props同步到state，应该提升state状态。
                如果通过"fork"props来作为state使用，可能还需要实现componentWillReceiveProps(nextProps)来保持state和它们同步更新，但是
                状态提升往往是更容易实现的，且不容易出错。

            》componentWillMount()
                在组件mounting发生之前被调用，它在render()之前调用。因此在此方法中设置的state不会触发重新渲染。避免在此方法中进行任何其他
                修改或订阅。

                这是在服务器渲染上调用的唯一的生命周期钩子，推荐使用constructor()。

            》render() -- 必需的
                当被调用时，它会检查this.props和this.state并返回一个单独的React元素。此元素可以是原生DOM组件的表示形式如:<div/>,
                也可以是你自定义的复合组件。

                也可以返回null或false来表示不想渲染任何东西。当返回null或false时，ReactDOM.findDOMNode(this)将返回null。

                render()函数应该是纯函数，这意味着它不会修改组件的状态，每次调用它时返回相同的结果，它不会直接与浏览器交互。
                如果需要与浏览器交互，选择使用其他生命hook方法执行你的逻辑，保持render()为纯函数使得组件更容易理解。

                注意：
                    shouldComponentUpdate()方法返回false，render()不会被调用。

            》componentDidMount()
                在组件mounting后被调用，需要初始化DOM节点的应该放在这里，如果需要从远程端点加载数据，这里是进行网络请求的好地方。
                此方法设置的state状态将触发重新渲染。

        》Updating
            改变props或state可以触发更新事件，在重新渲染组件时，这些方法将被调用：
            》componentWillReceiveProps(nextProps)
                在已mounted的组件接收到新的props之前调用。如果需要更新state以响应props的更改，则可以在此方法中比较this.props和
                nextProps并使用this.setState执行状态转换。

                注意：即使prop没有改变，React也可能调用这个方法，因此如果只想处理变化，请确保比较当前值和下一个值。当父组件导致你的
                组件重新渲染时，可能发生这种情况。

                在mount期间，React不会用初始化的props调用componentWillReceiveProps。如果某些组件的props可能更新，它只会调用此方法。
                调用this.setState一般不会触发componentWillReceiveProps。

            》shouldComponentUpdate(nextProps,nextState)
                使用shouldComponentUpdate()让React知道组件的输出是否不受state或props当前变化的影响。
                默认行为是在每次state更新时重新渲染，并且在绝大多数情况下，你应该依赖于默认行为。

                当接收到新的props或state时，shouldComponentUpdate()在渲染之前被调用。默认返回true，对于
                初始(第一次)渲染或使用forUpdate时，不调用此方法。

                返回false不会阻止子组件在state更改时重新渲染。

                目前，如果shouldComponentUpdate返回false，那么componentWillUpdate,render,componentDidUpdate将不会被调用。
                注意：在将来React可能将shouldComponentUpdate作为暗示而不是严格的指令，即返回false可能仍然导致组件的重新渲染。

                如果你确定一个特定的组件执行缓慢，可以使它继承React.PureComponent,它实现了具有props和state浅比较的shouldComponentUpdate()。
                如果你确信你想手工编写它，可以比较this.props和nextProps以及this.state和nextState,并返回false,告诉React可以跳过这次更新。

            》componentWillUpdate(nextProps,nextState)
                当接收到新的props或state时，componentWillUpdate在渲染之前立即被调用，在更新发生之前，使用这个方法可以作为执行准备更新的一个好机会。
                这个方法在第一次渲染时不会被调用。

                注意：
                    》这里不能调用this.setState(),如果你需要更新state以及响应props更改，需使用componentWillReceiveProps()。
                    》如果 shouldComponentUpdate() 返回 false ，那么 componentWillUpdate() 不会被调用。
            》render()
            》componentDidUpdate(prevProps,prevState)
                在更新发生后立即被调用。这个方法在第一次渲染时不会被调用。
                当组件已更新时，使用此方法作为操作DOM的一个机会，这也是做网络请求的一个好地方，只需要你比较当前props和以前的props，改变了就执行
                相应操作。

                注意：
                    如果 shouldComponentUpdate() 返回 false ，那么 componentDidUpdate() 不会被调用。

        》Unmounting
            当一个组件从DOM中删除时，这个方法将被调用：
            》componentWillUnmount()
                在一个组件被unmounted和destroyed之前立即被调用。在此方法中执行任何必要的清理。如：计时器无效，取消网络请求或清理在
                componentDidMount中创建的任何DOM元素。

    》实例方法
        》setState(updater,[callback])
            setState排队更改组件的state，并通过更新state来告诉React，该组件及其子组件需要重新渲染。这是用于响应事件处理程序和服务器响应
            更新用户界面的主要方法。

            注意：setState作为一个请求，而不是立即命令来更新组件。为了更好的感知性能，React可能会延迟它，然后合并多个setState更新多个组件。
                  React不保证state更新就立即应用(重新渲染)。

            setState并不总是立即更新组件。它可能会批量或延迟到后面的更新。这使得在调用setState之后立即读取this.state存在一个潜在的缺陷。
            而使用componentDidUpdate或setState回调，在应用更新后，都将被保证触发。

            setState总是会导致重新渲染，除非shouldComponentUpdate()返回false。如果可变对象被使用，并且条件渲染逻辑不能在shouldComponentUpdate()
            中实现，只有当新state与先前state不同时调用setState()才能避免不必要的重新渲染。

            参数：
                》updater -- 都是异步更新数据
                    》(prevState,props) => stateChange-->{}
                    》{}
                    updater输出的与prevState浅层合并
                》callback
                    将在setState完成后执行，并且重新渲染组件。通常这样的逻辑我们建议使用componentDidUpdate()

        》forceUpdate(callback)
            默认情况下，当组件的state或props改变时，组件将重新渲染。如果你的render()方法依赖于一些其他数据，你可以告诉
            React组件需要通过调用forceUpdate重新渲染。

            调用forceUpdate会导致组件跳过shouldComponentUpdate(),直接调用render()。这将触发子组件的正常生命周期方法，包括每个
            子组件的shouldComponentUpdate()方法。如果标记更改，React仍将更新DOM。

            通常应该尽量避免使用forceUpdate()，并且render()中的this.props和this.state应该是只读的。

    》类属性 -- 静态属性
        》defaultProps
            defaultProps可以定义组件类自身的属性，用来设置类的默认props。这用于未定义的props(undefined)但不用于null的props。
            class CustomButton extends React.Component{
                //...
            }
            CustomButton.defaultProps = {
                color:"blue"
            }

            如果没有提供props.color 它将默认设置为"blue":
            如果props.color设置为null，它将保持为null
                render(){
                    return <CustomButton color={null} />
                }

        》displayName
            displayName字符串被用在调式信息中，JSX自动设置设个值
    》实例属性
        》props
            this.props包含此组件的调用者定义的props。
            注意：this.props.children是一个特殊的props，通常由JSX表达式中的子标签定义而不是标签本身。
        》state
            state包含该组件的特定数据，该数据可能随时间而变化，状态是用户定义的。它应该是一个纯粹的js对象。
            如果你不在render()中使用它，它就不应该是state。

            注意：永远不要直接改变this.state,因为调用setState()之后可能会覆盖你所做的这个改变，把this.state看作是不可变的。
3.ReactDOM
    如果使用<script>标签加载React，这些在ReactDOM上的顶层API全局可用，如果你使用ES6与npm，你可以写import ReactDOM from 'react-dom'。
    如果使用Es5与npm，可以写var ReactDOM = require('react-dom');
    》概述
        react-dom包提供了DOM特定的方法，你可以在你的应用程序的顶层使用，如果你需要的话，也可以作为React模型之外的特殊操作DOM的接口。
        但大多数组件应该不需要使用这个模块。

        》render()
            ReactDOM.render(element,container,[callback]);
            渲染一个React元素到由container提供的DOM中，并且返回组件的一个引用(对于无状态组件返回null)。

            如果React元素先前已经被渲染到了container中，那么将对其执行更新，并且对DOM只修改需要修改的地方，以反映最新的React元素。

            如果提供了可选的回调，它将在组件渲染或更新后执行。

            注意：
                》ReactDOM.render()控制传入的容器节点的内容。当第一次调用时，容器内部的任何现有DOM元素都会被替换，之后使用React 的
                  DOM diffing算法来进行有效的更新。
                》ReactDOM.render() 不会修改容器节点，只修改容器的子节点，它可能插入一个组件到已经存在的DOM节点中而不会覆盖已经存在
                  的子节点。
                》ReactDOM.render() 当前返回根据ReactComponent实例的引用。但是使用此返回值是遗留的，应该避免使用，因为在某些情况下，
                  React的未来版本可能会异步渲染组件，如果你需要引用根ReactComponent实例，优选的解决方案是绑定一个ref回调到根元素。

        》unmountComponentAtNode()
            ReactDOM.unmountComponentAtNode(container);
            从DOM中移除已mounted的React组件，并清除其事件处理程序和state。如果在容器中没有挂载组件，调用此函数什么也不做。如果组件
            被卸载了返回true，如果没有要卸载的组件则返回false。
        》findDOMNode()
            ReactDOM.findDOMNode(component)
            如果组件已经被mounted到DOM中，这将返回相应的原生浏览器DOM元素。这个方法对读取DOM外的值是有用的，如：单字段值以及执行DOM分析。

            在大多数情况下，可以绑定一个ref到DOM节点上，从而避免使用findDOMNode。

            当render返回null或false时，findDOMNode将会返回null。

            注意：
                》findDOMNode是一个用于访问真实DOM节点的接口。在大多数情况下，不建议使用它，因为他会越过组件抽象层访问真实的DOM。
                》findDOMNode仅适用于已装载的组件，即已放置在DOM中的组件。如果你试图在一个尚未安装的组件上调用它，将抛出异常。
                》findDOMNode不能用于函数式组件。
    》浏览器支持
        React支持所有流行的浏览器，包括ie9及更高版本。
        注意：不支持那些不支持ES6方法的旧版浏览器，但如果页面中包含诸如es5-shim和es5-sham，应用也可以在旧版浏览器中正常工作。
4.ReactDOMServer
    如果使用<script>标签加载React，这些在ReactDOMServer上的顶层API全局可用。如果你使用ES6与npm，你可以写import ReactDOMServer from 'react-dom/server'。
    如果你使用ES5与npm，你可以写var ReactDOMServer = require('react-dom/server');

    》ReactDOMServer对象允许您在服务器上渲染组件
        》renderToString()
            ReactDOMServer.renderToString(element)
            将React元素渲染到其初始HTML中。该函数应该只在服务器上使用。

            React将返回一个HTML字符串。你可以使用此方法在服务器上生成html，并在初始化请求时发送标记，已加快网页加载速度。
            并允许搜索引擎抓取您的网页以实现SEO目的。

            如果在已经具有此服务器渲染标记的节点上调用ReactDOM.render()，React将保留它，并且只附加事件处理程序，从而使你拥有
            非常高性能的第一次加载体验。

            注意：此方法返回的流将以UTF-8编码的字节流返回，如果你需要另一种编码的流，
                  参考：https://www.npmjs.com/package/iconv-lite，其为转码文本提供了转换流。

        》renderToStaticMarkup(element)
            类似于renderToString，除了创建data-reactid外不创建额外的DOM属性，React在内部使用它。

            如果你想使用React作为一个简单的静态页面生成器，这很有用，因为去掉了额外的属性可以节省大量的字节。

            请注意，从此方法返回的流将以 utf-8 编码的字节流返回。转码同上。
5.ReactDOMNodeStream
    ES6+npm --> import ReactDOMNodeStream from 'react-dom/node-stream'
    ES5+npm --> var ReactDOMNodeStream = require('react-dom/node-stream')

    和React的其他包不同，ReactDOMNodeStream依赖于stream包，它在Node中可用，而不是在浏览器中。由于这个原因，ReactDOMNodeStream仅仅
    提供了Node的版本，而没有<script>标签引入的版本。

    》ReactDOMNodeStream允许你渲染你的组件在Node中，并且生成标记流。
        》renderToStream(element)
            渲染React元素为初始化HTML，它仅仅被用于Node中，在浏览器中它是不支持的，因为浏览器不支持Node的数据流。

            React将返回一个可读流用于输出HTML字符串。以流形式输出的HTML是等价于ReactDOMServer.renderToString的返回值。
            你能够使用这个方法在服务端生成HTML，并发送标记给初始化请求，达到更快的页面加载效果，并且允许搜索引擎SEO该页面。

            如果在已经具有此服务器渲染标记的节点上调用ReactDOM.render()，React将保留它，并且只附加事件处理程序，从而使你拥有
            非常高性能的第一次加载体验。

            注意：这个流的方法返回的是UTF-8的编码，如果想转换编码 同上使用 iconv-lite。

        》renderToStaticStream()
            ReactDOMNodeStream.renderToStaticStream(element)
            和renderToStream类似，除了不会创建额外的DOM属性以外如：reactid，React在内部使用它。

            如果你想使用React作为一个简单的静态页面生成器，这很有用，因为去掉了额外的属性可以节省大量的字节。

            请注意，从此方法返回的流将以 utf-8 编码的字节流返回。转码同上。
6.DOM元素
    React实现了一个独立于浏览器的DOM系统，用于提高性能和跨浏览器兼容性。

    在React中，所有的DOM properties和attributes(包括事件处理程序)都应该是驼峰命名法命名。
    如：html属性tabindex对应于React中的tabIndex属性。唯一的例外是aria-*和data-*属性它们应该是小写，
    如：aria-label就应该是aria-label，不需要驼峰式命名。

    》属性中的差异
        有许多属性在React和HTML之间有不同的使用方式：
        》checked
            类型为checkbox或radio的<input>组件支持checked属性。你可以使用它来设置该组件是否被选中。这对构建受控组件很有用。
            defaultChecked设置在首次载入组件时是否选中。
        》className
            要指定CSS类，需使用className属性。这适用于所有常规DOM和SVG元素。

            如果通过web components来使用React请改用class属性。
        》dangerouslySetInnerHTML
            dangerouslySetInnerHTML是React用于代替在浏览器DOM中使用innerHTML。一般来说，从代码设置HTML是有风险的。
            因为容易将用户暴露于**跨站点脚本(XSS)**攻击。所以你可以直接从React设置HTML，但是你必须使用dangerouslySetInnerHTML
            并通过__html键传递一个对象，提醒自己这是危险的。

            function TestDangerouslySetInnerHTML(){
                return <div dangerouslySetInnerHTML={ {__html:"<span>DANGEROUS XSS</span>"} }/>
            }
        》htmlFor
            由于for是js的保留字，React元素使用htmlFor。
        》onChange
            onChange事件的行为与期望的一样：每当表单字段更改时，将触发此事件。我们故意不使用现有的浏览器行为
            因为React依赖此事件来实时处理用户输入，onChange的表意与浏览器行为并不一致。
        》selected
            <option>组件支持selected属性，你可以使用它去设置组件是否被选中，这对构建受控的组件是有用的。
        》style
            style属性接受具有驼峰命名属性的js对象，而不是css字符串。这与js DOM的style属性一致，但是更高效，并且防止XSS安全漏洞。
            如：
            const divStyle = {
                color:"blue",
                backgroundImage:"url("+ imgUrl +")"
            }
            function Hello(){
                return <div style={ divStyle }>Hello</div>
            }
            注意：样式不自动进行兼容，要支持旧版本的浏览器，需要提供相应的样式属性
                const divStyle = {
                    WebkitTransition:"all",//首字母大写
                    msTransition:"all"//"ms"是唯一的小写字母的浏览器前缀 -- ms以外的供应商前缀应以大写字母开头
                }
        》suppressContentEditableWarning
            通常，当带有子代的元素被标记为contentEditable时，会出现警告，因为它不会起作用，此属性抑制该警告。
            不要使用它，除非你正在构建一个类似Draft.js的库，它手动管理contentEditable。
        》value
            <input>和<textarea>组件支持value属性，你可以使用它来设置组件的值。这对构建受控组件很有用。
            defaultValue是不受控组件的等同项，它设置组件首次装载时的值。
        》所有支持的HTML属性
            React支持所有的data-*与aria-*属性以及以下属性：
            accept acceptCharset accessKey action allowFullScreen allowTransparency alt
            async autoComplete autoFocus autoPlay capture cellPadding cellSpacing challenge
            charSet checked cite classID className colSpan cols content contentEditable
            contextMenu controls controlsList coords crossOrigin data dateTime default defer
            dir disabled download draggable encType form formAction formEncType formMethod
            formNoValidate formTarget frameBorder headers height hidden high href hrefLang
            htmlFor httpEquiv icon id inputMode integrity is keyParams keyType kind label
            lang list loop low manifest marginHeight marginWidth max maxLength media
            mediaGroup method min minLength multiple muted name noValidate nonce open
            optimum pattern placeholder poster preload profile radioGroup readOnly rel
            required reversed role rowSpan rows sandbox scope scoped scrolling seamless
            selected shape size sizes span spellCheck src srcDoc srcLang srcSet start step
            style summary tabIndex target title type useMap value width wmode wrap
            //RDFa属性的支持
            about datatype inlist prefix property resource typeof vocab
            //非标准的特性的支持
            Mobile Safari 中的 autoCapitalize autoCorrect 。
            Safari 中 <link rel="mask-icon" /> 的 color 。
            HTML5 microdata 中的 itemProp itemScope itemType itemRef itemID 。
            老版本IE浏览器中的 security 。
            Internet Explorer 的 unselectable 。
            对WebKit/Blink 中的 search 类型输入域中的 results autoSave。
        》所有支持的SVG属性
            accentHeight accumulate additive alignmentBaseline allowReorder alphabetic
            amplitude arabicForm ascent attributeName attributeType autoReverse azimuth
            baseFrequency baseProfile baselineShift bbox begin bias by calcMode capHeight
            clip clipPath clipPathUnits clipRule colorInterpolation
            colorInterpolationFilters colorProfile colorRendering contentScriptType
            contentStyleType cursor cx cy d decelerate descent diffuseConstant direction
            display divisor dominantBaseline dur dx dy edgeMode elevation enableBackground
            end exponent externalResourcesRequired fill fillOpacity fillRule filter
            filterRes filterUnits floodColor floodOpacity focusable fontFamily fontSize
            fontSizeAdjust fontStretch fontStyle fontVariant fontWeight format from fx fy
            g1 g2 glyphName glyphOrientationHorizontal glyphOrientationVertical glyphRef
            gradientTransform gradientUnits hanging horizAdvX horizOriginX ideographic
            imageRendering in in2 intercept k k1 k2 k3 k4 kernelMatrix kernelUnitLength
            kerning keyPoints keySplines keyTimes lengthAdjust letterSpacing lightingColor
            limitingConeAngle local markerEnd markerHeight markerMid markerStart
            markerUnits markerWidth mask maskContentUnits maskUnits mathematical mode
            numOctaves offset opacity operator order orient orientation origin overflow
            overlinePosition overlineThickness paintOrder panose1 pathLength
            patternContentUnits patternTransform patternUnits pointerEvents points
            pointsAtX pointsAtY pointsAtZ preserveAlpha preserveAspectRatio primitiveUnits
            r radius refX refY renderingIntent repeatCount repeatDur requiredExtensions
            requiredFeatures restart result rotate rx ry scale seed shapeRendering slope
            spacing specularConstant specularExponent speed spreadMethod startOffset
            stdDeviation stemh stemv stitchTiles stopColor stopOpacity
            strikethroughPosition strikethroughThickness string stroke strokeDasharray
            strokeDashoffset strokeLinecap strokeLinejoin strokeMiterlimit strokeOpacity
            strokeWidth surfaceScale systemLanguage tableValues targetX targetY textAnchor
            textDecoration textLength textRendering to transform u1 u2 underlinePosition
            underlineThickness unicode unicodeBidi unicodeRange unitsPerEm vAlphabetic
            vHanging vIdeographic vMathematical values vectorEffect version vertAdvY
            vertOriginX vertOriginY viewBox viewTarget visibility widths wordSpacing
            writingMode x x1 x2 xChannelSelector xHeight xlinkActuate xlinkArcrole
            xlinkHref xlinkRole xlinkShow xlinkTitle xlinkType xmlns xmlnsXlink xmlBase
            xmlLang xmlSpace y y1 y2 yChannelSelector z zoomAndPan
7.事件系统 SyntheticEvent
    》概述
        你的事件处理程序将传递SyntheticEvent的实例，这是一个跨浏览器原生事件包装器。它具有与浏览器原生事件相同的接口，包括
        stopPropagation()与preventDefault()，除了事件在所有浏览器中它们的工作方式都相同。

        如果由于某种原因需要底层浏览器事件，只需使用nativeEvent属性来获取它。每个SyntheticEvent对象都具有以下属性：
            boolean bubbles
            boolean cancelable
            DOMEventTarget currentTarget
            boolean defaultPrevented
            number eventPhase
            boolean isTrusted
            DOMEvent nativeEvent
            void preventDefault()
            boolean isDefaultPrevented()
            void stopPropagation()
            boolean isPropagationStopped()
            DOMEventTarget target
            number timeStamp
            string type
        注意：v.14起，事件处理程序返回false将不再停止事件传播，应该根据需要手动设置e.stopPropagation() 或 e.preventDefault() 。
    》事件池
        SyntheticEvent对象是通过合并得到的。这意味着在事件回调被调用后，SyntheticEvent对象将被重用，并且所有属性都将被取消。
        这是出于性能的原因。因此无法以异步方式访问该事件。
        注意：如果要以异步方式访问事件属性，应该对事件调用event.persist()，这将从池中删除合成事件，并允许用户代码保留对事件的引用。
    》被支持的事件
        React将事件规范化，以便它们在不同的浏览器中具有一致的属性。

        事件处理程序由冒泡阶段中的事件触发，要为捕获阶段注册事件处理程序，需将Capture附加到事件名称中。
        如：使用 onClickCapture 来处理捕获阶段中的点击事件，而不是使用 onClick 。
        》剪贴板事件 Clipboard Events
            事件名称：onCopy onCut onPaste
            属性：DOMDataTransfer(类型) --> clipboardData(属性)
        》合成事件 Composition Events
            事件名称：onCompositionEnd onCompositionStart onCompositionUpdate
            属性：string --> data
        》键盘事件 Keyboard Events
            事件名称：onKeyDown onKeyPress onKeyUp
            属性：
                boolean --> altKey
                number --> charCode
                boolean --> ctrlKey
                boolean --> getModifierState(key)
                string --> key
                number --> keyCode
                string --> locale
                number --> location
                boolean --> metaKey
                boolean --> repeat
                boolean --> shiftKey
                number --> which
        》焦点事件 Focus Events
            事件名称：onFocus onBlur 这些焦点事件工作在React DOM中的所有元素上，不仅仅是表单元素。
            属性：
                DOMEventTarget --> relatedTarget
        》表单事件 Form Events
            事件名称：
                onChange onInput onSubmit
        》鼠标事件 Mouse Events
            事件名称：
                onClick onContextMenu onDoubleClick onDrag onDragEnd onDragEnter onDragExit
                onDragLeave onDragOver onDragStart onDrop onMouseDown onMouseEnter onMouseLeave
                onMouseMove onMouseOut onMouseOver onMouseUp
            onMouseEnter和onMouseLeave事件从离开的元素传播到正在进入的元素，而不是普通的冒泡并且没有捕获阶段：

            属性：
                boolean altKey
                number button
                number buttons
                number clientX
                number clientY
                boolean ctrlKey
                boolean getModifierState(key)
                boolean metaKey
                number pageX
                number pageY
                DOMEventTarget relatedTarget
                number screenX
                number screenY
                boolean shiftKey
        》选择事件 Selection Events
            事件名称：onSelect
        》触摸事件 Touch Events
            事件名称：
                onTouchCancel onTouchEnd onTouchMove onTouchStart
            属性：
                boolean altKey
                DOMTouchList changedTouches
                boolean ctrlKey
                boolean getModifierState(key)
                boolean metaKey
                boolean shiftKey
                DOMTouchList targetTouches
                DOMTouchList touches
        》UI事件 UI Events
            事件名称：onScroll
            属性：
                number detail
                DOMAbstractView view
        》滚轮事件 Wheel Events
            事件名称：onWheel
            属性：
                number deltaMode
                number deltaX
                number deltaY
                number deltaZ
        》媒体事件 Media Events
            事件名称：
                onAbort onCanPlay onCanPlayThrough onDurationChange onEmptied onEncrypted
                onEnded onError onLoadedData onLoadedMetadata onLoadStart onPause onPlay
                onPlaying onProgress onRateChange onSeeked onSeeking onStalled onSuspend
                onTimeUpdate onVolumeChange onWaiting
        》图像事件 Image Events
            事件名称：
                onLoad onError
        》动画事件 Animation Events
            事件名称：
                onAnimationStart onAnimationEnd onAnimationIteration
            属性：
                string animationName
                string pseudoElement
                float elapsedTime
        》转换事件 Transition Events
            事件名称：
                onTransitionEnd
            属性：
                string propertyName
                string pseudoElement
                float elapsedTime
        》其他事件 Other Events
            事件名称：onToggle
8.Test Utilities
    import ReactTestUtils from 'react-dom/test-utils'; // ES6
    var ReactTestUtils = require('react-dom/test-utils'); // ES5 with npm

    ReactTestUtils是很容易测试React组件的。Facebook利用Jest(http://facebook.github.io/jest/docs/en/tutorial-react.html)测试js。
    Enzyme测试工具http://airbnb.io/enzyme/

    》浅渲染
        当为React写单元测试时，浅渲染时很有帮助的。浅渲染使得渲染一个组件仅仅为"一级深度"并断言它渲染的结果。不关注其子组件
        这些元素没有被实例化或渲染，是不需要DOM的。
        注意：浅渲染已经被移到react-test-renderer/shallow。

    》Simulate -- 模拟在DOM节点中的事件分发
        Simulate.{eventName}(
          element,
          [eventData]
        )
        注意：你需要提供相关事件，上面函数不会帮你创建相关事件
    》renderIntoDocument(element) -- 渲染一个React元素在独立的DOM节点中(即将组件渲染成一个DOM节点但是不将这个节点插入到视图中)
                                     这个函数需要一个DOM

        注意：你需要有window、window.document和window.document.createElement的全局属性在引入React之前。
              否则React认为他不能获取DOM，这个方法和setState一样。
    》mockComponent(componentClass,[mockTagName])
        传递一个虚拟的组件模块给这个方法，给这个组件扩充一些有用的方法，让组件能够被当初一个React组件的仿制品来使用。
        这个组件将会变成一个简单的<div>(或者是其他标签，如果mockTagName提供的话)。包含任何提供的子节点，而不像往常一
        样渲染出来。
    》isElement(element)
        element是React element 则返回true
    》isElementOfType(element,componentClass)
        如果element的类型是componentClass 则返回true
    》isDOMComponent(instance)
        instance是DOM组件，返回true
    》isCompositeComponent(instance)
        如果实例是用户定义的组件则返回true
    》isCompositeComponentWithType(instance,componentClass)
        如果实例的类型是componentClass,则返回true
    》findAllInRenderedTree(tree,testFunction)
        遍历tree中的所有组件，收集test(component)返回true的所有组件。这本身不是很有用，但是他可以为其他测试提供原始数据。
    》scryRenderedDOMComponentsWithClass(tree,ClassName)
        查找所有带有className的DOM组件
    》findRenderedDOMComponentWithClass(tree,className)
        类似于scryRenderedDOMComponentsWithClass()，但是它只返回一个结果，如果有其它满足条件的，则会抛出异常。
    》scryRenderedDOMComponentsWithTag(tree,tagName)
        在tree中找出标签名是tagName的所有元素
    》findRenderedDOMComponentWithTag(tree,tagName)
        类似于scryRenderedDOMComponentsWithTag()，但是它只返回一个结果，如果有其它满足条件的，则会抛出异常。
    》scryRenderedComponentsWithType(tree,componentClass)
        找出所有组件实例，这些组件的类型为componentClass
    》findRenderedComponentWithType(tree,componentClass)
        类似于scryRenderedComponentsWithType()，但是它只返回一个结果，如果有其它满足条件的，则会抛出异常。
9.Shallow Renderer
    import ShallowRenderer from 'react-test-renderer/shallow'; // ES6
    var ShallowRenderer = require('react-test-renderer/shallow'); // ES5 with npm

    浅渲染使得渲染一个组件仅仅为"一级深度"并断言它渲染的结果。不关注其子组件
    这些元素没有被实例化或渲染，是不需要DOM的。

    可以认为浅渲染是提供了一个测试渲染组件的位置，你可以提取组件的输出。
    》shallowRenderer.render()
        它和ReactDOM.render()，但是他不需要DOM仅仅是渲染一级深度，这意味着你能够测试与孩子分离的组件。

    》shallowRenderer.getRenderOutput()
        获取浅渲染的输出
    注意：浅渲染测试当前有些局限性，不支持refs
    我们推荐使用Enzyme's的shallow rendering API(http://airbnb.io/enzyme/docs/api/shallow.html)，它提供了
    一个更高级的API对于同样的功能。

*********************React路由**********************
http://618cj.com/react-router4-0%E8%B7%AF%E7%94%B1%E4%B8%AD%E6%96%87%E6%96%87%E6%A1%A3api/
1.安装
    npm install react-router
    或
    yarn add react-router

    npm i react-router-dom -S //react-router-dom是4.0从react-router分离出去的
    React Router 4.0里面有若干相互独立的包：
        》react-router React Router 核心
        》react-router-dom 用于 DOM 绑定的 React Router
        》react-router-native 用于 React Native 的 React Router
        》react-router-redux React Router 和 Redux 的集成
        》react-router-config 静态路由配置的小助手
2.开始
    import React from 'react'
    import {BrowserRouter as Router,Route,Link} from 'react-router-dom'//引入路由

    /**********************快速开始*************************/
    /**
     * 定义路由
     */
    const BasicExample = () =>
        <Router>
            <div>
                /**********定义路由链接***********/
                <ul>
                    <li><Link to="/">Home</Link></li>
                    <li><Link to="/about">About</Link></li>
                    <li><Link to="/topics">Topics</Link></li>
                </ul>

                <hr/>

                /**********定义视图显示***********/
                <Route exact path="/" component={Home}/>
                <Route path='/about' component={About}/>
                <Route path="/topics" component={Topics}/>
            </div>
        </Router>;
    /**
     * 定义组件
     */
    const Home = () =>
        <div>
            <h2>Home</h2>
        </div>;

    const About = () =>
        <div>
            <h2>About</h2>
        </div>;

    const Topics = ({match}) =>(
      <div>
          <h2>Topics</h2>
          <ul>
              <li>
                  <Link to={ `${match.url}/rendering` }>Rendering width React</Link>
              </li>
              <li>
                  <Link to={ `${match.url}/components` }>Components</Link>
              </li>
              <li>
                  <Link to={ `${match.url}/props-v-state` }>Props v. State</Link>
              </li>
          </ul>

          <Route path={ `${match.url}/:topicId` } component={Topic}/>
          <Route exact path={match.url} render={ ()=> <h3>Please select a topic.</h3>}/>
      </div>
    );

    const Topic = ({match}) =>{
        console.log(match);

        return <div>
            <h3>{match.params.topicId}</h3>
        </div>
    }

    export default BasicExample;
3.服务器端渲染
    服务端渲染最大的不同是无state的。其基本思想是通过无状态的<StaticRouter>来包裹我们的应用，而不是<BrowserRouter>
    我们通过请求url来匹配routes。
        //客户端
        <BrowserRouter>
            <App/>
        </BrowserRouter>
        //服务端
        <StaticRouter
            location={req.url}
            context={context}
        >
            <App/>
        </StaticRouter>
    当你渲染一个<Redirect>在客户端，这个浏览器的地址改变，并且我们能得到一个新的视图。在静态的服务器环境，我们不能
    改变app的状态，而是利用context属性寻找渲染结果，如果我们发现context.url我们就知道app已经被重定向，这允许我们发送
    正确的重定向从服务器。
        const context = {}
        const markup = ReactDOMServer.renderToString(
            <StaticRouter
                location={req.url}
                context={context}
            >
                <App/>
            </StaticRouter>
        );
        if(context.url){
            redirect(301,context.url);//<Redirect>被渲染
        }else{
            //发送请求
        }
    》为app添加特定的上下文信息
        这个路由仅仅添加来context.url。但是你可以添加其他重定向信息，如：301，302等。或你可能需要一个404的响应为渲染一些
        其他的UI分支，或者没有权限的401。这个context属性是你的，你可以改变它。
        下面是区分301与302的重定向方法。
        const RedirectWidthStatus = ({from,to,status}) =>(
            <Route
                render={
                    ({staticContext}) =>{
                        //在客户端是没有staticContext的，所以需要加判断
                        if(staticContext) staticContext.status = status;

                        return <Redirect from={from} to={to}/>
                    }
                }
            />
        );

        const App = ()=>(
            <Switch>
                {/**其他路由*/}
                <RedirectWidthStatus
                    status={301}
                    from="/users"
                    to="/profiles"
                />
                <RedirectWidthStatus
                    status={302}
                    from="/courses"
                    to="/dashboard"
                />
            </Switch>
        )

        const context = {}
        const markup = ReactDOMServer.renderToString(
            <StaticRouter context={context}>
                <App/>
            </StaticRouter>
        );
        if(context.url){
            redirect(context.status,context.url);
        }
    》401 404或其他状态
        const Status = ({code,children}) => (
            <Route
                render={
                    ({staticContext}) =>(
                        if(staticContext) staticContext.status = code;

                        return children;
                    )
                }
            />
        );

        const NotFound = () => (
            <Status code={404}>
                <div>
                    <h1>Sorry,can't find that.</h1>
                </div>
            </Status>
        )

        <Switch>
            <Route path='/about' component = {About} />
            <Route path="/dashboard" component={Dashboard} />
            <Route component={NotFound}/>
        </Switch>
    》代码整理
        /**************服务端*************/
        import { createServer } from 'http'
        import React from 'react'
        import ReactDOMServer from 'react-dom/server'
        import {StaticRouter} from 'react-router'
        import App from './App'

        //开启服务
        createServer((req,res) =>{
            const context = {}

            const html = ReactDOMServer.renderToString(
                <StaticRouter
                    location={req.url}
                    context={context}
                >
                    <App/>
                </StaticRouter>
            );

            if(context.url){
                res.writeHead(301,{
                    Location:context.url
                })
                res.end();
            }else{
                res.write(`
                    <!doctype html>
                    <div id="app">${html}</div>
                `);
                res.end();
            }
        }).listen(3000);

        /**************客户端*************/
        import ReactDOM from 'react-dom'
        import {BrowserRouter} from 'react-router-dom'
        import App from './App'
        ReactDOM.render(
            <BrowserRouter><App/></BrowserRouter>,document.getElementById('app')
        );
    》数据加载
        const routes = [
            {
                path:"/",
                component:Root,
                loadData:() => getSomeData()
            }
        ]

        import { routes } from './routes'
        const App => (
            <Switch>
                {
                    routes.map(route => (
                        <Route {...route} />
                    ))
                }
            </Switch>
        );

        import { matchPath } from 'react-router-dom'
        const promises = [];
        routes.some(route => {
            const match = matchPath(req.url,route)
            if(match) promises.push(route.loadData(match));

            return match;
        });
        Promise.all(promises).then(data => {
            //处理数据
        });
4.代码拆分
    Code Splitting是一个非常酷的特性，它能让我们用户无需完整下载整个App即可使用。你可以将它认为是增量加载我们的应用。尽管有一些其他
    工具也能实现相关特性，但在这里我们使用Webpack和bundle loader。
    你可以通过<Bundle>来实现网站的code splitting。需要注意的是，router并没有为实现code splitting而做额外的工作。当你进入一个路由仅仅
    意味着你渲染了一个组件，所以我们能在用户导航到某个路由时动态引入这个组件。你可以通过这种方式在应用的任何地方使用code splitting。
    》如果一个模块是一个组件
        这个组件需要一个名为load的属性，我们能够通过webpack bundle-loader获取。当组件获取一个新的load属性时，它将调用load，然后
        把结果返回到state中，最后渲染这个模块。

        import loadSomething from 'bundle-loader?lazy!./Something'
        <Bundle load={ loadSomething }>
            {
                mod => (
                    //做一些事情
                )
            }
        </Bundle>

        <Bundle load={ loadSomething }>
            {
                Comp => Comp ? <Comp/> : <Loading/>
            }
        </Bundle>

        import React, { Component } from 'react'
        class Bundle extends Component{
            state = {
                mod:null
            }

            componentWillMount (){
                this.load(this.props);
            }

            componentWillReceiveProps(nextProps){
                if(nextProps.load !== this.props.load){
                    this.load(nextProps);
                }
            }

            load(props) {
                this.setState({
                  mod: null
                })
                props.load((mod) => {
                  this.setState({
                    mod: mod.default ? mod.default : mod
                  })
                })
              }

              render() {
                return this.props.children(this.state.mod)
              }
        }
        export default Bundle;

        <Bundle load = { () => import ('./something ')}>{ mod => ()}</Bundle>
    》加载在渲染之后完成
        Bundle组件最大的好处是当开启一个新页面时加载，并且他也是有助于预加载的。
        你的应用加载时间是你自己决定的，他不需要在特定的路由，可能是用户不活跃时，也可能是进入某个路由时，也可能是初始化渲染之后等等。
           import LoadAbout from 'bundle-loader?lazy!./router/About'
           import loadDashboard from 'bundle-loader?lazy!./router/Dashborad'
           import Bundle from './router/bundle'

           const About = () => (
               <Bundle load={ LoadAbout }>
                   { About =>
                       {
                           return About ? <About/> :null
                       }
                   }
               </Bundle>
           );

           const Dashboard = () => (
               <Bundle load={ loadDashboard }>
                   {
                       Dashboard => {
                           return Dashboard ? <Dashboard/> : null;
                       }
                   }
               </Bundle>
           );

           class BundleTest extends React.Component{
               componentDidMount(){//挂载之后 懒加载组件
                   LoadAbout( () => {});
                   loadDashboard( () => {});
               }

               render(){
                   return <div>
                       <h1>Welcome!</h1>
                       <Router>
                           <div>
                               <Link to="/about">about</Link>
                               <Link to="/dashboard">dashboard</Link>
                               <hr/>
                               <Route path='/about' component={ About }/>
                               <Route path='/dashboard' component={ Dashboard }/>
                           </div>
                       </Router>
                   </div>
               }
           }

           export default BundleTest
    》代码拆分与服务器渲染
        我们尝试了几次的并且失败了
            》你需要同步模块解析在服务器上，以便于你在初始化渲染的时候获取到这些模块
            》您需要在呈现前将涉及到服务器呈现的所有绑定包加载，以便客户端呈现与服务器呈现相同的内容。
              (最棘手的部分，我认为这是可能的，但这是我放弃的地方。)
            》您需要异步解决客户端应用程序的其他生命。
5.Scroll Restoration 滚动恢复
    在早期版本的React Router中，我们提供了对滚动恢复的支持，从那时起人们就一直在要求它。
    希望这个文档能够帮助您从滚动条和路由中获得所需的内容!
    》Scroll to top
        大多数情况你需要滚动到顶部，因为你有一个很长的也没，当url改变时，它会滚动到以前的位置。
        <ScrollToTop>组件就可以实现。
        import React from 'react'
        import {withRouter} from 'react-router-dom'
        class ScrollToTop extends React.Component{
            componentDidUpdate(prevProps){
                if( this.props.location !== prevProps.location ){
                    window.scrollTo(0,0);
                }
            }

            render(){
                return this.props.children;
            }
        }
        export default withRouter(ScrollToTop);
6.测试
    React路由依赖于React的context，这将影响你测试自己的组件
    》context
        如果你试图单元测试一个组件，它渲染了<Link>或<Route>。你将得到一些关于上下文的错误或警告。尽管你可能尝试
        处理你的上下文，我们推荐你在<StaticRouter>或<MemoryRouter>中写单元测试。
        class Sidebar extends Component{
            render(){
                return <div>
                    <button onClick={ this.toggleExpand }>expand</button>
                    <ul>
                        {
                            users.map( user => (
                                <li>
                                    <Link to={user.path}>{ user.name }</Link>//使用了<Link>
                                </li>
                            ))
                        }
                    </ul>
                </div>
            }
        }

        //不好的测试
        test('it expands when the button is clicked', () => {
          render(
            <Sidebar/>
          )
          click(theButton)
          expect(theThingToBeOpen)
        })
        //好的
        test('it expands when the button is clicked', () => {
          render(
            <MemoryRouter>
              <Sidebar/>
            </MemoryRouter>
          )
          click(theButton)
          expect(theThingToBeOpen)
        })
    》开始一个特殊的路由
        <MemoryRouter>支持initialEntries和initialIndex属性，你能够在特定的地方启用一个应用程序(或应用程序的一部分)。
        test('current user is active in sidebar', () => {
          render(
            <MemoryRouter initialEntries={[ '/users/2' ]}>
              <Sidebar/>
            </MemoryRouter>
          )
          expectUserToBeActive(2)
        })
    》导航栏
        我们有许多路由工作的测试当这个url改变时，所以你可能不需要测试这些东西。但是如果你一定要测试这些，
        因为一切都是在渲染中发生的，我们有一些简便的方式。
        import { render, unmountComponentAtNode } from 'react-dom'
        import React from 'react'
        import { Route, Link, MemoryRouter } from 'react-router-dom'
        import { Simulate } from 'react-addons-test-utils'

        const renderTestSequence = ({
          initialEntries,
          initialIndex,
          subject: Subject,
          steps
        }) => {
          const div = document.createElement('div')

          class Assert extends React.Component {

            componentDidMount() {
              this.assert()
            }

            componentDidUpdate() {
              this.assert()
            }

            assert() {
              const nextStep = steps.shift()
              if (nextStep) {
                nextStep({ ...this.props, div })
              } else {
                unmountComponentAtNode(div)
              }
            }

            render() {
              return this.props.children
            }
          }

          class Test extends React.Component {
            render() {
              return (
                <MemoryRouter
                  initialIndex={initialIndex}
                  initialEntries={initialEntries}
                >
                  <Route render={(props) => (
                    <Assert {...props}>
                      <Subject/>
                    </Assert>
                  )}/>
                </MemoryRouter>
              )
            }
          }

          render(<Test/>, div)
        }

        const App = () => (
          <div>
            <Route exact path="/" render={() => (
              <div>
                <h1>Welcome</h1>
              </div>
            )}/>
            <Route path="/dashboard" render={() => (
              <div>
                <h1>Dashboard</h1>
                <Link to="/" id="click-me">Home</Link>
              </div>
            )}/>
          </div>
        )

        it('navigates around', (done) => {

          renderTestSequence({

            subject: App,

            steps: [

              // initial render
              ({ history, div }) => {
                // assert the screen says what we think it should
                console.assert(div.innerHTML.match(/Welcome/))

                // now we can imperatively navigate as the test
                history.push('/dashboard')
              },

              // second render from new location
              ({ div }) => {
                console.assert(div.innerHTML.match(/Dashboard/))

                // or we can simulate clicks on Links instead of
                // using history.push
                Simulate.click(div.querySelector('#click-me'), {
                  button: 0
                })
              },

              // final render
              ({ location }) => {
                console.assert(location.pathname === '/')
                // you'll want something like `done()` so your test
                // fails if you never make it here.
                done()
              }
            ]
          })
        })
7.Redux集成
    Redux时React生态系统里面一个重要的部分，我们希望使用React Router与Redux尽可能的无缝的使用两者。
    React Router v4中，React Router Redux包是router项目中的一个部分，参考它进行集成。
8.Static Routes
    以前版本的React路由器使用静态路由来配置应用程序的路由。这允许在渲染之前检查和匹配路由。
    由于v4移动到动态组件而不是路由configs，一些以前的用例变得不那么明显和棘手。
9.API汇总
    》<BrowserRouter>
        <Router>使用h5提供的history API(pushState,replaceState和popState事件)来保持UI和URL的同步。
        <BrowserRouter
            basename: string //当前位置的基准URL。如果你的页面部署在服务器的二级子目录中，你需要将此属性设置到此子目录。
                            //正确的URL格式是前面有一个前导斜杠，但是不能有尾部斜杠。
            getUserConfirmation: func//当导航需要确认时执行的函数，默认使用window.confirm
            forceRefresh: bool//当设置为true时，在导航的过程中整个页面将会刷新。只有当浏览器不支持h5的history API 才设置为true
            keyLength: number//location.key的长度。默认是6
            children: node//渲染单一子组件(元素)
        >
            <App/>
        </BrowserRouter>
    》<HashRouter>
        HashRouter是一种特定的<Router>,HashRouter使用URL的hash(如：window.location.hash)来保持UI和URL的同步。
        注意：使用hash的方式记录导航历史不支持location.key和location.state。在以前的版本中，我们为这种行为提供了
        shim，但是仍有一些问题无法解决。任何依赖此行为的代码或插件都将无法正常使用。由于该技术仅用于支持传统
        的浏览器，因此在用于浏览器时可以使用<BrowserHistory>代替。
        <HashRouter
            basename: string//当前位置的基准URL，正确的URL格式是前面有一个前导斜杠，但不能有尾部斜杠
            getUserConfirmation: func//当导航需要确认时执行的函数，默认使用window.confirm
            hashType: string//window.location.hash使用的hash类型，有如下几种：
                            //"slash" - 后面跟一个斜杠，例如 #/ 和 #/sunshine/lollipops 默认值
                            //"noslash" - 后面没有斜杠，例如 # 和 #sunshine/lollipops
                            //"hashbang" - Google 风格的 “ajax crawlable”，例如 #!/ 和 #!/sunshine/lollipops
            children:node //渲染单一子组件(元素)
        ><App/></HashRouter>
    》<Link>
        为你的应用提供声明式的，无障碍的导航
        <Link
            to:string || object //string-->需要跳转到的路径(pathname)或地址(location)
                                //object-->需要跳转到的地址(location)
            replace:bool //true -->点击链接后将使用新地址替换掉访问的历史记录里面的原地址
                        //false -->默认值，点击链接后将在原有访问历史记录的基础上添加一个新的记录
        />
        //String
        <Link to='/about'/>
        //Object
        <Link to={
            {
                pathname:"/courses",
                search:"?sort=name",
                hash:"#the-hash",
                state:{formDashboard:true}
            }
        } />
    》<NavLink>
        一个特殊的<Link>，当渲染它和正常的URL匹配时，它将添加样式属性
        <NavLink
            activeClassName: string//当链接被激活时，该类将被给。默认给的class是"active",它将和元素的className一起合并。
            activeStyle: object//这样式将被使用在激活时
            exact: bool//当为true时，只有url匹配正确时激活样式才会被应用
            strict: bool//当为true时，pathname与URL匹配时将考虑尾部斜线，具体看<Route strict>
            isActive: func//链接激活的执行函数，如果你想验证链接pathname与当前URL的pathname，它应该被使用。
        />
    》<Prompt>
        用于提示用户在离开页面之前。当你的应用进入一个状态，你应该阻止用户离开，渲染<Prompt>即可。
        <Prompt
            message:string || function //string -->当用户离开页面时，显示的消息
                                        //function -->当next location和用户试图导航时被调用，返回一个string的显示信息或返回true表示
                                        //可以跳转。
            when:bool//作为<Prompt>的条件渲染，when={true}--渲染 when={false}阻止其渲染
        />
    》<MemoryRouter>
       <Router>保持你的URL在历史记录中，而他用于测试或没有浏览器的环境中如(React Native)。
       <MemoryRouter
            initialEntries: array//一个locations的历史堆栈数组。值可能是location的objects{pathname,search,hash,state}或
                                //简单的string url
            initialIndex: number//初始位置的location index 对应于initialEntries
            getUserConfirmation: func//用于确认导航的函数。但直接使用<Prompt>时这个选项必须使用。
            keyLength: number//location.key的长度，默认6
            children: node//一个唯一的child元素为渲染
       />
    》<Redirect>
        渲染一个<Redirect>将导航一个新的URL。这个新的URL将覆盖当前URL在历史记录中，像服务器的的重定向类似。
        <Redirect
            to:string || object//string -->重定向URL
                                //object --> 重定向location
            push:bool//当为true，redirect将push一个新的地址在历史纪录中而不是替换当前地址
            from:string//一个触发redirect的from pathname。当在<Switch>里面使用<Redirect>时他能够被用来匹配location
        />
    》<Route>
        这Route组件是在React路由中最重要的组件。它最基本的作用是渲染一些路由匹配的UI。
        》Route 渲染方法
            <Route
                component//当location匹配是渲染的React组件
                render:func//指定内联渲染 注意：component优先于render，所以不要同时使用他们
                children:func//component和render都优先于它
            />
            //上面三个方法在同时只能使用一个
        》Route props
            <Route
                path:string//任何有效(满足 path-to-regexp )的URL
                exact:bool//当为true时，仅仅pathname和location.pathname匹配时才匹配成功
                strict:bool//当为true时，匹配location.pathname的尾部斜杠
                match
                location
                history
            />
            注意：strict能够强制被使用为location.pathname没有尾部斜杠，为了做到这个strict和exact都设置为true

            //传参
            <Route path="/user/:username" component={User}/>
        》<Router>
            一个共用的低级接口为所有的router组件。通常应用程序将使用高级路由器中的一个:
                <BrowserRouter>
                <HashRouter>
                <MemoryRouter>
                <NativeRouter>
                <StaticRouter>
            使用低级的<路由器>的最常见的用例是同步一个自定义的历史和一个像Redux或Mobx这样的状态管理lib。
            请注意，这并不需要使用状态管理libs和React路由器，它只是为了深度集成。
            <Router
                history:object//用于导航的历史对象。
                children:node//单一的child元素
            />

            import { Router } from 'react-router'
            import createBrowserHistory from 'history/createBrowserHistory'

            const history = createBrowserHistory()

            <Router history={history}>
              <App/>
            </Router>
        》<StaticRouter>
            一个不改变location的<Router>
            这在服务器端呈现场景中非常有用，因为用户并没有实际点击，所以位置实际上并没有改变。
            因此,名称:静态的。当您需要插入一个位置并在呈现输出上做出断言时，它在简单测试中也很有用。
            <StaticRouter
                basename:string//所有位置的基本URL。正确格式化的basename应该有一个主要的斜杠，但是没有尾部斜杠。
                location:string || object//string -->服务器接受的URL，可能是node服务的req.url
                                        //location object { pathname, search, hash, state }
                context:object//一个普通的JavaScript对象，记录渲染的结果。
                children:node//单一的child元素
            />
            //服务端案例
            import {createServer } from 'http'
            import React from 'react'
            import ReactDOMServer from 'react-dom/server'
            import {StaticRouter} from 'react-router'

            createServer((req,res) =>{
                const context = {}//记录渲染结果

                const html = ReactDOMServer.renderToString(
                    <StaticRouter
                        location = {req.url}
                        context= { context }
                    >
                        <App/>
                    </StaticRouter>
                );

                if(context.url){
                    res.writeHead(302,{
                        Location:context.url
                    });
                    res.end();
                }else{
                    res.write(html);
                    res.end();
                }
            }).listen(3000);
        》<Switch>
            渲染第一个child<Route>或<Redirect>来匹配路径
            <Switch
                children:node
            />
            》这有什么不同与使用一堆<Route>
                <Switch>渲染唯一的一个route。相反，每一个<Route>都匹配渲染在内的location。
                案例：
                    <Route path="/about" component={About}/>
                    <Route path="/:user" component={User}/>
                    <Route component={NoMatch}/>
                //如果URL是/about,那么上面的组件都将被渲染，因为他们全都匹配这个路径。
                import { Switch, Route } from 'react-router'

                <Switch>
                  <Route exact path="/" component={Home}/>
                  <Route path="/about" component={About}/>
                  <Route path="/:user" component={User}/>
                  <Route component={NoMatch}/>
                </Switch>
                //现在，如果我们在/ about，< Switch >将开始寻找匹配的<路由>。
                //将匹配，< Switch >将停止寻找匹配并呈现< about >。类似地，如果我们在/ michael，那么< User >将呈现。

                //这对于动画过渡也很有用，因为匹配的< Route >被呈现在与前一个相同的位置。
                <Fade>
                  <Switch>
                    {/* there will only ever be one child here */}
                    <Route/>
                    <Route/>
                  </Switch>
                </Fade>
        》history
            这里说的history与history object是react中的history包，他是React路由两个依赖之一。在各个环境中他提供了
            几个不同的实现。
            》browser history 一个DOM特性的实现，它利用web浏览器，支持h5的history API。
            》hash history 一个DOM特性的实现，利用比较老的浏览器
            》memory history 一个内存中的历史实现，在测试和非dom环境中有用，如：React Native

            history对象的属性和方法：
                》length -- number 历史堆栈中的条目数
                》action -- string 当前行为(PUSH, REPLACE, or POP)
                》location
                    》pathname -- string URL
                    》search -- string URL query string
                    》hash -- string URL hash片段
                    》state -- string 特定的状态state被提供如：push(path,state)当这个location被push到历史记录中时，仅仅在browser和memory history可用
                》push(path, [state]) -- function push一个新的location进入历史记录
                》replace(path, [state]) -- function 替换当前历史记录的location
                》go(n) -- function 跳转到历史记录中的n
                》goBack() -- go(-1)
                》goForward() -- go(1)
                》block(prompt) -- 防止导航

            history是可变的
                history是可变的因此推荐通过<Route>去改变location而不是使用history.location。
        》location
            location代表当前应用的位置。如：
            {
              key: 'ac3df4', // not with HashHistory!
              pathname: '/somewhere'
              search: '?some=search-string',
              hash: '#howdy',
              state: {
                [userDefined]: true
              }
            }
            》这个router提供location对象在这些地方：
                》Route component 中的this.props.location
                》Route render ({location})=>();
                》Route children ({location}) => ();
                》withRouter 中的this.pops.location
                //history.location也是存在的，但是他是不推荐使用的，因为他是可变的
            》上面的location对象是不会改变的，所以你能够适应它在生命hook中。它是有用的对于数据抓取和动画。
                componentWillReceiveProps(nextProps) {
                  if (nextProps.location !== this.props.location) {
                    // navigated!
                  }
                }
            》你可以提供location来代替string在下面的地方
                》Web Link to
                》Native Link to
                》Redirect to
                》history.push
                》history.replace
                通常，您只是使用一个字符串，但是如果您需要添加一些“location state”，当应用程序返回到特定位置时，
                您可以使用location对象。如果您想要基于导航历史而不是仅使用路径(比如modals)，那么这将非常有用。
                如：
                const location = {
                  pathname: '/somewhere'
                  state: { fromDashboard: true }
                }
                <Link to={location}/>
            》最后你能够使用location在下面的组件中
                Route
                Switch
                这将阻止他们使用路由器状态中的实际位置。
                这对于动画和未决的导航非常有用，或者任何时候您想要在不同的位置对组件进行欺骗，而不是实际的位置。
        》match
            match对象包含<Route path>匹配URL的信息。它的属性如下：
            》params -- object key:value path后面根的参数
            》isExact - true 整个URL匹配
            》path -- string 匹配的URL <Route>
            》url -- string <Link>的url

            》获取match对象的地方
                Route component -- this.props.match
                Route render -- ({match}) => ()
                Route children -- ({match}) =>()
                withRouter -- this.props.match
                matchPath 的返回值
                //如果Route没有path，因此总是匹配，你能够得到最近的父组件的match，withRouter也是一样的。
        》matchPath
            它使你可以使用相同的<Route>的匹配代码，除了用在正常的render周期中，如：分析在服务器渲染之前的数据依赖
            import { matchPath } from 'react-router'

            const match = matchPath('/users/123', {
              path: '/users/:id'
              exact: true,//默认false
              strict: false//默认false
            })

            matchPath(
                pathname,//要匹配的路径，如果在服务器渲染 req.url
                props//match数据
            )
        》withRouter
            你可以通过withRouter高阶组件获取history对象的属性，最近<Route>匹配的。
            withRouter将在每次路由改变时都重新渲染它的组件，与< Route >render属性:{match,location,history}相同。
            import React, { PropTypes } from 'react'
            import { withRouter } from 'react-router'

            class ShowTheLocation extends React.Component {
              static propTypes = {
                match: PropTypes.object.isRequired,
                location: PropTypes.object.isRequired,
                history: PropTypes.object.isRequired
              }

              render() {
                const { match, location, history } = this.props

                return (
                  <div>You are now at {location.pathname}</div>
                )
              }
            }

            const ShowTheLocationWithRouter = withRouter(ShowTheLocation)
            注意：
                如果您使用withRouter防止由shouldComponentUpdate阻塞的更新，他是重要的withRouter包裹这个实现了
                shouldComponentUpdate的组件。如：Redux
                    withRouter(connect(...)(MyComponent)
        》context.router
            React路由利用context.router来使得<Router>与<Route><Link><Prompt>等通信。
            context.router不应该被认为是公共API。因为context本身只是一个实验性的API，在未来的React版本中可能改变，
            所以你应该避免在你的组件中使用this.context.router。
            相反，你能获取存储在上下文的属性通过props。通过withRouter来包裹<Route>组件或其他组件来达到效果。

10.案例
    》基本使用
    》URL参数
    》认证
    》自定义链接
    》阻止导航
    》未匹配404
    》路径递归
    》侧边栏
    》过渡动画
    》模糊匹配
    》路由配置
    》模态画廊