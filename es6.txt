/******************ES6 http://es6.ruanyifeng.com/#README *******************/
1.安装nodejs的版本管理工具nvm 可以自由切换版本
2.安装ES-Checker模块 用来检查各种运行环境对ES6的支持情况
	npm install -g es-checker
	es-checker
3.Babel转码器
	Babel是一个广泛使用的ES6转码器，可以将ES6代码转为ES5代码 从而在现有环境执行
	第一步：在项目根目录 创建.babelrc文件 
		{
			"presets":[],
			"plugins":[]
		}
	第二步：presets字段设定转码规则 
		npm install --save-dev babel-preset-es2015 //ES2015转码规则
		npm install --save-dev babel-preset-react //react转码规则
		//ES7不同阶段语法提案的转码规则  选装一个即可
		npm install --save-dev babel-preset-stage-0
		npm install --save-dev babel-preset-stage-1
		npm install --save-dev babel-preset-stage-2
		npm install --save-dev babel-preset-stage-3
	第三步：将这些规则加入.babelrc
4.命令行转码babel-cli
	babel提供babel-cli工具 用于命令行转码
	安装：npm install --global babel-cli
	基本用法：
		babel example.js(要输出的文件) //转码结果输出到标准输出
		//转码结果写入一个文件
			//--out-file 或 -o 参数指定输出文件
			babel example.js --out-file compiled.js
			或
			babel example.js -o compiled.js
		//整个目录转码
			// --out-dir 或 -d参数指定输出目录
			babel src --out-dir lib
			或
			babel src -d lib
		//-s 参数生成source map文件
			babel src -d lib -s
	注意：这是在全局环境下 进行babel转码 这要求全局环境必须有babel 同时也无法支持不同项目使用不同版本的babel
	解决方案： 将babel-cli安装在项目中
		步骤一：npm install --save-dev babel-cli
		步骤二：改写 package.json
			在文件中添加：
			"scripts":{
				"build":"babel js -d lib"
			}
		步骤三：转码
			npm run build
5.babel-node
	babel-cli工具自带一个babel-node命令 提供一个支持ES6的repl环境，它支持node的repl环境的所有功能 而且可以直接运行ES6代码
	它不需要单独安装 而是随着babel-cli一起安装 然后执行babel-node就进去repl环境
		如：
		babel-node
		(x => x*1)(2);
		2
	babel-node命令可以直接运行ES6脚本
		如：babel-node test.js
	babel-node也可以安装在项目中：
		npm install --save-dev babel-cli
6.babel-register
	babel-register模块改写了require命令 每当使用require加载.js .jsx .es .es6后缀名的文件就会先用babel进行转码
	npm install --save-dev babel-register
	使用时 必须首先加载babel-register
	require("babel-register");
	require("./index.js");//会对index.js转码
	注意：babel.register只会对require命令加载的文件转码，而不会对当前文件转码 另外 由于它是实时转码 所以只适合在开发环境使用
7.babel-core--如果某些代码需要调用babel的API进行转码 就要使用babel-core模块
	安装：npm install babel-core --save
	在项目中就可以调用babel-core
	如：
	var babel=require("babel-core");
	//字符串转码
	babel.transform("code();",options);
	//文件转码(异步)
	babel.transformFile("filename.js",options,function(err,result){
		result;
	});
	//文件转码(同步)
	babel.transformFileSync("filename.js",options);
	//babel AST转码
	babel.transformFromAst(ast,code,options);
	注意：options--http://babeljs.io/docs/usage/options/
8.babel-polyfill
	babel默认只转换新的JavaScript句法 而不转换新的api 如：Symbol Promise等全局对象
	以及一些定义在全局对象上的方法都不会转码
	如ES6在Array对象上新增的Array.from方法。babel就不会转码这个方法 如果想让这个方法运行必须使用babel-polyfill为当前环境提供一个垫片
	安装：npm install --save babel-polyfill
	然后在脚本头部加入以下代码：
	import "babel-polyfill";
	或
	require("babel-polyfill");
9.浏览器环境
	babel也可以用于浏览器环境 但是从babel 6.0开始 不在直接提供浏览器版本
	而是需要构建工具构建出来 如果你没有或者不想使用构建工具 可以通过安装5.x版本的babel-core模块获取
	安装：npm install babel-core@5
	然后找到browser.js 或者browser.min.js引入到网页中
	<script src='browser.js'></script>
	或者使用babel-standalone模块提供的浏览器版本
	<script src='https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/6.4.4/babel.min.js'></script>
	<script type="text/babel">//需要注明 type="text/babel"
		//ES6 代码
	</script>
	注意：网页中实时将ES6代码转为ES5 对性能有影响 生产环境需要加载已经转码完成的脚本
	/*****************************************/
	如下是将代码打包成浏览器可以使用的脚本：
	安装：babelify模块
	npm install --save-dev babelify babel-preset-es2015
	再用命令行转换ES6脚本
	browserify script.js -o bundle.js -t [babelify --presets [es2015]]
	上面代码将ES6脚本script.js 转为bundle.js 浏览器直接加载后者就可以了
	在package.json设置下面的代码
	{
		"browserify":{
			"transform":[["babelify",{"presets":["es2015"]}]]
		}
	}
10.在线转换
	babel提供一个RePl在线编码器  可以将ES6代码转为ES5代码 转换后的代码可以直接作为ES5插入网页运行
11.与其他工具的配合
	ESLint用于静态检查代码的语法和风格 安装如下：npm install --save-dev eslint babel-eslint
	然后在项目根目录下：新建.eslintrc配置文件 在其中加入parser字段
	{
		"parser":"babel-eslint",
		"rules":{
		
		}
	}
	在再package.json之中，加入相应的scripts脚本
	{
		"scripts":{
			"lint":"eslint my-files.js"
		}
	}
	Mocha是一个测试框架，如果需要执行使用ES6语法的测试脚本 可以修改package.json的scripts.test
	{
		"scripts":{
			"test":"mocha --ui qunit --compilers js:babel-core/register"
		}
	}
	--上面命令中，--compilers参数指定脚本的转码器，规定后缀名为js的文件，都需要使用babel-core/register先转码。
12.Traceur转码器
	首先在页面头部加载Traceur库文件
	//加载Traceur的库文件
	<script src="https://google.github.io/traceur-compiler/bin/traceur.js"></script>
	//将这个库文件用于浏览器环境
	<script src="https://google.github.io/traceur-compiler/bin/BrowserSystem.js"></script>
	<script src="https://google.github.io/traceur-compiler/src/bootstrap.js"></script>
	//加载用户脚本 这个脚本里面可以使用ES6代码
	<script type="module">//这个module是Traceur编译器识别ES6代码的标志 编译器会自动将所有的type=module的代码编译为ES5 然后在交个浏览器执行
	  import './Greeter.js';//引入外部ES6脚本 当然也可以在这里直接写ES6代码
	</script>
	/*********对Tranceur的行为的精确控制********/
	<script>
		// Create the System object
		window.System = new traceur.runtime.BrowserTraceurLoader();
		// Set some experimental options
		var metadata = {
			traceurOptions: {
				experimental: true,
				properTailCalls: true,
				symbols: true,
				arrayComprehension: true,
				asyncFunctions: true,
				asyncGenerators: exponentiation,
				forOn: true,
				generatorComprehension: true
			}
		};
		// Load your module
		System.import('./myModule.js', {metadata: metadata}).catch(function(ex) {
		console.error('Import failed', ex.stack || ex);
	});
	</script>
	--上面代码中，首先生成Traceur的全局对象window.System，然后System.import方法可以用来加载ES6模块。
	加载的时候，需要传入一个配置对象metadata，该对象的traceurOptions属性可以配置支持ES6功能。
	如果设为experimental: true，就表示除了ES6以外，还支持一些实验性的新功能。
	/************命令行转换************/
	先安装 Traceur：npm install -g traceur
	命令转换：traceur --script es6.js --out es5.js --experimental
		上面代码的--script选项表示指定输入文件，--out选项表示指定输出文件。
13. let和const命令
	》let基本用法
		ES6新增了let命令，用来声明变量，他的用法类似于var 但是所声明的变量，只在let命令所在的代码块内有效
		如：{let a=10;}
		let声明变量适合于for循环中
		for(let i=0;i<10;i++){}
		》用let声明的变量  没有变量提前的现象 即变量一定要在声明后使用 否则报错
		》暂时性死区
			只要块级作用域内存在let命令 它所声明的变量就"绑定"在这个区域，不再受外部的影响
			在代码块内，使用let命令声明变量之前，该变量都是不可用的(哪怕有个同名的全局变量也是不可用的)，
			这个在语法上称为"暂时性死区"(TDZ)
		》不允许重复声明
			let不允许在相同的作用域内，重复声明同一个变量
	》块级作用域
		》为什么需要块级作用域
			ES5只有全局作用域和函数作用域 没有块级作用域 这样带来了很多不合理的场景
			》内层变量可能会覆盖外层变量
			》用来计数的循环变量泄露为全局变量
		》ES6的块级作用域
			let为js新增加了块级作用域
			**内层作用域可以定义外层作用域的同名变量**
	》const命令
		--const声明一个只读的常量，一旦声明 常量的值就不能改变
		》const的作用域与let命令相同 只在声明所在的块级作用域内有效
		》const命令声明的常量也是不能提升的 同样存在暂时性的死区 只能在声明的位置后面使用
		》const声明的常量 也与let一样不可重复声明
	》顶层对象(window)的属性
		var、function声明的全局变量 依旧是顶层对象的属性，另一方面规定：let、const、class声明的全局变量，不属于顶层对象的属性
		也就是说ES6开始 全局变量将逐步与顶层对象的属性脱钩
14. 变量的解构赋值
	ES6允许按着一定的模式，从数组和对象中提取值，对变量进行赋值--解构
	》数组的解构赋值--即模式匹配  只要等号两边的模式相同  左边的变量就会被赋予对应的值
	如：var a=1;var b=2;
	ES6: var [a,b]=[1,2];
	let [a,...b]=[1,2,3];=>a=1 b=[2,3];
	如果解构不成功，变量的值就等于undefined
	》解构赋值允许指定默认值
	如：var [foo=true]=[false];
	//foo--默认值true
	//解构赋值的值为false
	》对象的解构赋值--对象的解构与数组有一个重要的不同，数组的元素是按次序排列的，变量的取值由它的位置决定，
	  而对象的属性没有次序，变量必须与属性同名，才能取到正确的值
	  如：var {bar,foo}={foo:"aaa",bar:"bbb"}
	  注意：如果变量名与属性名不一致，可以写成下面格式：
	  var {foo:baz}={foo:"aa"};--即 var {属性名:变量名}={属性名:属性值}
	  console.log(baz);
	  let baz;
	  ({bas:baz}={bas:"a"});//注意"()"是必须的  避免js解析为代码块
	  //对象的解构默认值
	  var {x=3}={};
	  var {x:y=3}={}
	 》字符串的解构赋值--字符串也可以解构赋值，这是因为此时，字符串被转换成了一个类似数组的对象
		var [a,b,c]="she";
	 》类似数组的对象都有一个length属性，因此还可以对该属性解构赋值
		let {length:len}="hello";
		console.log(len);//5
	 》数值和布尔值的解构赋值--解构赋值时，如果等号右边的是数值和布尔值，则会先转为对象
	 如：let{toString:s}=123;
	     s===Number.prototype.toString;//true
	 》函数参数的解构赋值
		function add([x,y]){
			return x+y;
		}
		add([1,2]);
	 》解构的用途
		》交换变量的值  [x,y]=[y,x];
		》从函数中返回多个值--函数只能返回一个值，如果要返回多个值，只能将他们放在数组或对象里返回。
		//返回一个数组
		function example(){
			return [1,2,3];
		}
		var [a,b,c]=example();
		//返回一个对象
		function example(){
			return {
				foo:1,
				bar:2
			}
		}
		var {foo,bar}=example();
		》函数参数的定义--解构赋值可以方便地将一组参数与变量名对应起来
		function fun([x,y,z]){...};//参数是一组有次序的值
		fun([1,2,3]);
		function fun({x,y,z}){...};//参数是一组无次序的值
		fun({z:3,y:2,x:1});
		》提取 JSON 数据--解构赋值对提取json对象的数据  
		var jsonData={
			id:42,
			status:"ok",
			data:[867,5309]
		}
		let {id,status,data:number}=jsonData;
		》函数参数的默认值
		$.ajax=function(url,{async=true,beforeSend=function(){},cache=true,complete=function(){}});
		》遍历Map结构--任何部署了iterator接口的对象 都可以用for...of循环遍历
		var map=new Map();
		map.set("first","hello");
		map.set("second","world");
		for(let [key,value] of map){//key--键 value--值
			console.log(key+"is"+value);
		}
		》输入模块的指定方法--加载模块时，往往需要指定输入那些方法，解构赋值使得输入语句非常清晰
		const {SourceMapConsumer,SourceNode}=require("source-map");
15. 字符串的扩展
	》字符的Unicode表示法--js允许采用\uxxxx形式表示一个字符，其中"xxxx"表示字符的码点，但是这种表示法只限于\u0000--\uffff之间的字符
	超出这个范围的字符，必须用两个双字节的形式表达，但是ES6对这一定做出了改进 只要将码点放入大括号即可
	如："\u{20BB7}"
	》codePointAt()--js内部，字符以UTF-16的格式储存，每个字符固定为2个字节，
	对于那些需要4个字节存储的字符即Unicode码点大于0xFFFF的字符，js会认为它们是两个字符,codePointAt()能正确处理4个字节存储的字符
	返回一个字符的码点
	codePointAt(字符在字符串中的位置，从0开始(若某个汉子占用两个字符，那么这里针对该汉子也是有两个字符));--返回的码点是十进制的值
	如："字符串".codePointAt(某字符在字符串中的索引)
	》String.fromCodePoint(码点)
		ES5提供的String.fromCharCode方法，用于从码点返回对应的字符，但是这个方法不能识别32位的UTF-16(Unicode编号大于0xFFFF)
		而String.fromCodePoint()方法可以识别大于0xFFFF的字符，弥补了fromCharCode的不足
	》字符串的遍历器接口--for...of
		for(let ch of "foo"){
			console.log(codePoint);
		}--这种遍历的方式：除了遍历字符串，这个遍历器最大的优点是可以识别大于0xFFFF的码点，传统的for循环无法识别这样的码点
	》at()--ES5对字符串对象提供charAt方法，返回字符串给定位置的字符，该方法不能识别码点大于0xFFFF的字符
		at()可以识别Unicode编号大于0xFFFF的字符，返回正确的字符
		"字符串".at(字符在该字符串中的索引)--但是该方法需要垫片库实现
		<script src="at.js"></script>--引入
	》normalize()--将字符的不同表示方法统一为同样的形式--Unicode正规化
		》normalize()可以接受**一个参数**来指定normalize的方式
			》NFC  默认参数--标准等价合成
			》NFD  标准等价分解
			》NFKC  兼容等价合成
			》NFKD  兼容等价分解

	》includes() --返回布尔值，表示是否找到了参数字符串
	  startsWith() --返回布尔值，表示参数字符串是否在源字符串的头部
	  endsWith()--返回布尔值，表示参数字符串是否在源字符串的尾部
	  如："hello world".includes("o"[,index])//true index表示从什么位置开始
	      "hello world".startsWith("hello"[,index]);//true index表示从什么位置开始
	      "hello world".endsWith("!"[,index]);//true  ***表示前index个字符串**
	》repeat()--返回一个新的字符串，表示将原字符串重复n次
		如："x".repeat(3);//"xxx"
	》padStart() padEnd()--字符串不全长度的功能，如果某个字符串不够指定长度，会在开始位置或者结束位置不全
	如："x".padStart(4,"ab");//从开始位置用"ab"去不全"x",如果第二个参数省略，那么以空格不全
	》模板字符串--是增强版的字符串，用反引号(`)标识，它可以当做普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量
		var  name='Bob';//嵌入变量${name} ${任何的js表达式}
		var str =`Hello ${name}`;
		str.trim();//用来消除被保留的空格
	》实例：模板编译
	》标签模板
	》String.raw()
	》模板字符串的限制
16.正则的扩展
	》RegExp构造函数
		》在ES5中，RegExp构造函数的参数有两种情况
			》第一种情况：参数是字符串 这时第二个参数表示正则表达式的修饰符
			var reg=new RegExp("xyz","i");等价于 var reg=/xyz/i;
			》第二种情况是，参数是一个正则表达式，这时会返回一个原有正则表达式的拷贝
			var reg=new RegExp(/xyz/i);等价于 var reg=/xyz/i;
			但是在这种情况下ES5不允许使用第二个参数，添加修饰符 否则报错即 var reg=new RegExp(/xyz/,"i");
			**ES6改变了这种行为*，即如果RegExp构造函数第一个参数是一个正则对象，那么可以使用第二个参数指定修饰符，而且
			返回的正则表达式会忽略原有的正则表达式的修饰符，只是用新指定的修饰符
			即 new RegExp(/abc/ig,'i').flags;//"i"
	》字符串的正则方法--字符串对象中有4个方法可以使用正则表达式：
		match()
		replace()
		search()
		split()

	》u修饰符--ES6对正则表达式添加了u修饰符，含义为"Unicode模式"，用来正确处理大于\uFFFF的Unicode字符
		如：/^\uD83D/u.test("luD83D\uDC2A");//false
		》点子符--"."字符在正则表达式中，含义是除了换行符以外的任意单个字符。对于码点大于0xFFFF的Unicode字符，点子符不能识别，必须加上u修饰符才行
		/^.$/u.test('𠮷');//true
		》Unicode字符表示法--ES6新增了使用大括号表示Unicode字符，这种表示法在正则表达式中必须加上u修饰符才能识别
		/\u{61}/u.test("a");//true
		》量词--使用u修饰符后，所有的量词都会正确的识别码点大于0xFFFF的Unicode字符
		/𠮷{2}/u.test('𠮷𠮷')
		注意：只有在使用u修饰符的情况下，Unicode表达式当中的大括号才会被正确解读，否则会被解读为量词
		》预定义模式--u修饰符也影响到预定义模式，能否正确识别码点大于0xFFFF的Unicode字符
		/^\S$/u.test('𠮷');//\S表示匹配所有不是空格的字符
		》i修饰符(忽略大小写)--有些Unicode字符的编码不同 但是字型很相近，不加u修饰符 就无法识别非规范的字符
	》y修饰符--ES6还为正则表达式添加了y修饰符，叫做"粘连"修饰符
		y修饰符与g修饰符作用类似，也是全局匹配。后一次匹配都从上一次匹配成功的下一个位置开始，不同之处在于，g修饰符只要剩余位置
		中存在匹配就可，而y修饰符**确保匹配必须从剩余的第一个位置开始**(即从该位置处就开始满足正则表达式)。
		lastIndex属性指定每次搜索的开始位置：如：reg.lastIndex=2;
	》sticky属性--与y修饰符相匹配 ES6的正则对象多了sticky属性，表示是否设置了y修饰符
		/hello/y.sticky;//true
	》flags属性--ES6为正则表达式新增了flags属性，会返回正则表达式的修饰符
		//ES5的source属性--返回正则表达式的正文
		/abc/ig.source;//"abc"
		/abc/ig.flags;//"ig"
	》RegExp.escape()--字符串必须转义(即当字符串中有特殊字符时，需要用反斜杠对其中特殊的字符转义)，才能作为正则模式
		该方法可以直接把包含特殊符号的字符串  转换成正则表达式需要的字符串格式
		//该方法需要垫片
		var reg=new RegExp(RegExp.escape("hello."),'g');
	》s修饰符 dotAll模式--正则表达式中，点(.)是一个特殊字符，代表任意的单个字符，但是行终止符除外
		》行终止符包括：
			U+000A 换行符(\n)
			U+000D 回车符(\r)
			U+2028 行分隔符
			U+2029 段分隔符
		引入/s修饰符，使得"."可以匹配任意的单个字符，包括行终止符--这就是dotAll模式即点dot代表一切字符。
		所以正则表达式还引入了一个dotAll属性，返回一个布尔值，表示该正则表达式是否处于dotAll模式
		/s修饰符和多行修饰符/m不冲突，两者一起使用时，"."匹配所有字符
		const reg=/foo.bar/s;
		reg.test("foo\nbar");
		reg.dotAll
	》后行断言
		先行断言：表示x只有在y前面才匹配  /x(?=y)/
			》如：只匹配百分号之前的数字，要写成/\d+(?=%)/
		先行否定断言：表示x只有不在y前面才匹配。必须写成/x(?!y)/
			》如：只匹配不在百分号之前的数字，要写成/\d+(?!%)/;
		后行断言：表示x只有在y后面才匹配， /(?<=y)x/
			》如：只匹配美元符号之后的数字：/(?<=\$)\d+/
		后行否定断言：表示x只有不在y后面才匹配 /(?<!y)x/
			》如：只匹配不在美元符号后面的数字 /(?<!\$)\d+/;
	》Unicode属性类--预留类
		》\p{属性名=属性值} \P{属性名=属性值}--允许正则表达式匹配符号Unicode某个属性的所有字符
17.数值的扩展
	》二进制和八进制表示法--ES6提供了二进制和八进制数值的新的写法，分别用前缀0b(0B)和0o(0O)表示
	0b111110111 === 503 // true
	0o767 === 503 // true
	从ES5开始，在严格模式中，八进制就不再允许使用前缀0表示，ES6进一步明确，要使用前缀0o表示
	//非严格模式：0o11===011//true
	//严格模式："use strict";0o11===011//报错
	如果要将0b和0o前缀的字符串数值转为十进制，要使用Number方法
	Number("0b111");//7
	Number("0o10");//8
	》Number.isFinite() Number.isNaN()
		》Number.isFinite()用来检查一个数值是否为有限的
		Number.isFinite(15);//true
		》Number.isNaN()用来检查一个值是否为NaN
		Number.isNaN(NaN);//true
		注意：这两个方法与传统的全局方法isFinite()和isNaN()的区别在于，传统的方法先调用Number()将非数值的值转为数值
		在进行判断，而这两个新方法只对数值有效，**非数值**一律返回false
	》Number.parseInt() Number.parseFloat()--将全局方法parseInt()和parseFloat()移植到Number对象上面，行为完全保持不变
		Number.parseInt("12.34");//12
		Number.parseFloat("123.45#");//123.45
		这样做的目的：是逐步减少全局行方法，使得语言逐步模块化
	》Number.isInteger()--用来判断一个值是否为整数，需要注意的是，在js内部，整数和浮点数是同样的存储方法，所以3和3.0被视为同一值
	Number.isInteger(25);//true
	Number.isInteger(25.0);//true
	Number.isInteger(25.1);//false
	》Number.EPSILON--ES6在Number对象上面，新增的一个极小的常量
	Number.EPSILON;// 2.220446049250313e-16
	Number.EPSILON.toFixed(20);// '0.00000000000000022204'
	引入一个这么小的量的目的，在于为浮点数计算，设置一个误差范围，我们知道浮点数计算是不精确的，但是如果这个误差
	能够小于Number.EPSILON,我们就可以认为得到了正确的结果。因此Number.EPSILON的实质是一个可以接受的误差范围
	》安全整数和Number.isSafeInteger()
		》安全整数：js能够准确表示的整数范围在-2^53到2^53之间(不含两个端点)，超过这个范围，无法精确表示这个值
		Math.pow(2, 53) === Math.pow(2, 53) + 1// true
		ES6引入了Number.MAX_SAFE_INTEGER和Number.MIN_SAFE_INTEGER这两个常量，用来表示这个范围的上下限
		Number.MAX_SAFE_INTEGER === Math.pow(2, 53) - 1;// true
		Number.MIN_SAFE_INTEGER === -Number.MAX_SAFE_INTEGER;// true
		》Number.isSafeInteger()则是用来判断一个**整数**是否落在这个范围之内
		Number.isSafeInteger(3) // true
		Number.isSafeInteger(1.2) // false
	》Math对象的扩展--ES6在Math对象上新增了17个与数字相关的方法。所有这些方法都是静态方法，只能在Math对象上调用
		》Math.trunc()方法用于去除一个数的小数部分，返回整数部分
		Math.trunc(4.5);//4
		对于非数值，Math.trunc内部使用Number方法将其先转为数值
		Math.trunc("123.5");//123
		对于空值和无法截取整数的值，返回NaN
		》Math.sign方法用来判断一个数到底是正数  负数 还是零
		它会返回五种值：
			》参数为正数  返回+1
			》参数为负数  返回-1
			》参数为0     返回0
			》参数为-0    返回-0
			》其他值      返回NaN
			如：Math.sign(-5);//-1
		》Math.cbrt()用于计算一个数的立方根
		Math.cbrt(8);//2
		对于非数值，Math.cbrt方法内部也是先使用Number方法将其转为数值
		》Math.clz32();//js的整数使用32位二进制形式表示，Math.clz32方法返回一个数的32位无符号整数形式有多少个前导0
		Math.clz32(1000);//22
		对于小数，Math.clz32方法只考虑整数部分--》Math.clz32(3.2);//30
		对于空值或其他类型的值，Math.clz32方法会将他们先转为数值，然后再计算
		Math.clz32(NaN) // 32
		》Math.imul();返回两个数以32位带符号整数形式相乘的结果，返回的也是一个32位的带符号整数
		Math.imul(2,4);//8
		注意：如果只考虑最后32位，大多数情况下，Math.imul(a,b);与a*b的结果是相同的，即该方法等同于(a*b)|0的效果，
		但是js有精度限制，超过2的53次方的值无法精确表示，这就是说，对于那些很大的数的乘法，低位数值往往都是不精确的
		Math.imul方法可以返回正确的低位数值
		如：
			Math.imul(0x7fffffff, 0x7fffffff) // 1
			(0x7fffffff * 0x7fffffff)|0 // 0
		》Math.fround();//返回一个数的单精度浮点数形式，对于整数来说，Math.fround方法返回结果不会有任何不同，区别主要是那些无法用
		64个二进制位精确表示的小数，这时，Math.fround方法会返回最接近这个小数的单精度浮点数
		Math.fround(1.337) // 1.3370000123977661
		》Math.hypot();//返回所有参数的平方和的平方根
		Math.hypot(3,4);//5
		注意：如果参数不是数值，Math.hypot方法会将其转为数值，只要有一个参数无法转为数值，就会返回NaN
		》对数方法
			》Math.expm1(x);//返回e^x-1即Math.exp(x)-1;
			Math.expm1(1)  // 1.718281828459045
			》Math.log1p(x);//返回1+x的自然对数，即Math.log(1+x);如果x小于-1返回NaN
			Math.log1p(0)  // 0
			Math.log1p(-1) // -Infinity
			》Math.log10(x);//返回以10为底的x的对数，如果x小于0，则返回NaN
			Math.log10(1)      // 0
			Math.log10(0)      // -Infinity
			》Math.log2(x);//返回以2为底的x的对数，如果x小于0，则返回NaN
			Math.log2(1)       // 0
			Math.log2(0)       // -Infinity
		》三角函数方法：ES6新增的6个三角函数方法
			》Math.sinh(x);//返回x的双曲正弦
			》Math.cosh(x);//返回x的双曲余弦
			》Math.tanh(x);//返回x的双曲正切
			》Math.asinh(x);//返回x的反双曲正弦
			》Math.acosh(x);//返回x的反双曲余弦
			》Math.atanh(x);//返回x的反双曲正切
	》指数运算符--ES7新增了一个指数运算符(**)
	即：2**3=2^3//8
	指数运算符可以与等号结合，形成一个新的赋值运算符(**=)
	即：let b=3;b **=5;//3^5;
18.数组的扩展
	》Array.from()//用于将两类对象转为真正的数组，**类数组对象和可遍历的对象(包括ES6新增的数据结构Set和Map)**
		》类数组对象
		let arr_like={"0":"a","1":"b",length:2}//***必须加上length属性才能转化，属性必须是能转为数字的字符串***
		//ES5的写法
		var arr1=[].slice.call(arr_like);
		//ES6的写法
		var arr2=Array.from(arr_like);
		实际应用中：常见的类似数组的对象是DOM操作返回的NodeList集合，以及函数内部的arguments对象。
		Array.from都可以将它们转为真正的数组
		》只要部署了iterator接口的数据结构，Array.from都能将其转为数组
		Array.from("hello");
		Array.from(new Set(["a","b"]));
		注意：如果参数是一个真正的数组，Array.from会返回一个一模一样的新数组
		》扩展运算符(...)也可以将某些数据结构转为数组
			》arguments对象  var args=[...arguments];
			》NodeList对象   [...document.querySelectorAll("div")]
			注意：扩展运算符背后调用的是遍历器接口(Symbol.iterator);如果一个对象没有部署这个接口，就无法转换
			Array.from方法则是还支持类数组对象，所谓类数组对象，本质特征只有一点，即必须有length属性。因此任何
			有length属性的对象，都可以通过Array.from方法转为数组
		》Array.from还可以接受第二个参数，作用类似于数组的map方法，用来对每个元素进行处理，将处理后的值放入返回的数组中
		Array.from(arr_like,function(x){return x**x;//x是遍历的类数组值，这里只有return了生成的数组中才会有值});
		Array.from(arr_like,x=>x*x);等效于：Array.from(arr_like).map(x=>x*x);\
		》取出一组DOM节点的文本内容
			let spans=document.querySelectorArr("span.name");
			//map()
			let names=Array.prototype.map.call(spans,s=>s.textContent);
			var arr1=arr.map(function(x){//map return返回的是一个新数组  x是原arr的值
				return x;
			});
			//Array.from
			let names=Array.from(spans,s=>s.textContent);
		》将数组中布尔值为false的成员转为0
			Array.from([1,,3,,5],x=>x||0);
		》Array.from的第三个参数--用于绑定第二个参数函数中的this指向
		Array.from(arr_like,function(){
			console.log(this);//arr_like
			//当第三个参数没有传入时，这里面的this是undefined,传入第三个参数时，this就表示传入的对象
		},arr_like);
	》Array.of()--用于将一组值，转换为数组,目的：弥补数组构造函数Array()的不足，因为参数个数的不同，会导致Array()的行为差异
		如：Array.of(3,11,8);//[3,11,8]
		Array()//[];
		Array(3)//[ , , ];
		Array(3,11,8);//[3,11,8]
		即：Array方法没有参数、一个参数、三个参数时，返回结果都不一样。只有当参数个数不少于2个时，Array才会返回由
		参数组成的新数组。参数个数只有一个时，实际上是指定数组的长度
		Array.of基本上可以用来替代Array()或new Array();并且不存在由于参数不同而导致的重载，它的行为非常统一
		Array.of() // []
		Array.of(undefined) // [undefined]
		Array.of(1) // [1]
		Array.of(1, 2) // [1, 2]
		注意：Array.of总是返回参数值组成的数组，如果没有参数，就返回一个空数组
	》数组实例的copyWithin()--在当前数组内部，将指定位置的成员复制都其他位置(会覆盖原有成员)，然后返回当前数组。也就是说，使用这个方法，会修改当前数组
	Array.prototype.copyWithin(target,start=0,end=this.length);
		》参数--这三个参数都应该是数值，如果不是，会自动转为数值
			target--必需的  从该位置开始替换数据
			start--可选的   从该位置开始读取数据 默认为0  如果为负数 表示倒数
			end--可选的     到该位置前停止读取数据，默认等于数组长度，如果为负值，表示倒数
		[1,2,3,4,5].copyWithin(0,3,4)

	》数组实例的find()和findIndex()
		》find();//数组实例的find函数，用于找出**第一个**符合条件的数组成员，它的参数是一个回调函数，所有数组成员依次执行
		该回调函数，直到找出第一个返回值为true的成员，然后返回该成员。如果没有符合条件的成员则返回undefined
		[1,2,-4,5].find(function(value,index,arr){return value<0;})
		》findIndex();//返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回-1;
		[1,2,-4,5].findIndex(function(value,index,arr){
			return value<0;
		});//2
		注意：
			》上述两个方法可以接受第二个参数，用来绑定回调函数的this对象
			var arr=[1,2,-4,5];
			arr.find(function(value,index,arr){
				console.log(this);//arr 当未传入第二个参数时，this表示undefined
				return value<0;
			},arr)
			》上述两个方法都可以发现NaN  弥补了数组indexOf方法的不足
			[NaN].indexOf(NaN);//-1
			[NaN].findIndex(function(y){
				return Object.is(NaN,y);
			});//0
			即：indexOf方法无法识别数组的NaN成员，但是findIndex方法可以借助Object.is方法做到
	》数组实例fill()//fill方法使用给定值，填充一个数组
		["a","b"].find(7);//修改的是原数组
		》fill方法用于空数组的初始化非常方便，数组中已有的元素，会被全部抹去
		》fill方法还可以接受第二个和第三个参数，用于指定填充的起始位置，和结束位置(填充到结束位置的前一个位置处)
		["a","b","c"].fill(7,1,2);//如果结束位置的值大于了原数组的长度，它也只填充到原数组的长度就结束了
	》数组实例的entries(),keys(),values()--用于遍历数组，它们都会返回一个遍历器对象，可以用for...of循环进行遍历，唯一的区别是
		keys()是对键名的遍历，values()是对键值的遍历，entries()是对键值对的遍历
		var arr=["a","b","c"];
		》使用for...of循环遍历
			for(let key of arr.keys()){
				console.log(key);
			}
			for(let value of arr.values()){
				console.log(value);
			}
			for(let entrie of arr.entries()){
				console.log(entrie);
			}
		》手动调用遍历器对象的next方法遍历;next用于改变指针位置
			console.log(arr.keys().next().value);//0
			console.log(arr.keys().next().value);//1
			console.log(arr.keys().next().value);//2
	》数组实例的includes();//Array.prototype.includes方法返回一个布尔值，表示某个数组是否包含给定的值，与字符串的includes方法类似
		》[1,2,3].includes(2);//true
		》[1,2,3].includes(4);//false
		》[1,2,NaN].includes(NaN);//true
		注意：该方法的第二个参数表示搜索的起始位置，默认为0。如果第二个参数为负数，则表示倒数的位置，如果这时它大于
		数组长度，则会重置为从0开始
		[1,2,3].includes(3,3);//false  不能重置为0
		[1, 2, 3].includes(3, -4); // true  能重置为0
		》indexOf的缺点：
			》不够语义化，它的含义是找到参数值的第一个出现位置，所以要去比较是否不等于-1 表达不够直观
			》它内部使用严格相当的运算符(===)进行判断，这会导致对NaN的误判
			[NaN].indexOf(NaN);//-1
			》includes使用的是不一样的判断算法
			[NaN].includes(NaN);//true
		》注意：与Map和Set数据结构中的has方法进行区分
			》Map结构的has方法是用来查找键名的
			》Set结构的has方法是用来查找值的
	》数组的空位//数组的某一个位置没有任何值。比如：Array构造函数返回的数组都是空位
	如：Array(3);//[ , , ]--返回一个具有3个空位的数组
	注意：空位不是undefined 一个位置的值等于undefined 依然是有值的。空位是***没有任何值***
	》in运算符希望它的做操作数是一个字符串或可以转为字符串，希望他的右操作数是一个对象，
	**如果右侧对象拥有一个名为左操作数值的属性名那么表达式返回true否则返回false**
	如：var point={x:1,y:2};
	"x" in point //true
	"z" in point //false
	"toString" in point //true
	var arr =[1,2];
	0 in arr;//true 因为arr0索引处有值
	0 in [undefined];//true undefined也是值
	0 in [ , ]//false  空位
	ES5对空位的处理，大多数情况下会忽略空位：
		》forEach();filter();every();some()都会跳过空位
			》forEach
				arr.forEach(function(value,index,arr){
				
				},thisArg);//thisArg 为回调函数中绑定this对象，如果省略该参数  回调函数中的this值为undefined
			》filter();//对数组中的每个元素都执行一次指定函数callback，并且创建一个新的数组，该数组元素是所有回调函数执行时返回值为true的原数组元素
				   //它只对数组中的非空元素执行指定的函数。没有赋值或者已经删除的元素将被忽略，同时新创建的数组也不会包含这些元素
				语法：filterArr=arr.filter(callback[,thisArg]);
				callback://要对每个数组元素执行的回调函数
				thisAry://在执行回调函数时定义的this对象--为回调函数中绑定this对象，如果省略该参数  回调函数中的this值为undefined
				如：arr.filter(function(value,index,arr){
					return value>=0;//过滤掉arr中小于10的数组元素
				});
			》map();//对数组中的每个元素都执行一次回调函数，并创建一个新的数组，该数组的所有元素，是回调函数的执行结果;
			语法：mapArr=arr.map(callback[,thisArg]);
				callback://要对每个数组元素执行的回调函数
				thisAry://在执行回调函数时定义的this对象--为回调函数中绑定this对象，如果省略该参数  回调函数中的this值为undefined
				如：
					var test2=["a","b","c",NaN];
					var test3=test2.map(function(value,index,arr){//将test2数组中的元素转成大写
						if(typeof value == "string"){
						    return value.toUpperCase();
						}
					},test2);
			》some();//对数组中的每个元素都执行一次回调函数，直到此函数返回true，如果发现这个元素，some将返回true，如果回调函数对每个元素执行后都返回false，some将返回false。它只对
			数组中的非空元素执行指定的函数，没有赋值或者已经删除的元素将被忽略
			语法：someArr=arr.some(callback[,thisArg]);
				如：//判断test2数组中是否有大于"b"的元素存在
					var test3=test2.some(function(value,index,arr){
							return value>"b";
				        },test2);
						    console.log(test2);//true
			》every();//对数组中的每一个元素都执行一次指定函数，直到此函数返回false，如果发现这个元素，every将返回false 如果回调函数对每个元素执行后都返回true，every将返回true。它只对数组中的非空元素执行指定
			的函数，没有赋值或已经删除的元素将被忽略
			语法：everyArr=arr.every(callback[,thisArg]);
				如：检查test2是否所有元素都大于等于"b"
				var test3=test2.every(function(value,index,arr){
						return value>"b";
					    },test2)
					    console.log(test3);//false
		》map()会跳过空位，但会保留这个值
		》join()和toString()会将空位视为undefined 而undefined和null会被处理成空字符串
	ES6则是明确将空位转为undefined
		》Array.from会将数组的空位，转为undefined即该方法不会忽略空位
			Array.from(['a',,'b']);//['a',undefined,'b']
		》扩展运算符(...)也会将空位转为undefined
			[...['a',,'b']]//['a',undefined,'b']
		》copyWithin也是连空位一起拷贝
			[,'a','b', , ].copyWithin(2,0); // [,"a",,"a"]
		》fill会将空位视为正常的数组位置
		   new Array(3).fill('a')//['a','a','a']
		》for...of循环也会遍历空位
			let arr=[, ,];
			for(let i of arr){
				console.log(1);
			}
		》entries() keys() values() find() findIndex()会将空位处理成undefined
19.函数的扩展
	》函数参数的默认值
		》在ES6之前，不能直接为函数的参数指定默认值，只能采用变通的方法
			function log(x,y){
				x=x||'hello';//这样的缺点：如果x赋值了，但是对应的布尔值为false，则该赋值不起作用
				y=y||"world";
				console.log(x,y);
			}
			//为了避免这个问题，通常需要先判断一下参数是否被赋值了，如果没有，在等于默认值
			if(typeof x === 'undefined'){y='world'}
		》ES6允许为函数的参数设置默认值，即直接写在参数定义的后面，且不会出现上述的情况
			function log(x='hello',y='world'){
				console.log(x,y);
			}
		注意：参数变量是默认声明的，所以不能用let或const*再次声明*
		》与解构赋值默认值结合使用
			function foo({x,y=5}){
				console.log(x,y);
			}
			//foo({});//undefined 5
			//foo({x:1});//1 5
			//foo({x:1,y:2});//1 2
			//foo();//报错
			function fetch(url,{method='GET'}={}){
				console.log(method);
			}
		》参数默认值的位置--通常情况下，定义了默认值的参数，应该是函数的尾参数。因为这样比较容易看出来，到底省略了那些参数。
		如果非尾部的参数设置默认值，实际上这个参数是没法省略的
		当默认值的参数不是尾参数时，这时无法只省略该参数，而不省略它后面的参数，除非显示输入undefined。如果传入
		undefined，将触发该参数等于默认值，null则没有这个效果
		如：
			function  foo(x=5,y=6){
				console.log(x,y);
			}
			foo(undefined,null);//5 null
		》函数的length属性//指定默认值以后，函数的length属性，将返回没有指定默认值的参数个数，也就是说，指定了默认值后，length属性将失真
			(function(a){}).length;//1
			(function(a=5){}).length//0
			(function(a,b,c=5){}).length//2
			即：length属性的返回值，等于函数的参数个数减去指定了默认值的参数个数;这是因为
			length属性的含义是，该函数预期传入的参数个数，某个参数指定了默认值以后，预期传入的参数个数就不包括这个参数了。
			》同理rest参数也不会计入length属性：
				(function(...args){}).length;//0
			》如果设置了默认值的参数不是尾参数，那么length属性也不再计入后面的参数了：
				(function(a=0,b,c){}).length;//0
				(function(a,b=1,c){}).length;//1
		》作用域//一个需要注意的地方是，如果参数默认值是一个变量，则该变量所处的作用域，与其他变量的作用域规则是一样的
			//即先是当前函数的作用域，然后才是全局作用域
			var x=1;
			function f(x,y=x){
				console.log(y);
			}
			f(2);//2
		》应用
			》利用参数默认值，可以指定某一个参数不得省略，如果省略就抛出一个错误
			function throwIfMissing(){
				throw new Error("Missing parameter");
			}
			function foo(mustBeprovided=throwIfMissing()){
				return mustBeProvided;
			}	
			foo();//Error Missing parameter
			》可以将参数默认值设为undefined  表明这个参数是可以省略的
			function foo(optional=undefined){...}
	》rest参数;//ES6引入rest参数(形式为"...变量名")，用于获取函数的多余参数，这样就不需要使用arguments对象了。
		   //rest参数搭配的变量是一个数组，该变量将多余的参数放入数组中
		   function add(...values){
			let sum=0;
			for(var value of values){
				sum+=value;
			}
			return sum;
		   }
		   add(2,5,3);//10
		   注意：rest参数之后不能再有其他参数，即只能是最后一个参数，否则会报错
	》扩展运算符；//扩展运算符是三个点(...)，它好比rest参数的逆运算，将一个数组转为用**逗号分隔**的参数序列
		console.log(...[1,2,3]);//1 2 3
		[...document.querySelectorAll("div")];//[<div>,<div>]
		》该运算符主要用于函数调用
			如：
			function push(arr,...items){//items是一个数组
				arr.push(...items);//分解数组
			}
			/***********************/
			function add(x,y){
				return x+y;
			}
			var numbers=[4,38];
			add(...numbers);//42
		》替代数组的apply方法//由于扩展运算符可以展开数组，所以不在需要apply方法，将数组转为函数的参数了
		//ES5的写法
		function f(x,y,z){//...}
		var args=[0,1,2];
		f.apply(null,args);
		//ES6的写法
		f(...args);
		如：应用Math.max简化求出一个数组最大元素的写法
		//ES5
		Math.max.apply(null,[14,3,77]);
		//ES6的写法
		Math.max(...[14,3,77]);
		//等同于
		Math.max(14,3,77);
		》扩展运算符的应用
			》合并数组
				var arr1=[1,2];
				var arr2=[3,4];
				var arr3=[5,6];
				//ES5的合并数组
				arr1.concat(arr2,arr3);
				//ES6的合并数组
				[...arr1,...arr2,...arr3];
			》与结构赋值结合--扩展运算符可以与解构赋值结合起来，用于生成数组
				如：
					var list=[1,2,3];
					//ES5
					a=list[0];//1
					rest=list.slice(1);//[2,3]
					//ES6
					[a,...rest]=list;
					//a=1
					//rest=[2,3];
				注意：如果将扩展运算符用于数组赋值，只能放在参数的最后一位，否则会报错
					如：const [...butLast,last]=[1,2,3];//报错
			》函数的返回值//js的函数只能返回一个值，如果需要返回多个值，只能返回数组或对象，扩展运算符提供了
			解决这个问题的一种变通方法
			》字符串//扩展运算符还可以将字符串转为真正的数组
			如：[..."hello"];
			》实现了Iterator接口的对象;//任何Iterator接口的对象都可以用扩展运算符转为真正的数组
			如：var nodeList=document.querySelectorAll("div");//类数组
			    var array=[...nodeList];//数组
			》Map和Set结构 Generator函数;//扩展运算符内部调用的是数据结构的Iterator接口，因此只要具有Iterator接口
			的对象，都可以使用扩展运算符
			如：Map结构
				let map=new Map([
					[1,"one"],
					[2,'two']
				]);
				let arr=[...map.keys()];//[1,2];
			如：Generator函数运行后，返回一个遍历器对象，因此也可以使用扩展运算符
				var go=function*(){
					yield 1;
					yield 2;
					yield 3
				}
				[...go()]//[1,2,3]
				即：go是一个Generator函数，执行后返回的是一个遍历器对象
			注意：如果对没有Iterator接口的对象，使用扩展运算符，将会报错
			如：var obj={a:1,b:1};
			    let arr=[...obj];//报错				
	》严格模式
		//从ES5开始，函数内部可以设定为严格模式
		function doSomething(a,b){
			"use strict";
			//code
		}
		//ES6 规定只要函数参数使用了默认值，解构赋值，或者扩展运算符，那么函数内部就不能显示设定为严格默认 否则会报错
		如：
		function doSomething(a, b = a) {
		  'use strict';
		  // code
		}
	》name属性--函数的name属性，返回该函数的函数名
		function foo(){}
		foo.name//"foo"
		注意：ES6对这个属性的行为做了一些修改。如果将一个匿名函数赋值给一个变量
		ES5的name属性会返回一个空字符串，而ES6的name属性会返回实际的函数名
		var func1=function(){}
		//ES5
		func1.name;//""
		//ES6
		func1.name;//"func1"
		如果将一个具名函数赋值给一个变量，则ES5和ES6的name属性都返回这个具名函数的原本名字
		const bar=function baz(){}
		//ES5
		bar.name//'baz'
		//ES6
		bar.name//"baz"
		Function构造函数返回的函数实例，其name属性值为"anonymous"
		(new Function).name //'anonymous'
		bind返回的函数，name属性值会加上"bound"前缀
		function foo(){}
		foo.bind({}).name;//'bound foo'
		(function(){}).bind({}).name//'bound'
	》箭头函数--ES6允许使用"箭头"(=>)定义函数
		如：
		var f= v => v;
		等同于：
		var f=function(v){
			return v;
		}
		》如果箭头函数不需要参数或需要多个参数，就使用一个圆括号代表参数部分
			如：
			//无参数
			var f= () => 5;
			等同于
			var f=function(){return 5}
			//多个参数
			var sum=(num1,num2)=>num1+num2;
			等同于
			var sum=function(num1,num2){
				return num1+num2;
			}
		》如果箭头函数的代码块部分多于一条语句，就要使用大括号将它们括起来，并且使用return语句返回
			var fun=(num1,num2)=>{var sum=num1+num2;return sum;}
			等同于
			var fun = function(num1, num2) {
				var sum = num1 + num2;
				return sum;
		        };
		》由于大括号被解释为代码块，所以如果箭头函数直接返回一个对象，必须在对象外面加上**圆括号**
			var getTempItem=id=>({id:id,name:"Temp"});
		》箭头函数可以与变量解构结合使用
			const full=({first,last})=>first+" "+last;
			等同于
			function full(person){
				return person.first+" "+person.last;
			}
		》简化回调函数
			//正常函数写法
			[1,2,3].map(function(x){
				return x*x;
			});
			//箭头函数写法
			[1,2,3],map(x=>x*x);
		》rest参数与箭头函数结合使用
			const numbers=(...nums)=>nums;
			numbers(1,2,3,4,5);//[1,2,3,4,5]
		》注意事项
			》函数体内的this对象，就是定义时所在的对象(this固定化)，而不是使用时所在的对象
				this指向的固定化，并不是因为箭头函数内部有绑定this的机制，实际原因是箭头函数
				根本没有自己的this，导致内部this就是外层代码块的this，正是因为它没有this，所
				以也就不能作为构造函数
				注意：this、arguments、super、new.target在箭头函数中也是不存在的，同时都是指向外层
				函数的对应变量this、arguments、super、new.target
				由于箭头函数没有自己的this，所以也就不能用call、apply、bind这些方法去改变this的指向
			》不可以当做构造函数，也就是说，不可以使用new命令，否则会抛出一个错误
			》不可以使用arguments对象，该对象在函数体内不存在，如果要用，可以用Rest参数代替
			》不可以使用yield命令，因此箭头函数不能用作Generator函数
		》嵌套的箭头函数
			//ES5
			function insert(value){//2
				return {
					into:functioon(array){//[1,3]
						return {
							after:function(afterValue){//1
								array.splice(array.indexOf(afterValue)+1,0,value);
								//[1,3].splice(1,0,2);
								return array;//[1,2,3]
							}
						}
					}
				}
			}
			insert(2).into([1,3]).after(1);//[1,2,3]
			//ES6
			let insert=value=>({
				into:array=>({
					after:afterValue=>{
						array.splice(array.indexOf(afterValue)+1,0,value);
						return array;
					}
				})
			});
		》部署管道机制的例子，即前一个函数的输出是后一个函数的输入
		即：
		//方式1
			const plus1=a=>a+1;
			const mult2=a=>a*2;
			mult2(plus1(5));//12
		//方式2
			const pipeline=(...funcs)=>val=>funcs.reduce((a,b)=>b(a),val);
				》分析
					function pipeline(...funcs){
						return function (val){
							return funcs.reduce(function(a,b){
								return b(a);
							},val);
						}
					}
			const plus1=a=>a+1;
			const mult2=a=>a*2;
			const addEhenMult=pipeline(plus1,mult2);
				》addEhenMult=function (val){
							return [a=>a+1,a=>a*2].reduce(function(a,b){
								return b(a);
							},val);
						}
			addThenMult(5);//12
				》[a=>a+1,a=>a*2].reduce(function(a,b){
								//a prev b next
								//    5      a=>a+1
								//    6      a=>a*2;
								return b(a);
							},5);//5初始值	
	》绑定this//箭头函数可以绑定this对象，大大减少了显示绑定this对象的写法(call、apply、bind)。但是
		  //箭头函数并不适用于所有场合，所以ES7提出了"函数绑定"运算符，用来取代call、apply、bind调用。
		  //虽然语法还是ES7的一个提案，但是babel转码器已经支持
		》函数绑定运算符是并排的两个双冒号(::),双冒号左边是一个对象，右边是一个函数。该运算符会自动将
		左边的对象，作为上下文环境(即this对象)，绑定到右边的函数上面
		foo::bar;
		等同于
		bar.bind(foo);
		foo::bar(...arguments);
		等同于
		bar.apply(foo,arguments);
		》如果双冒号左边为空，右边是一个对象的方法，则等于该方法绑定在该对象上面
		var method=obj::obj.foo;
		等同于
		var method= ::obj.foo;
		》由于双冒号运算符返回的还是原对象，因此可以采用链式写法
	》尾调用优化
		》尾调用
			是函数式编程的一个重要概念，本身非常简单，一句话就能说清楚，
		    就是指某个函数的最后一步是调用另一个函数
		    如：
			function f(x){
				return g(x);
			}//函数f的最后一步是调用函数g，这就是尾调用
		    》以下三种情况，都**不属于**尾调用
			//情况1
			function f(x){
				let y=g(x);
				return y;
			}
			//情况2
			function f(x){
				return g(x)+1;
			}
			//情况3
			function f(x){
				//代码
				...

				g(x);
			}
			//情况3等同于
			function f(x){
				g(x);
				return undefined;
			}
			即：尾调用不一定出现在函数尾部，只要是最后一步操作即可
		》尾调用优化
			尾调用由于是函数的最后一步操作，所以不在需要保留外层函数的调用帧，因为调用位置、内部变量等信息
			都不会再用到了，只要直接用内层函数的调用帧，取代外层函数的调用帧就可以了
			--这就叫做"尾调用优化"，即只保留内层函数的调用帧。如果所有函数都是尾调用，那么完全可以做到每次
			执行时，调用帧只有一项，这将大大节省内存，这就是"尾调用优化"的意义
			注意：只有不在用到外层函数的内部变量，内存函数的调用帧才会取代外层函数的调用帧，否则就无法进行
			"尾调用优化"
		》尾递归
			函数调用自身，称为递归，如果尾调用自身，就称为尾递归
			递归非常耗费内存，因为需要同时保存成千上百个调用帧，很容易发生"栈溢出"错误，但是对于尾调用递归
			来说，由于只存在一个调用帧，所以永远不会发生"栈溢出"错误
			如：一个阶乘函数
			//正常情况下
			function factorial(n){
				if(n===1)return 1;
				return n*factorial(n-1);
			}
			factorial(5);//120
			//尾递归
			function factorail(n,total){
				if(n===1)return total;
				return factorial(n-1,n*total);
			}
			factorail(5,1);//120
		》递归函数的改写
			尾递归的实现，往往需要改写递归函数，确保最后一步只调用自身，做到这一点的方法
			就是把所有用到的内部变量改写成函数的参数。
		》严格模式
			ES6的尾调用优化只在严格模式下开启，正常模式是无效的，这是因为在正常模式下，函
			数内部有两个变量，可以跟踪函数的调用栈，
			》func.arguments:返回调用时函数的参数
			》func.caller:返回调用当前函数的那个函数
			尾调用优化发生时，函数的调用栈会改写，因此上面两个变量就会失真。严格模式禁用了
			这两个变量，所以尾调用模式仅在严格模式下生效
		》尾递归优化的实现
			尾递归优化只在严格模式下生效，那么正常模式下，或者那些不支持功能的环境中，有没有
			办法也使用尾递归优化呢？这是可以的即自己实现尾递归优化
			原理：尾递归之所以需要优化，原因是调用栈太多，造成溢出，那么只要减少调用栈，就不
			会溢出，即采用"循环"换掉"递归"。
	》函数参数的尾逗号
		ES7将允许函数的最后一个参数有尾逗号，此前，函数定义和调用时，都不允许最后一个参数后面出现逗号
		function clownsEverywhere(param1,param2,){
			//代码
			...
		}
20.对象的扩展
	》属性的简洁表示法--ES6允许直接写入变量和函数，作为对象的属性和方法
		如：//直接写入变量
			var foo='bar';
			var obj={foo}
			//等同于
			obj={foo:foo}
			即obj={foo:"bar"}
			即：对象的属性名为变量名，属性值为变量值
		如：//直接写入函数
			function fun(x,y){
				return {x,y};
			}
			//等同于
			function fun(x,y){
				return {x:x,y:y}
			}
			obj={fun}
		如：//简写方法
			var o={
				method(){
					return "hello";
				}
			}
			//等同于
			var o={
				method:function(){
					return "hello";
				}
			}
	》属性名表达式
		//js定义对象的属性，有两种方式
		》方式1//直接用标识符作为属性名
			obj.foo=true
		》方式2//用表达式作为属性名，这时要将表达式放入方括号之内
			obj['a'+'bc']=123
		但是使用字面量方式定义对象(使用大括号)，在ES5中只能使用方式1(标识符)定义属性
			var obj={
				foo:true,
				abc:123
			}
		ES6允许字面量定义对象时，用方式2(表达式)作为对象的属性名，即把表达式放在方括号内
			let propKey="foo";
			let obj={
				[propKey]:true,
				["a"+"bc"]:123
			}
		注意：属性名表达式与简洁表示法，不能同时使用，否则会报错
		      即：
			var foo='bar';
			var baz={[foo]}//报错
			var baz={[foo]:"abc"}//正确
		注意：属性名表达式如果是一个对象，默认情况下会自动将对象转为字符串[object object]
		      即：
		      const keyA={a:1}
		      const myObject={
				[keyA]:"valueA"//[object object]:"valueA"
		      }
	》方法的name属性--函数的name属性，返回函数名，对象方法也是函数，因此也有name属性
		var person={
			sayName(){
				console.log(this.name);
			}
			get firstName(){
				return "Nicholas";
			}
		}
		person.sayName.name//'sayName'
		person.firstName.name//'get firstName'
		上述代码中，方法的name属性返回函数名(即方法名)，如果使用了取值函数，则会在方面前面加上get
		如果是存值函数，方法名的前面会加上set
		注意：有两种情况比较特殊：
			》bind方法创造的函数 name属性会返回"bound"加上原函数的名字
			var doSomething=function(){...}
			doSomething.bind().name//'bound doSomething'
			》Function构造函数创造的函数，name属性返回"anonymous"
			(new Function()).name//"anonymous"
			》如果对象的方法是一个Symbol值，那么name属性返回的是这个Symbol值的描述
			const key1=Symbol("description");
			const key2=Symbol();
			let obj={
				[key1](){...},
				[key2](){...}
			}
			obj[key1].name;//'[description]'
			obj[key2].name;//""
	》Object.is()//ES5比较两个值是否相等，只有两个运算符：
		》相等运算符(==)
			会自动转换数据类型
		》严格相等运算符(===)
			NaN不等于自身，以及+0等于-0
		js缺乏一种运算，在所有环境中，只要两个值是一样的，它们就应该相等
		ES6提出了"Same-value equelity"同值相等算法，用来解决这个问题。object.is就是
		部署这个算法的新方法，它用来比较两个值是否严格相等，与严格比较运算符(===)的
		行为基本一致
		如：
		 Object.is('foo','foo');//true
		 Object.is({},{});//false
		 不同之处只有两个：一是：+0不等于-0 二是：NaN等于自身
	》Object.assign()//用于对象的合并，将源对象source的所有可枚举属性，复制到目标对象target
		var target={a:1};
		var source1={b:2};
		var source2={c:3};
		Object.assign(target,source1,source2);
		object.assign方法的第一个参数是目标对象，后面的参数都是源对象
		注意：如果目标对象与源对象有同名属性，或者多个源对象有同名属性，则后面的属性会覆盖前面
		的属性
		》如果只有一个参数，Object.assign会直接返回该参数
			var obj={a:1}
			Object.assign(obj)===obj//true
		》如果该参数不是对象，则会先转成对象，然后返回
			typeof Object.assign(2);//"object"
		》由于undefined和null无法转成对象，所以如果它们作为参数，就会报错
			Object.assign(undefined);//报错
			Object.assign(null);//报错
		》如果非对象参数出现在源对象的位置(即非首参数)，那么处理规则有所不同，首先，那些参数都会转成对象
			如果无法转成对象，就会跳过，这意味着如果undefined和null不在首参数，就不会报错
			let obj={a:1};
			Object.assign(obj,undefined)===obj//true
			Object.assign(obj,null)===obj//true
		  其他类型的值(即数值、字符串和布尔值)不首参数，也不会报错，但是，除了字符串会以数组形式，拷贝入目标对象，
		  其他值都不会产生效果
		  注意：Object.assign拷贝的属性是有限制的，只拷贝源对象的自身属性(不拷贝继承属性)以及不可枚举的属性(enumerable:false)
		  属性名为Symbol值的属性，也会被Object.assign拷贝
			如：Object.assign({a:"b"},{[Symbol("c")]:"d"});
		  注意：
			》Object.assign方法实行的是浅拷贝，而不是深拷贝。也就是说，如果源对象某个属性的值是对象，那么目标对象
			拷贝得到的是这个对象的引用,即这个对象的任何变化，都会反映到目标对象上面
			var obj1={a:{b:1}};
			var obj2=Object.assign({},obj1);
			注意：对于这种嵌套的对象，一旦遇到同名属性，Object.assign的处理方法是替换，而不是添加
			》Object.assign可以用来处理数组，但是会把数组视为对象
				Object.assign([1,2,3],[4,5]);//[4,5,3]
				上面代码中，Object.assign把数组视为属性名为0,1,2的对象，因此目标数组的0号属性4覆盖原数组的0号属性1
		》Object.assign方法的常用用途
			》为对象添加属性
				class Point{
					constructor(x,y){
						Object.assign(this,{x,y})
					}
				}
			》为对象添加方法
				Object.assign(SomeClass.prototype,{
					someMethod(arg1,arg2){
						...
					},
					anotherMethod(){
						...
					}
				});
				//等同于下面的写法
				SomeClass.prototype.someMethod=function(arg1,arg2){...};
				SomeClass.prototype.anotherMethod=function(){...}
			》克隆对象
				function clone(origin){
					return Object.assign({},origin);
				}
				//如果想要保持继承链
				function clone(origin){
					//得到origin对象的原型对象的标准方法
					let originProto=Object.getPrototypeOf(origin);
					return Object.assign(Object.create(originProto),origin);
				}
			》合并多个对象--将多个对象合并到某个对象
				//将多个对象合并到某个对象
				const merge=(target,...sources)=>Object.assign(target,...sources);
				//希望合并后返回一个新的对象
				const merge=(...sources)=>Object.assign({},...sources);
			》为属性指定默认值
				const DEFAULTS={//默认值
					logLevel:0,
				}
				function processContent(options){
					options=Object.assign({},DEFAULTS,options);
				}
	》属性的可枚举性;//对象的每个属性都有一个描述对象(Descriptor)，用来控制该属性的行为。
			 //Object.getOwnPropertyDescriptor方法可以获取该属性的描述对象
			 let obj={foo：123};
			 Object.getOwnPropertyDescriptor(obj,'foo');
			 结果：
				{
					value:123,
					writable:true,
					enumerable:true,
					configurable:true
				}
			//描述对象的enumerable属性，称为"可枚举性"，如果该属性为false，就表示某些操作会忽略当前属性
			ES5有三个操作会忽略enumerate为false的属性
				for...in循环：只遍历对象自身的和继承的可枚举的属性
				Object.keys():返回对象自身的所有可枚举的属性的键名
				JSON.stringify():只串行化对象自身的可枚举的属性
			ES6新增了一个操作 Object.assign()，会忽略enumerable为false的属性，只拷贝对象自身的可枚举的属性
			注意：以上四个操作之中，只有for...in会返回继承的属性，实际上，引入enumerable的最初目的就是让某
			些属性可以规避掉for...in操作。比如对象原型的toString方法，以及数组的length属性，就通过这种手段，
			不会被for...in遍历到
			ES6规定 所有的Class的原型的方法都是不可枚举的
	》属性的遍历--ES6一共有5中方法可以遍历对象的属性
		》for...in
			//for...in循环遍历对象自身的和继承的可枚举属性(不含Symbol属性)
		》Object.keys(obj)
			//返回一个数组，包括对象自身的(不含继承的)所有可枚举属性(不含Symbol属性)
		》Object.getOwnPropertyNames(obj);
			//返回一个数组，包含对象自身的所有属性(不含Symbol属性，但是包括不可枚举属性)
		》Object.getOwnPropertySymbols(obj)
			//返回一个数组，包含对象自身的所有Symbol属性
		》Reflect.ownKeys(obj)
			//返回一个数组，包含对象自身的所有属性。不管是属性名是Symbol或者字符串，也不管是否可枚举
		注意：以上5种方法遍历对象的属性，都遵守同样的属性遍历的次序规则
			》首先遍历所有属性名为数值的属性，按照数字排序
			》其次遍历所有属性名为字符串的属性，按照生成的时间排序
			》最后遍历所有属性名为Symbol值的属性，按照生成时间排序
			Reflect.ownKeys({[Symbol()]:0,b:0,10:0,2:0,a:0});
			//['2','10','b','a',Symbol()]
	》__proto__属性，Object.setPrototypeOf(),Object.getPrototypeOf()
		》__proto__属性
			//用来读取或设置当前对象的prototype对象，目前，所有浏览器都部署了这个属性
		》Object.setPrototypeOf(object,prototype)
			//其作用与__proto__相同，用来设置一个对象的prototype对象，它是ES6正式推荐的设置原型对象的方法
		》Object.getPrototypeOf(object)
			//该方法与setPrototypeOf方法配套，用于读取一个对象的prototype对象
	》Object.values()  Object.entries()
		》Object.keys()
			//ES5引入object.keys方法，返回一个数组，成员是参数对象自身的(不含继承的)所有可遍历的(enumerable)属性的键名
			var obj={foo:"bar",baz:42}
			Object.keys(obj);//["foo",'baz']
		//ES2017引入了根Object.keys配套的Object.values和Object.entries，作为遍历一个对象的补充手段
		》Object.values()
			//Object.values方法返回一个数组，成员是参数对象自身的(不含继承的)所有可遍历(enumerable)属性的键值
			var obj={foo:"bar",baz:42}
			Object.values(obj);//['bar',42]
			//返回数组的成员顺序，与上文的**属性的遍历**部分介绍的排列规则一致
			//Object.values会过滤属性名为Symbol值的属性
			Object.values({[Symbol()]:123,foo:"abc"});//['abc']
			//如果Object.values方法的参数是一个字符串，会返回各个字符组成的一个数组
			Object.values("foo");//["f","o","o"]
			注意：如果参数不是对象，Object.values会先将其转为对象，由于数值和布尔值的包装对象，都不会为实例添加非继承的属性
			所有 Object.values会返回空数组
			Object.values(42);//[]
			Object.values(true);//[]
		》Object.entries()
			//返回一个数组，成员是参数对象自身的(不含继承的)所有可遍历(enumerable)的属性的键值对数组
			var obj={foo:"bar",baz:42}
			Object.entries(obj);//[["foo","bar"],["baz",42]]
			//如果原对象的属性名是一个Symbol值，该属性会被省略
			Object.entries({[Symbol()]:123,foo:"abc"});
			//[["foo","abc"]]
			》基本用途是遍历对象的属性
				let obj={one:1,two:2};
				for(let [k,v] of Object.entries(obj)){
					console.log(k,v);
				}
			》将对象转为真正的Map结构
				var obj={foo:"bar",baz:42};
				var map=new Map(Object.entries(obj));
				map//Map {foo=>"bar",baz=>42}
	》对象的扩展运算符//ES7有一个提案，将Rest运算符(解构赋值)/扩展运算符(...)引入对象
		》解构赋值
			对象的解构赋值用于从一个对象取值，相当于将所有可遍历的、但尚未被读取的属性，分配到指定的对象上面。所有的键
			和它们的值，都会拷贝到新对象上面
			let {x,y,...z}={x:1,y:2,a:3,b:4};
			x//1
			y//2
			z//{a:3,b:4}
			//变量z是解构赋值所在的对象，它们获取等号右边的所有尚未读取的键(a和b)，将它们连同值一起拷贝过来
			//由于解构赋值要求等号右边是一个对象，所以如果等号右边是undefined或null就会报错，因为它们无法转为对象
			let {x,y,...z}=null;//报错
			let {x,y,...z}=undefined//报错
			//解构赋值必须是最后一个参数，否则会报错
			//注意：解构赋值的拷贝是浅拷贝，即如果一个键的值是复合类型的值(数组、对象、函数)，那么解构赋值拷贝的是这个值的引用
			//而不是这个值的副本
			let obj={a:{b:1}}
			let {...x}=obj
			obj.a.b=2;
			x.a.b//2
			//解构赋值不会拷贝继承自原型对象的属性
			let o1={a:1}
			let o2={b:2}
			o2.__proto__=o1;
			let o3={...o2}
			o3//{b:2}
		》扩展运算符//(...)用于取出参数对象的所有可遍历属性，拷贝到当前对象之中
			let z={a:3,b:4}
			let n={...z}//{a:3,b:4}
			等同于
			let aclone=Object.assign({},z);
			》扩展运算符可用于合并两个对象
				let ab={...a,...b}
				等同于
				let ab=Object.assign({},a,b);
			》如果用户自定义的属性，放在扩展运算符后面，则扩展运算符内部的同名属性会被覆盖
				let aOverrides={...a,x:1,y:2}
				等同于
				let aOverrides={...a,...{x:1,y:2}};
				等同于
				let x=1,y=2,aOverrides={...a,x,y}
				等同于
				let aOverrides=Object.assign({},a,{x:1,y:2});
				上面代码中，a对象的x属性和y属性，拷贝到新对象后会被覆盖掉
			》如果把自定义属性放在扩展运算符前面，就变成了设置新对象的默认属性值
				let aDefaults={x:1,y:2,...a}
			》如果扩展运算符的参数是null或undefined，这两个值会被忽略，不会被报错
				let emptyObject={...null,...undefined}//不报错
	》Object.getOwnPropertyDescriptors();
		》ES5有一个Object.getOwnPropertyDescriptor方法，返回某个对象属性的描述对象
			var obj={p:"a"}
			Object.getOwnPropetyDescriptor(obj,"p");
			Object{
				value:"a",
				writable:true,
				enumerable:true,
				configurable:true
			}
		》ES7有一个提案，提出了Object.getOwnPropertyDescriptors方法，返回指定对象所有自身属性(非继承属性)的描述对象
			const obj={
				foo:123,
				get bar(){return "abc"}
			}
			Object.getOwnPropertyDescriptors(obj);
			//{
				foo:{
					value:123,
					writable:true,
					enumerable:true,
					configurable:true
				},
				bar:{
					get:[Function:bar],
					set:undefined,
					enumerable:true,
					configurable:true
				}	
			}
			Object.getOwnPropertyDescritors方法返回一个对象，所有原对象的属性名都是该对象的属性名，对应
			的属性值就是该属性的描述对象
			这个方法的提出目的，主要是为了解决Object.assign()无法正确拷贝get属性和set属性的问题
			const source={
				set foo(value){
					console.log(value);
				}
			}
			const target={};
			Object.assign(target,source);
			console.log(target.foo);//undefined
			上面代码中，source对象的foo属性的值是一个赋值函数，Object.assign方法将属性拷贝给target对象，结果
			该属性的值变成了undefined，这是因为Object.assign方法总是拷贝一个属性的值，而不会拷贝它背后的赋值
			方法或取值方法
			这时，Object.getOwnPropertyDescriptors方法配合Object.defineProperties方法就可以实现正确拷贝
			const source={
				set foo(value){
					console.log(value);
				}
			}
			const target={};
			Object.defineProperties(target,Object.getOwnPropertyDescriptors(source));
			//配合Object.create方法，将对象属性克隆到一个新对象中
			const clone=(obj)=>Object.create(Object.getPrototypeOf(obj),Object.getOwnPropertyDescriptors(obj));
			//一个对象继承另一个对象
				方式1：
				const obj={
					__proto__:proto,
					foo:123
				}
				方式2：
				const obj=Object.create(proto);
				obj.foo=123
				方式3：
				const obj=Object.assign(Object.create(proto),{foo:123});
				方式4：
				const obj=Object.create(proto,Object.getOwnPropertyDescriptors({foo:123}));
			//用来实现Mixin混入模式
				let mix=(obj)=>({
					with:(...mixins)=>mixins.reduce((c,mixin)=>Object.create(c,Object.getOwnPropertyDescriptors(mixin)),obj)
				})
				let a={a:"a"}
				let b={b:"b"}
				let c={c:"c"}
				let d=mix(c).with(a,b);
				//对象a和b被混入对象c中
21.Symbol
	》概述
		ES5的对象属性名都是字符串，这容易造成属性名的冲突，如你使用了一个她人提供的对象，但是又想为这个对象添加新的方法，新方法名
		就有可能与现有方法产生冲突。如果有一种机制，保证每个属性名都是独一无二的就好了，这样就从根本上防止属性名的冲突，这就是ES6
		引入Symbol的原因
		ES6引入了一种新的原始数据类型Symbol,表示独一无二的值，它是js语言的第七种数据类型，前六种：undefined  null boolean String
		Number  Object
		Symbol值通过Symbol函数生成，这就是说，对象的属性名现在可以有两种类型，一种是原来就有的字符串，另一种就是新增的Symbol类型
		凡是属性名属于Symbol类型就都是独一无二的，可以保证不会与其他属性名产生冲突
		如 let s=Symbol();
		typeof s//"symbol"
		注意：Symbol函数前不能使用new命令，否则会报错。这是因为生成的Symbol是一个原始类型的值，不是对象。也就是说 由于Symbol值不是
		对象，所以不能添加属性，基本上它是一种类似于字符串的数据类型
		Symbol函数可以接受一个**字符串**作为参数，表示对Symbol实例的描述，主要是为了在控制台显示，或者转为字符串时比较容易区分
		var s1=Symbol("foo");
		s1//Symbol(foo);
		》如果Symbol的参数是一个对象，就会调用该对象的toString方法，将其转为字符串，然后才生成一个Symbol值
		》Symbol函数的参数**只是表示对当前Symbol值的描述**，因此相同参数的Symbol函数返回值是不相等的
			Symbol("foo")===Symbol("foo")//false
		》Symbol值**不能**与其他类型的值进行运行，会报错，如字符串的拼接
		》Symbol值可以显示转为字符串
			String(Symbol("My symbol"));
			Symbol().toString();
		》Symbol值也可以转为布尔值，但是不能转为数值
			Boolean(Symbol());
	》作为属性名的Symbol
		由于每一个Symbol值都是不相等的，这意味着Symbol值可以作为标识符，用于对象的属性名，就能保证不会出现同名的属性。
		这对于一个对象由多个模块构成的情况非常有用，能防止某一个键不小心改写或覆盖
		var mySymbol=Symbol();
		//第一种写法
		var a={};
		a[mySymbol]='hello!';
		//第二种写法
		var a={
			[mySymbol]:"hello"
		}
		//第三种
		var a={}
		Object.defineProperty(a,mySymbol,{value:"hello"});
		//以上写法的结果
		a[mySymbol]//'hello'
		注意：Symbol值作为对象属性名时，不能用点运算符
		var mySymbol=Symbol();
		var a={};
		a.mySymbol='hello';
		a[mySymbol]//undefined
		a['mySymbol']//'hello'
		上面代码中，因为点运算符后面总是字符串，所以不会读取mySymbol作为标识名所指代的那个值，
		导致a的属性名实际上是一个字符串，而不是一个Symbol值
		同理，在对象的内部，使用Symbol值定义属性时，Symbol值必须放在方括号中
		let s=Symbol();
		let obj={
			[s]:function (){...}
		}
		注意：Symbol值作为属性名时，该属性还是公开属性，不是私有属性
	》实例：消除魔术字符串
		魔术字符串：在代码之中多次出现，与代码形成耦合的某一个具体的字符串或者数值。
		风格良好的代码，应该尽量消除魔术字符串，该由含义清晰的变量代替
		function getArea(shape){
			switch (shape){
				case "Triangle";//魔术字符串
			}
		}
		getArea("Triangle");//魔术字符串
		/********消除魔术字符串********/
		const shapeType={
			triangle:Symbol();
		}
		function getArea(shape){
			switch (shape){
				case shapeType.triangle;//魔术字符串
			}
		}
		getArea(shapeType.triangle);//魔术字符串
	》属性名的遍历
		Symbol作为属性名，该属性不会出现在for...in，for...of循环中，也不会被Object.keys(),Object.getOwnPropertyNames(),
		JSON.stringify()返回，但是，它也不是私有属性，
		有一个Object.getOwnPropertySymbols方法，可以获取指定对象的所有Symbol属性名
		var obj={
			[Symbol("a")]:"hello"
		}
		var objSym=Object.getOwnPropertySymbols(obj);//[Symbol(a)]
		》Object.getOwnPropertySymbols与for..in循环、Object.getOwnPropertyNames方法进行对比
			var obj={};
			Object.defineProperty(obj,Symbol("foo"),{value:"foobar"});
			for (var i in obj){
				console.log(i);//无输出
			}
			Object.getOwnPropertyNames(obj);//[]
			Object.getOwnPropertySymbols(obj);//[Symbol(foo)]
		》Reflect.ownKeys方法可以返回所有类型的键名，包括常规键名和Symbol键名
			let  obj={
				[Symbol("my_key")]:1,
				enum:2
			}
			Reflect.ownKeys(obj);//[Symbol(my_key),'enum']
		》由于以Symbol值作为名称的属性，不会被常规方法遍历得到。我们可以利用这个特性，
		  为对象定义一些非私有的，但又希望只用于内部的方法
	》Symbol.for() Symbol.keyFor()
		有时，我们希望重新使用同一个Symbol值，Symbol.for方法可以做到这一点，它接受一个字符串作为参数，然后搜索有没有以该参数
		作为名称的Symbol值，如果有，就返回这个值Symbol值，否则就新建并返回一个以该字符串为名称的Symbol值
		var s1=Symbol.for("foo");
		var s2=Symbol.for("foo");
		s1===s2//true
		s1===Symbol("foo");//false
		Symbol.for和Symbol()这两种写法，都会生成新的Symbol，他们的区别是，***前者会被登记在全局环境中供搜索****，后者不会。Symbol.for
		不会每次调用就返回一个新的Symbol类型的值，而是先检查给定的key是否已经存在，如果不存在才会新建一个值。如：如果你调用Symbol.for
		30次，每次都会返回同一个Symbol值，但是调用Symbol("cat")30次，会返回30个不同的Symbol值
		》Symbol.keyFor方法返回一个已登记的Symbol类型的值的key
			/********有登记的机制********/
			var s1=Symbol.for("foo");
			Symbol.keyFor(s1);//"foo"
			/********无登记的机制********/
			var s2=Symbol("foo");
			Symbol.keyFor(s2);//undefined
		注意：Symbol.for为Symbol值登记的名字，是全局环境的，可以在不同的iframe或service worker中取同一个值
	》实例：模块的Singleton模式
		Singleton模式指的是调用一个类，任何时候返回的都是同一个实例(单例模式)
		对于Node来说，模块文件可以看成是一个类。怎么保证每次执行这个模块文件，返回的都是同一个实例呢？
		即把实例放到顶层对象global中即可：
			//mod.js
			function A(){
				this.foo="hello";
			}
			if(!global._foo){
				global._foo=new A();
			}
			module.exports=global._foo;
			//调用时
			var a=require("./mod.js");
			console.log(a.foo);//'hello'
			虽然变量a任何时候加载的都是A的同一个实例，但是，这里的全局变量global._foo是可写的，任何文件都可以修改
			为了防止这种情况出现，我们可以使用Symbol
			//mod.js
			const FOO_KEY=Symbol("foo");
			function A(){
				this.foo='hello';
			}
			if(!global[FOO_KEY]){
				gobal[FOO_KEY]=new A();
			}
			module.exports=global[FOO_KEY];
	》内置的Symbol值--除了定义自己使用的Symbol值以外，ES6还提供了11个内置的Symbol值，指向语言内部使用的方法
		》Symbol.hasInstance
			对象的Symbol.hasInstance属性，指向一个内部方法，当其他对象使用instanceof运算符，判断是否为该对象的实例时
			会调用这个方法。如：foo instanceof Foo在语言内部 实际调用的是FOO[Symbol.hasInstance](foo);
			class Myclass{
				[Symbol.hasInstance](foo){
					return foo instanceof Array;
				}
			}
			[1,2] instanceof new Myclass();//true
			上面代码中，Myclass是一个类，new Myclass()会返回一个实例。该实例的Symbol.hasInstance方法，会进行instanceof运算时
			自动调用，判断左侧的运算子是否为Array实例
			class Even{
				static [Symbol.hasInstance](obj){
					return Number(obj)%2===0;
				}
			}
			1 instanceof Even;//false
			2 instanceof Even;//true
		》Symbol.isConcatSpreadable//对象的Symbol.isConcatSpreadable属性等于一个布尔值，表示该对象使用Array.prototype.concat时，是否可以展开
			let arr1=['c','d'];
			['a','b'].concat(arr1,'e');//['a','b','c','d','e']
			arr1[Symbol.isConcatSpreadable]//undefined
			/**使用上面属性**/
			let arr2=['c','d'];
			arr2[Symbol.isConcatSpreadable]=false;
			['a','b'].concat(arr2,'e');//['a','b',['c','d'],'e']
			上面代码说明，数组的默认行为是可以展开的，Symbol.isConcatSpreadable属性等于true或undefined都有这个效果
			类数组的对象也可以展开，但是它的Symbol.isConcatSpreadable属性默认是false，必须手动打开
			let obj={length:2,0:'c',1:'d'}
			['a','b'].concat(obj,'e');//['a','b',obj,'e']
			obj[Symbol.isConcatSpreadable]=true;
			['a','b'].concat(obj,'e');//['a','b','c','d','e']
			》对于一个类来说，Symbol.isConcatSpreadable属性必须写成实例的属性
				//可展开的
				class A1 extends Array{
					constructor(args){
						super(args);
						this[Symbol.isConcatSpreadable]=true;
					}
				}
				//不可展开的
				class A2 extends Array{
					constructor(args){
						super(args);
						this[Symbol.isConcatSpreadable]=false;
					}
				}
				let a1=new A1();
				a1[0]=3;
				a1[1]=4;
				let a2=new A2();
				a2[0]=5;
				a2[1]=6;
				[1,2].concat(a1).concat(a2);//[1,2,3,4,[5,6]]
		》Symbol.species//指向用来创建派生类对象的构造函数
			对象的Symbol.species属性，指向一个方法，该对象作为构造函数创造实例时，会调用这个方法，
			即如果this.constructor[Symbol.species]存在，就会使用这个属性作为构造函数，来创造新的
			实例对象
			//扩展Array的构造函数
			class MyArray extends Array{
				static get [Symbol.species](){
					return Array;
				}
			}
			var a=new MyArray(1,2,3);
			var mapped=a.map(x=>x*x);
			console.log(mapped instanceof MyArray);//false
			console.log(mapped instanceof Array);//true
		》Symbol.match
			对象的Symbol.match属性，指向一个函数。
			当执行str.match(myObject)时，如果该属性存在，会调用它，返回该方法的返回值
			String.prototype.match(regexp);
			//等同于
			regexp[Symbol.match](this)
			class MyMatcher{
				[Symbol.match](string){
					return 'hello world'.indexOf(string);
				}
			}
			'e'.match(new MyMatcher());//1
		》Symbol.replace;
			对象的Symbol.replace属性，指向一个方法，
			当该对象被String.prototype.replace方法调用时，会返回该方法的返回值
			String.prototype.replace(searchValue,replaceValue);
			//等同于
			searchValue[Symbol.replace](this,replaceValue);
			如：
			const x={};
			x[Symbol.replace]=(...s)=>console.log(s);
			'hello'.replace(x,'world');//['hello','world']
			Symbol.replace方法会收到两个参数，第一个参数是replace方法正在作用的对象，上面例子是hello
			第二个参数是替换后的值，上面例子是world
		》Symbol.search
			对象的Symbol.search属性，指向一个方法，
			当该对象被String.prototype.search方法调用时，会返回该方法的返回值
			String.prototype.search(regexp);
			//等同于
			regexp[Symbol.search](this);
			class MySearch{
				constructor(value){
					this.value=value;
				}
				[Symbol.search](string){
					return string.indexOf(this.value);
				}
			}
			'foobar'.search(new MySearch('foo'));//0
		》Symbol.split
			对象的Symbol.split属性，指向一个方法
			当该对象被String.prototype.split方法调用时，会返回该方法的返回值
			String.prototype.split(separator,limit);
			//等同于
			separator[Symbol.split](this,limit);
		》Symbol.iterator
			对象的Symbol.iterator属性，指向该对象的默认遍历器方法
			var myIterable={};
			myIterable[Symbol.iterator]=function* (){
				yield 1;
				yield 2;
				yield 3;
			}
			[...myIterable]//[1,2,3]
			//对象进行for...of循环时，会调用Symbol.iterator方法，返回该对象的默认遍历器
			class Collection{
				*[Symbol.iterator](){
					let i=0;
					while(this[i] !== undefined){
						yield this[i];
						++i;
					}
				}
			}
			let myCollection=new Collection();
			myCollection[0]=1
			myCollection[1]=2
			for(let value of myCollection){
				conosle.log(value);
			}
			//1
			//2
		》Symbol.toPrimitive
			对象的Symbol.toPrimitive属性，指向一个方法，
			该对象被转为原始类型的值时，会调用这个方法，返回这个对象对应的原始类型值
			Symbol.toPrimitive被调用时，会接受一个字符串参数，表示当前运算的模式，
			一共有三种模式：
				Number:该场合需要转成数值
				String:该场合需要转成字符串
				Default:该场合可以转成数值，也可以转成字符串
			let obj={
				[Symbol.toPrimitive](hint){
					switch(hint){
						case 'number':
							return 123;
						case 'string':
							return 'str';
						case 'default':
							return 'default';
						default:
							throw new Error();
					}
				}
			}
			2*obj//246
			3+obj//'3default'
			obj=='default'//true
			String(obj);//str
		》Symbol.toStringTag
			对象的Symbol.toStringTag属性，指向一个方法。
			在该对象上面调用Object.prototype.toString方法时，如果这个属性存在，
			它的返回值会出现在toString方法返回的字符串之中，表示对象的类型。
			也就是说，这个属性可以用来定制[object object]或[object Array]中object后面的那个字符串
			如：
				console.log({[Symbol.toStringTag]:"Foo"}).toString());//[object Foo]
				class Collection{
					get [Symbox.toStringTag](){
						return 'xxx';
					}
				}
				Object.prototype.toString.call(new Collection());//[object xxx]
			》ES6新增内置对象的Symbol.toStringTag属性值
				》JSON[Symbol.toStringTag]:"JSON"
				》Math[Symbol.toStringTag]:"Math"
				》Module对象 M[Symbol.toStringTag]:"Module"
				》ArrayBuffer.prototype[Symbol.toStringTag]:"ArrayBuffer"
				》DataView.prototype[Symbol.toStringTag]:"DataView"
				》Map.prototype[Symbol.toStringTag]:"Map"
				》Promise.prototype[Symbol.toStringTag]:"Promise"
				》Set.prototype[Symbol.toStringTag]:"Set"
				》%TypedArray%.prototype[Symbol.toStringTag]：'Uint8Array'等
				》WeakMap.prototype[Symbol.toStringTag]：'WeakMap'
				》WeakSet.prototype[Symbol.toStringTag]：'WeakSet'
				》%MapIteratorPrototype%[Symbol.toStringTag]：'Map Iterator'
				》%SetIteratorPrototype%[Symbol.toStringTag]：'Set Iterator'
				》%StringIteratorPrototype%[Symbol.toStringTag]：'String Iterator'
				》Symbol.prototype[Symbol.toStringTag]：'Symbol'
				》Generator.prototype[Symbol.toStringTag]：'Generator'
				》GeneratorFunction.prototype[Symbol.toStringTag]：'GeneratorFunction'
		》Symbol.unscopables
			对象的Symbol.unscopables属性，指向一个对象
			该对象指定了使用with关键字时，那些属性会被with环境排除
			Array.prototype[Symbol.unscropables]
				// {
				//   copyWithin: true,
				//   entries: true,
				//   fill: true,
				//   find: true,
				//   findIndex: true,
				//   keys: true
				// }
			Object.keys(Array.prototype[Symbol.unscropables]);
				// ['copyWithin', 'entries', 'fill', 'find', 'findIndex', 'keys']
				即 数组有6个属性，会被with命令排除
			//没有unscropables时
			class MyClass{
				foo(){
					return 1;
				}
			}
			var foo=function (){return 2;}
			with(MyClass.prototype){
				foo();//1
			}
			//有unscopables时
			class MyClass {
			  foo() { 
				return 1; 
			  }
			  get [Symbol.unscopables]() {
			    return { foo: true };
			  }
			}
			var foo = function () { return 2; };
			with (MyClass.prototype) {
			  foo(); // 2
			}
22.Set和Map数据结构
	》Set
		ES6提供了新的数据结构Set，它类似于数组，但是**成员的值都是唯一的**，没有重复的值
		Set本身是一个构造函数，用来生成Set数据结构
		var s=new Set();
		[2,3,5,3,2].map(x=>s.add(x));
		for(let i of s){
			console.log(i);
		}//2,3,5
		//上述代码通过add方法向Set结构加入成员，结果表明Set结构不会添加重复的值
		Set函数可以接受一个数组(或者类似数组的对象)作为参数，用来初始化
		var set=new Set([2,3,5,3,2]);
		[...set];//[2,3,5]
		set.size;//3
		》去除数组重复成员的方法
			[...new Set(array)]
		注意：向Set加入值的时候，不会发生类型转换，所以5和"5"是两个不同的值，
		Set内部判断两个值是否不同，使用的算法叫"same-value equality"，它类似于精确相等运算符(===),主要的区别是NaN等于自身
		而精确相等运算符认为NaN不等于自身
		let set=new Set();
		let a=NaN;
		let b=NaN;
		set.add(a);
		set.add(b);
		set//Set{NaN}
		》两个对象总是不相等的即使是两个空对象也是不相等的
		》Set实例的属性和方法
			》属性
				Set.prototype.constructor构造函数，默认是Set函数
				Set.prototype.size:返回Set实例的成员总数
			》Set实例的方法
				》操作方法
					》add(value);//添加某个值，返回Set结构本身
					》delete(value);//删除某个值，返回一个布尔值，表示删除是否成功
					》has(value);//返回一个布尔值，表示该值是否为Set的成员
					》clear();//清除所有成员，没有返回值
					》Array.from方法可以将Set结构转为数组
						var array=Array.from(new Set([1,2,3,3]));
				》遍历方法
					》keys();//返回键名的遍历器
					》values();//返回键值的遍历器
					》entries();//返回键值对的遍历器
					》forEach();//使用回调函数遍历每个成员
					注意：Set的遍历顺序就是插入顺序，这个特性有时非常有用，
					比如使用Set保存一个回调函数列表，调用时就能保证按照添加顺序调用
					由于Set结构没有键名，只有键值(或者说键名和键值是同一个值)，所以keys和values方法的行为完全一致
					let set=new Set(['red','green','blue']);
					for(let item of set.keys()){
						console.log(item);// red green blue
					}
					for(let item of set.values()){
						console.log(item);//red green blue
					}
					for(let item of set.entries()){
						console.log(item);//['red','red'] ['green','green']['blue','blue']
					}
					注意：entries方法返回的遍历器，同时包括键名和键值，所以每次输出一个**数组**
					Set结构的实例默认可遍历，它的默认遍历器生成函数就是它的values方法。
						即：Set.prototype[Symbol.iterator]===Set.prototype.values
						这意味着，可以省略values方法，直接用for...of循环遍历Set
						let  set=new Set(['red','green','blue']);
						for(let x of set){
							console.log(x);//red green  blue
						}
					》forEach
						Set结构的实例的forEach方法，用于对每个成员执行某种操作，没有返回值
						let set=new Set([1,2,3]);
						set.forEach((value,key,set)=>console.log(value*2),this);
						forEach方法的参数就是一个处理函数，该函数的参数依次为键值、键名、集合本身。另外forEach
						方法还可以有第二个参数，表示绑定的this对象
				》遍历的应用
					扩展运算符(...)内部使用for...of循环，所以也可以用于Set结构
						let set=new Set(['red','green','blue']);
						let arr=[...set];//['red','green','blue']
					扩展运算符和Set结构相结合，就可以去除数组的重复成员
						let arr=[3,5,2,2,5,5];
						let unique=[...new Set(arr)];//[3,5,2]
					》数组的map和filter用于Set
						let set=new Set([1,2,3]);
						set=new Set([...set].map(x=>x*2));//{2,4,6}

						let set=new Set([1,2,3,4,5]);
						set=new Set([...set].filter(x=>x%2==0));//{2,4}
					》使用Set可以很容易实现并集(Union)、交集(Intersect)、差集(Defference)
						let a=new Set([1,2,3]);
						let b=new Set([4,3,2]);
						//并集
						let union=new Set([...a,...b]);//{1,2,3,4}
						//交集
						let intersect=new Set([...a].filter(x=>b.has(x)));//{2,3}
						//差集
						let defference=new Set([...a].filter(x=>!b.has(x)));//{1}
					//如果想在遍历操作中，同步改变原来的Set结构，目前没有直接的方法，但是有两种变通方法。
					//一种是利用原Set结构映射出一个新的结构，然后赋值给原来的Set结构
						let set =new Set([1,2,3]);
						set=new Set([...set].map(val=>val*2));//{2,4,6}
					//另一种是利用Array.from方法
						let set=new Set([1,2,3]);
						set=new Set(Array.from(set,val=>val*2));//{2,4,6}			
	》WeakSet
		WeakSet结构与Set类似，也是不重复的值的集合，但是它和Set有两个区别：
			》WeakSet的成员只能是对象，而不能是其他类型的值
			》WeakSet中的对象都是弱引用，即垃圾回收机制不考虑WeakSet对该对象的引用，也就是说，如果其他对象
			都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于WeakSet之中，
			这个特点意味着，无法引用WeakSet的成员，因此WeakSet是不可遍历的
			WeakSet是一个构造函数，可以使用new命令，创建WeakSet数据结构
				var ws=new WeakSet();
			作为构造函数，WeakSet可以接受一个数组或类似数组的对象作为参数，实际上，任何具有Iterable接口的对象
			都可以作为WeakSet的参数。该数组的所有成员，都会自动成为WeakSet实例对象的成员
				var ws=new WeakSet([1,2])//报错
				注意，是数组的成员成为WeakSet的成员，而不是数组本身，这意味着，数组的成员**只能是对象**
		》WeakSet结构方法：
			》WeakSet.prototype.add(value);//向WeakSet实例添加一个新成员
			》WeakSet.prototype.delete(value);//清除WeakSet实例的指定成员
			》WeakSet.prototype.has(value);//返回一个布尔值，表示某一值是否在WeakSet实例之中
			WeakSet不能遍历，是因为成员都是弱引用，随时可能消失，遍历机制无法保证成员的存在，很可能刚刚遍历结束，
			成员就取不到了。WeakSet的一个用处，是存储DOM节点，而不担心这些节点从文档移除时，会引发内存泄漏
	》Map
		JS的对象，本质上是键值对的集合(Hash结构)，但是传统上只能用字符串当作键。这给它的使用带来了很大的限制
		var data={};
		var element=document.getElementById("myDiv");
		data[element]='metadata';
		//data['[object HTMLDivElement]'] 'metadata'
		上面代码原意是将一个DOM节点作为对象的data的键，但是由于对象只接受字符串作为键名，
		所以element被自动转为字符串[object HTMLDivElement]。
		为了解决这个问题，ES6提供了Map数据结构。它类似于对象，也是键值对的集合，但是"键"的范围不限于字符串，各种类型的值
		(包括对象)都可以当作键。也就是说，Object结构提供了"字符串-值"的对应，Map结构提供了"值-值"的对应，是一种更完善的Hash
		结构实现。如果你需要"键值对"的数据结构，Map比Object更合适
		var m=new Map();
		var o={p:'hello world'}
		m.set(o,'content');
		m.get(o);//'content'
		m.has(o);//true
		m.delete(o);//true
		作为构造函数，Map也可以接受一个数组作为参数，该数组的成员是一个个表示键值对的数组
		var map=new Map([
			['name','张三'],
			['title','Author']
		]);
		map.size;//2
		Map构造函数接受数组作为参数，实际上执行的是下面的算法：
		var items=[
			['name','张三'],
			['title','Author']
		];
		var map=new Map();
		items.forEach(([key,value])=>map.set(key,value););
		》如果对同一个键多次赋值，后面的值将覆盖前面的值，字符串true和布尔值true是两个不同的键
		》如果读取一个未知的键则返回undefined
			new Map().get("asfddfsasadf");//undefined
		》注意：只有对同一个对象的引用，Map结构才将其视为同一个键
			var map=new Map();
			map.set(['a'],555);
			map.get(['a']);//undefined
			Map的键实际上是根内存地址绑定的，只要内存地址不一样，就视为两个键。这就解决了同名属性碰撞的问题，我们
			扩展别人的库的时候，如果使用对象作为键名，就不用担心自己的属性与原作者的属性同名。
			如果Map的键是一个简单类型的值(数字、字符串、布尔值)，则只要两个值严格相等，Map将其视为一个键。包括
			0和-0，另外虽然NaN不严格相等于自身，但Map将其视为同一个键
			let map=new Map();
			map.set(NaN,123);
			map.get(NaN);//123
			map.set(-0,123);
			map.get(+0);//123
		》实例的属性和操作方法
			》size属性--返回Map结构的成员总数
				let map=new Map();
				map.set('foo',true);
				map.set('bar',false);
				map.size;//2
			》set(key,value)--设置key所对应的键值，然后返回整个Map结构，如果key已经有值，则键值会被更新，否则就新生成该键
				var m=new Map();
				m.set(undefined,'nah');//键是undefined
				》set方法返回的是Map本身，因此可以采用链式写法
					var map=new Map().set(1,'a').set(2,'b');
			》get(key)--读取key对应的键值，如果找不到key，返回undefined
				var m=new Map();
				var hello=function(){conosle.log('hello');}
				m.set(hello,'hello Es6');//键是函数
				m.get(hello);//hello Es6
				m.set('hello',hello);//键值是函数
				m.get("hello")();//hello
			》has(key)--返回一个布尔值，表示某个键是否在Map数据结构中
				var m=new Map();
				m.set(undefined,'nah');
				m.has(undefined);//true
			》delete(key)--删除某个键，返回true，如果删除失败，返回false
				var m=new Map();
				m.set(undefined,'nah');
				m.delete(undefined);//true
				m.delete(a);//false  删除不存在的键
			》clear()--清除所有成员，没有返回值
				let map=new Map();
				map.set('foo',true);
				map.size;//1
				map.clear();
				map.size//0
		》遍历方法--Map原生提供三个遍历器生成函数和一个遍历方法
			注意：Map的遍历顺序就是插入顺序
			let map=new Map([
				['F','no'],
				['T','yes']
			]);
			》keys()--返回键名的遍历器
				for(let key of map.keys()){
					console.log(key);//'F' 'T'
				}
			》values()--返回键值的遍历器
				for(let value of map.values()){
					console.log(value);//'no' 'yes'
				}
			》entries()--返回所有成员的遍历器
				for(let item of map.entries()){
					console.log(item);//['F','no'] ['T','yes']
				}
				或
				for(let [key,value] of map.entries()){
					console.log(key,value);
				}
				或
				for(let [key,value] of map){//表示Map结构的默认遍历器接口Symbol.iterator属性就是entries方法 map[Symbol.iterator]===map.entries //true
					console.log(key,value);
				}
			》Map结构转为数组结构，比较快速的方法是结合使用扩展运算符(...)
				let map=new Map([
					[1,'one'],
					[2,'two']
				]);
				[...map.keys()]//[1,2]
				[...map.values()]//['one','two']
				[...map.entries()]//[[1,'one'],[1,'two']]
				[...map]//[[1,'one'],[1,'two']]
				结合数组的map方法、filter方法可以实现Map的遍历和过滤(Map本身没有map和filter方法)
				let map=new Map().set(1,'a').set(2,'b');
				map=new Map([...map].filter(([k,v])=>k<2));
				//map {1=>'a'}
				map=new Map([...map].map(([k,v])=>[k*2,'_'+v]));
				//map {2=>'_a'}
			》forEach()--遍历Map的所有成员;第二个参数，用来绑定回调函数中的this对象
				map.forEach(function(value,key,map){
				
				},this);
		》与其他数据结构的互相转换
			》Map转为数组--使用扩展运算符
				[...new Map().set(1,'a').set(2,'b')]//[[1,'a'],[2,'b']]
			》数组转为Map--将数组转入Map构造函数
				new Map([[1,'a'],[2,'b']]);//Map {1=>'a',2=>'b'}
			》Map转为对象--如果所有Map的键都是字符串，它可以转为对象
				function strMapToObj(strMap){
					let obj=Object.create(null);
					for(let [k,v] of strMap){
						obj[k]=v;
					}
					return obj;
				}
				let myMap = new Map().set('yes', true).set('no', false);
				strMapToObj(myMap)// { yes: true, no: false }
			》对象转为Map
				function objToStrMap(obj){
					let strMap=new Map();
					for(let k of Object.keys(obj)){
						strMap.set(k,obj[k]);
					}
					return strMap;
				}
				objToStrMap({yes: true, no: false});//Map {"yes" => true, "no" => false}
			》Map转为JSON
				Map转为JSON分两种情况：
				》Map的键名都是字符串，这时可以选择转为对象JSON
					function strMapToJson(strMap){
						return JSON.stringify(strMapToObj(strMap));
					}
				》Map的键名有非字符串，这时可以选择转为数组JSON
					function mapToArrayJson(map){
						return JSON.stringify([...map]);
					}
			》JSON转为Map
				》正常情况下，所有的键名都是字符串
					function jsonToStrMap(jsonStr){
						return objToStrMap(JSON.parse(jsonStr));
					}
				》整个JSON就是一个数组，且每个数组成员本身，又是一个有两个成员的数组
				  这时它可以一一对应的转为Map，这往往是数组转为JSON的逆操作。
					function jsonToMap(jsonStr){
						return new Map(JSON.parse(jsonStr));
					}		
	》WeakMap
		WeakMap结构与Map结构基本类似，唯一的区别是它**只接受对象**作为键名(null除外)，
		不接受其他类型的值作为键名，而且键名所指向的对象，不计入垃圾回收机制
		var map=new  WeakMap();
		map.set(1,2);//报错
		WeakMap的设计目的在于，键名是对象的弱引用(垃圾回收机制不将该引用考虑在内)，所以其所对应的
		对象可能会被自动回收，当对象被回收后，WeakMap**自动移除**对应的键值对。
		典型应用：一个对应DOM元素的WeakMap结构，当某个DOM元素被清除，其所对应的WeakMap记录就会自动
		被移除。基本上，WeakMap的专用场合就是，它的键所对应的对象，可能会在将来消失，WeakMap结构有
		助于防止内存泄露
		WeakMap与Map的用法差不多，其主要区别有两个：
			》一是没有遍历操作
				即没有keys() values()  entries()也没有size属性
			》而是无法清空
				即不支持clear方法，这与WeakMap的键不被计入引用，被垃圾回收机制忽略有关
			因此WeakMap只有四个方法可用：get() set() has() delete()
		》WeakMap的典型场合  DOM节点作为键名
			let myElement=document.getElementById('logo');
			let myWeakmap=new WeakMap();
			myWeakmap.set(myElement,{timesClicked:0});
			myElement.addEventListener("click",function(){
				myWeakmap.get(myElement).timesClicked++;
			},false);
			上述代码中，myElement是一个DOM节点，每当发生click事件，就更新一下状态。我们将这个
			状态作为键值放在WeakMap里，对应的键名就是myElement.一旦这个DOM节点删除，该状态就
			会自动消失，不存在内存泄露风险
		》WeakMap的另一个用途就是部署私有属性
			let _counter=new WeakMap();
			let _action=new WeakMap();
			class Countdown{
				constructor(counter,action){
					_counter.set(this,counter);
					_action.set(this,action);
				}
				dec(){
					let counter=_counter.get(this);
					if(counter<1) return;
					counter--;
					_counter.set(this,counter);
					if(counter===0){
						_action.get(this)();
					}
				}
			}
			let c=new Countdown(2,()=>console.log("DONE"));
			上面代码中，Countdown类的两个内部属性_counter和_action，是实例的弱引用，
			所以如果删除实例，它们也就随之消失，不会造成内存泄漏。
23.Proxy和Reflect
	》Proxy概述
		Proxy用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种"元编程"，即对编程语言进行编程
		Proxy可以理解成，在目标对象之前架设一层"拦截",外界对该对象的访问，都必须先通过这层拦截，因此提供了一种
	    机制，可以对外界的访问进行过滤和改写。Proxy这个词原意是代理，用在这里表示由它来"代理"某些操作，可以称为"代理器"
	    》ES6原生提供Proxy构造函数用来生成Proxy实例
		var proxy=new Proxy(target,handler);
		Proxy对象的所有用法都是上面这种形式，不同的只是handler参数的写法，
		其中：target参数表示所要拦截的目标对象
		      handler参数也是一个对象，用来定制拦截行为
		》var proxy=new Proxy({},{
			get:function(target,property){
				return 35;
			}
		  });
		  proxy.time//35;
		  proxy.name//35
		  proxy.title//35
		  》第一个参数是所要代理的目标对象，即如果没有Proxy介入，操作原来要访问的这个对象
		  》第二个参数是一个配置对象，对于每一个被代理的操作，需要提供一个对应的处理函数，该
		    函数将拦截对应的操作，比如上面代码中配置对象有一个get方法，用来接对目标对象属性的
		    访问请求。get方法的两个参数分别是目标对象和所要访问的属性。
			  注意：要使得Proxy起作用，必须针对Proxy实例进行操作，而不是针对目标对象(上例是空对象)进行操作
			  如果handler没有设置任何拦截，那就等同于直接通向原对象
			  var target={};
			  var handler={};
			  var proxy=new Proxy(target,handler);
			  proxy.a='b';
			  console.log(target.a);//'b'
			  //此时访问handler就等同于访问target
		  》一个技巧是将Proxy对象，设置到object.proxy属性，从而可以在object对象上调用
		      var object={proxy:new Proxy(target,handler)}
		  》Proxy实例也可以作为其他对象的原型对象
			var proxy=new Proxy({},{
				get:function(target,property){
					return 35;
				}	
			});
			let obj=Object.create(proxy);
			obj.time;//35
			//上面代码中，proxy对象是obj对象的原型，obj对象本身并没有time属性，所以根据原型链，会在proxy对象
			//上读取该属性，导致被拦截
		  》同一个拦截器，可以设置拦截多个操作
			var handler={
				get:function (target,property){
					if(property==='prototype'){
						return Object.prototype;
					}
					return "Hello,"+property;
				},
				apply:function(target,thisBinding,args){
					return args[0];
				},
				construct:function(target,args){
					return {value:args[1]};
				}
			}
			var fproxy=new Proxy(function(x,y){return x+y;},handler);
			fproxy(1,2);//1
			new fproxy(1,2);//{value:2}
			fproxy.prototype===Object.prototype;//true
			fproxy.foo;//'Hello,foo'
	》Proxy实例的方法
		》Proxy支持的拦截操作如下，对于可以设置，但是没有设置拦截的操作，则直接落在目标对象上，按照原先的方式产生结果
			》get(target,propKey[,receiver])--拦截对象属性的读取，如：proxy.foo或proxy['foo'],最后一个参数receiver是
			  一个对象，可选的
				》get方法用于拦截某个属性的读取操作
					var person={
						name:"张三"
					}
					var proxy=new Proxy(person,{
						get:function(target,property){
							if(property in target){
								return target[property];
							}else{
								throw new ReferenceError("Property \""+property+"\" does not exist.");
							}
						}
					});
					proxy.name;//'张三'
					proxy.age;//抛出错误--如果没有这个拦截函数，访问不存在的属性只会返回undefined
				》get方法可以继承
					let proto=new Proxy({},{
						get(target,propertyKey,receiver){
							console.log("GET"+prototypeKey);
							return target[propertyKey];
						}
					});
					let obj=Object.create(proto);
					obj.xxx//"GET xxx"
				》实现数组读取负数的索引
					function createArray(...element){
						//创建数组
						let target=[];
						target.push(...element);
						//实现负数的索引
						return new Proxy(target,{
							get(target,propKey,receiver){
								if(Number(propKey)<0){
									propKey=String(target.length+index);
								}
								return Reflect.get(target,propKey,receiver);
							}
						});
					}
					let arr=createArray('a','b','c');
					arr[-1]//c
				》利用Proxy，可以将读取属性的操作get，转变为执行某个函数，从而实现属性的链式操作
					var pipe=(function(value){
						return function (value){
						    var funcStack=[];
						    var oproxy=new Proxy({},{
							get:function(pipeObject,fnName){
							    if(fnName==='get'){
								return funcStack.reduce(function(val,fn){
								    return eval(fn+"("+val+")");
								},value)
							    }
							    funcStack.push(fnName);
							    return oproxy;
							}
						    });
						    return oproxy;
						}
					  }());
					  var double=n=>n*2;//6
					  var pow =n=>n*n;//36
					  var reverseInt=n=>n.toString().split("").reverse("").join("")|0;//63
					  pipe(3).double.pow.reverseInt.get;//63
				》利用get拦截，实现一个生成各种DOM节点的通用函数
					const dom=new Proxy({},{
						get(target,property){
							return function(attrs={},...children){
								const el=document.createElement(property);
								for(let prop of Object.keys(attrs)){
									el.setAttribute(prop,attrs[prop]);
								}
								for(let child of children){
									if(typeof child==='string'){
										child=document.createTextNode(child);
									}
									el.appendChild(child);
								}
								return el;
							}
						};
					});
					const el=dom.div({},'Helo,my name is ',dom.a({href:"/example.com"},'Mark'),'.I like',
						dom.ul({},dom.li({},'The web'),dom.li({},'Food'))
					);
			》set(target,propKey,value,receiver)--拦截对象属性的设置，如proxy.foo=v或proxy['foo']=v,返回一个布尔值
				》set方法用来拦截某个属性的赋值操作
					如:假定Person对象有一个age属性,该属性应该是不大于200的整数,那么可以使用Proxy保证age的属性值符合要求
					let validator={
						set:function(obj,propKey,value){
							if(propKey==='age'){
								if(!Number.isInteger(value)){
									throw new TypeError("The age is not an integer");
								}
								if(value>200){
									throw new RangeError("The age seems invalid");
								}
							}
							//对于age以为的属性，直接保存
							obj[propKey]=value;
						}
					}
					let person=new Proxy({},validator);
					person.age=100;
					person.age='young';//报错
					person.age=300;//报错
			》has(target,propKey)--拦截propKey in proxy的操作，以及对象的hasOwnProperty方法，返回一个布尔值
				》has方法用来拦截HasProperty操作，即判断对象是否具有某个属性时，这个方法会生效，典型的操作就是in运算符
					》如：使用has方法隐藏某些属性，不被in运算符发现
						var handler={
							has (target,key){
								//如果原对象的属性名第一个字符是下划线，proxy.has就会返回false
								//从而不会被in运算符发现
								if(key[0] ==="_"){
									return false;
								}
								return key in target;
							}
						}
						var targe={_prop:"foo",prop:"foo"};
						var proxy=new Proxy(target,handler);
						'_prop' in proxy//false
						注意：
							》如果原对象不可配置或者禁止扩展，这时has拦截就会报错
							》has方法拦截的是HasProperty操作，而不是HasOwnProperty操作，即has
							   方法不判断一个属性是对象自身的属性还是继承的属性
							》虽然for...in循环也用到了in运算符，但是has拦截对for...in循环不生效
			》deleteProperty(target,propKey)--拦截delete proxy[propKey]的操作，返回一个布尔值
					》deleteProperty方法用于拦截delete操作，如果这个方法抛出错误或返回false，当前属性就无法被delete命令删除
						var handler={
							deleteProperty(target,key){
								invariant(key,'delete');
								return true;
							}
						}
						function invariant(key,action){
							if(key[0]==='_'){
								throw new Error(`Invalid attempt to ${action} private "${key}" property`);
							}
						}
						var target={_prop:"foo"}
						var proxy =new Proxy(target,handler);
						//delete操作
						delete proxy._prop;//Error
						//上述代码中，deleteProperty方法拦截了delete操作符，删除第一个字符为下划线的属性会报错
			》ownKeys(target)--拦截Object.getOwnPropertyNames(proxy)、Object.getOwnPropertySymbols(proxy)、Object.keys(proxy)
			                   返回一个数组。该方法返回对象所有自身的属性，而Object.keys()仅返回对象可遍历的属性。
					let target={};
					let handler={
						ownKeys(target){
							return ['hello','world'];
						}
					}
					let proxy=new Proxy(target,handler);
					Object.keys(proxy);//['hello','world']
					//拦截第一个字符为下划线的属性名
					let target={
						_bar:"foo",
						_prop:"bar",
						prop:"baz"
					}
					let handler={
						ownKeys(target){
							return Reflect.ownKeys(target).filter(key=>key[0]!=='_');
						}
					}
					let proxy=new Proxy(target,handler);
					for(let key of Object.keys(proxy)){
						console.log(target[key]);//"baz"
					}
			》getOwnPropertyDescriptor(target,propKey)--拦截Object.getOwnPropertyDescriptor(proxy,propKey),返回属性的描述对象
					var handler={
						getOwnPropertyDescriptor(target,key){
							if(key[0]==='_'){
								return;
							}
							return Object.getOwnProertyDescripor(target,key);
						}
					}
					var target={_foo:"bar",baz:"tar"}
					var proxy=new Proxy(target,handler);
					Object.getOwnPropertyDescriptor(proxy, 'wat')// undefined
					Object.getOwnPropertyDescriptor(proxy, '_foo')// undefined
					Object.getOwnPropertyDescriptor(proxy, 'baz')// { value: 'tar', writable: true, enumerable: true, configurable: true }
					//上面代码中handler,getOwnPropertyDescriptor方法对于第一个字符为下划线的属性名会返回undefined
			》defineProperty(target,propKey,propDesc)--拦截Object.defineProperty(proxy,propKey,propDesc)、Object.defineProperties(proxy,propDescs)，返回一个布尔值
					var handler={
						defineProperty(target,key,descriptor){
							return false;
						}
					}
					var target={};
					var proxy=new Proxy(target,handler);
					proxy.foo='bar';//报错
					//若defineProperty方法返回false，导致添加新属性会抛出错误
			》preventExtensions(target)--拦截Object.preventExtensions(proxy),返回一个布尔值
				//这个方法有一个限制，只有当Object.isExtensible(proxy)为false(即不可扩展)时，
				//proxy.preventExtensions才能返回true，否则会报错
				如：
				var p=new Proxy({},{
					preventExtensions:function(target){
						return true;
					}
				});
				Object.preventExtensions(p);//报错
				上面代码中，proxy.preventExtensions方法返回true，但这时Object.isExtensible(proxy)会返回true，因此报错
				为了防止出现这个问题，通常要在proxy.preventExtensions方法里面，调用一次Object.preventExtensions
				如：
					var p=new Proxy({},{
						preventExtensions:function(target){
							console.log("called");
							Object.preventExtensions(target);
							return true;
						}
					});
					Object.preventExtensions(p);//'called' true
			》getPrototypeOf(target)--拦截Object.getPrototypeOf(proxy),返回一个对象
					getPrototypeOf方法主要用来拦截Object.getPrototypeOf()运算符以及其他一些操作
					》Object.prototype.__proto__
					》Object.prototype.isPrototypeOf()
					》Object.getPrototypeOf()
					》Reflect.getPrototypeOf()
					》instanceof运算符
					var proto={};
					var p=new Proxy({},{
						getPrototypeOf(target){
							return proto;
						}
					});
					Object.getPrototypeOf(p)===proto;//true
					上面代码中，getPrototypeOf方法拦截Object.getPrototypeOf(),返回proto对象
			》isExtensible(target)--拦截Object.isExtensible(proxy),返回一个布尔值
					var p=new Proxy({},{
						isExtensible:function(target){
							console.log("called");
							return true;
						}
					});
					Object.isExtensible(p);
					//"called"
					//true
					注意：该方法有一个强限制，如果不能满足下面的条件就会抛出错误
					Object.isExtensible(proxy)===Object.isExtensible(target);
					如：
						var p=new Proxy({},{
							isExtensible:function(target){
								return false;
							}
						});
						Object.isExtensible(p);//报错
			》setPrototypeOf(target,proto)--拦截Object.setPrototypeOf(proxy,proto),返回一个布尔值
					var handler={
						setPrototypeOf(target,proto){
							throw new　Error("Changing this prototype is forbidden");
						}
					}
					var proto={};
					var target=function (){}
					var proxy=new Proxy(target,handler);
					proxy.setPrototypeOf(proxy,proto);//报错--只要修改target的原型就会报错
			//如果目标对象是函数，那么还有两种额外操作可以拦截
				》apply(target,object,args)--拦截Proxy实例作为函数调用的操作，
							     如：proxy(...args)、proxy.call(object,...args)、proxy.apply(...)
						》apply方法拦截函数的调用、call和apply操作
							var handler={
								apply(target,ctx,args){
									return Reflect.apply(...arguments);
								}
							}
							//apply方法可以接受三个参数，分别是目标对象、目标对象的上下文对象(this)和目标
							//对象的参数数组
							var twice={
								apply(target,ctx,args){
									return Reflect.apply(...arguments)*2;
								}
							}
							function sum(left,right){
								return left+right;
							}
							var proxy=new Proxy(sum,twice);
							proxy(1,2);//6
							proxy.call(null,5,6);//22
							proxy.apply(null,[7,8]);//30
							Reflect.apply(proxy,null,[9,10])//38
							上述代码中，每当proxy函数执行时，就会被apply方法拦截
				》construct(target,args)--拦截Proxy实例作为构造函数调用的操作 如：new proxy(...args);
						》construct方法用于拦截new命令
							var handler={
								construct(target,args,newTarget){
									return new target(...args);
								}
							}
							construct方法可以接受两个参数：
								》target：目标参数
								》args:构建函数的参数对象
							var p=new Proxy(function(){console.log("这是目标函数")},{
								construct:function(target,args){
									console.log(target);
									return {value:args[0]*10};
								}
							});
							new p(1).value;//10
							注意：construct方法返回的必须是一个对象，否则会报错
	》Proxy.revocable();//返回一个可取消的Proxy实例
		let target={};
		let handler={};
		let {proxy,revoke}=Proxy.revocable(target,handler);
		proxy.foo=123;//proxy.foo--123
		revoke();
		proxy.foo;//TypeError:Revoked
		//Proxy.revocable方法返回一个对象，该对象的proxy属性是Proxy实例，revoke属性是一个函数，可以取消Proxy实例。
		//上面代码中，当执行revoke函数之后，在访问Proxy实例，就会抛出一个错误
	》this问题
		虽然Proxy可以代理针对目标对象的访问，但它不是目标对象的透明代理，即不做任何拦截的情况下，也无法保证与目标对象
		的行为一致。主要原因就是在Proxy代理的情况下，目标对象内部的this关键字会指向Proxy代理
		const target={
			m:function(){
				console.log(this===proxy);
			}
		}
		const proxy=new Proxy(target,{});
		target.m();//false
		proxy.m();//true
		//上述代码中，一旦proxy代理target以后，target内部的this就指向proxy，而不是target本身了
		》由于this指向的变化，导致Proxy无法代理目标对象
			const _name=new WeakMap();
			class Person{
				constructor(name){
					_name.set(this,name);
				}
				get name(){
					return _name.get(this);
				}
			}
			var jane=new Person("Jane");
			jane.name;//"Jane"
			new Proxy(jane,{}).name;//undefined
		》有些原生对象的内部属性，只有通过正确的this才能拿到，所以Proxy也无法代理这些原生对象的属性
			如：
			const target=new Date();
			const proxy=new Proxy(target,{});
			proxy.getDate();//TypeError
			//getDate方法只能在Date对象实例上面拿到，如果this不是Date对象实例就会报错。这是this绑定原始对象就可以解决这个问题
				const  target=new Date("2015-01-01");
				const proxy=new Proxy(target,{
					get(target,prop){
						if(prop==='getDate'){
							return target.getDate.bind(target);
						}
						return Reflect.get(target,prop);
					}
				});
				proxy.getDate();//1
	》Reflect概述
			Reflect对象与Proxy对象一样，也是ES6为了操作对象而提供的新的API。
			Reflect对象的设计目的：
				》将Object对象的一些明显属于语言内部的方法(如：Object.defineProperty),放到Reflect对象上。
				  现阶段，某些方法同时在Object和Reflect对象上部署，未来的新方法将只部署在Reflect对象上，也就是
				  说，从Reflect对象上可以拿到语言内部的方法
				》修改某些Object方法的返回结果，让其变得更合理。比如，Object.defineProperty(obj,name,desc)在无法定义属性时，会
				  抛出一个错误，而Reflect.defineProperty(obj,name,desc)则会返回false
				  //老写法
					  try{
						Object.defineProperty(target,property,attributes);
						//成功
					  }catch(e){
						//失败
					  }
				  //新写法
					if(Reflect.defineProperty(target,property,attributes)){
						//成功
					}else{
						//失败
					}
				 》让Object操作都变成函数行为，某些Object操作是命令，如：name in obj和delete obj[name]
				   而Reflect.has(obj,name)和Reflect.deleteProperty(obj,name)让它们变成了函数行为
				   //老写法
				   'assign' in Object;//true
				   //新写法
				   Reflect.has(Object,'assign');//true
				 》Reflect对象的方法与Proxy对象的方法一一对应，只要Proxy对象的方法，就能在Reflect对象上找到对应的方法
				   这就让Proxy对象可以方便的调用对应的Reflect方法，完成默认行为，作为修改行为的基础。也就是说，不管Proxy
				   怎么修改默认行为，你总可以在Reflect上获取默认行为
				    如：
					Proxy(target,{
						set:function(target,name,value,receiver){
							var success=Reflect.set(target,name,value,receiver);
							if(success){
								log('property'+name+'on'+target+'set to'+value)
							}
							return success;
						}
					});
					//上面代码中，Proxy方法拦截target对象的属性赋值行为，它采用Reflect.set方法将值赋值给对象的属性，确保
					//完成原有的行为，然后在部署额外的功能
					var loggedObj=new Proxy(obj,{
						get(target,name){
							console.log("get",target,name);
							return Reflect.get(target,name);
						},
						deleteProperty(){
							console.log("delete"+name);
							return Reflect.deleteProperty(target,name);
						},
						has(target,name){
							console.log("has"+name);
							return Reflect.has(target,name);
						}
					});
					//上面代码中，每一个Proxy对象的拦截操作(get、delete、has)，内部都调用对应的Reflect方法，保证原生行为
					//能够正常执行。添加的工作，就是将每一个操作输出一行日志
				》有了Reflect对象以后，很多操作会更易读
					//老写法
					Function.prototype.apply.call(Math.floor,undefined,[1.75]);//1
					//新写法
					Reflect.apply(Math.floor,undefined,[1.75]);//1
	》Reflect对象的方法--下面这些方法，大部分与Object对象的同名方法的作用都是相同的，而且它与Proxy对象的方法是一一对应的
			》Reflect.apply(target,thisArg,args);
				》该方法等同于Function.prototype.apply.call(func,thisArg,args),用于绑定this对象后执行给定函数
				  一般来说，如果要绑定一个函数的this对象，可以这样写fn.apply(obj,args),但是如果函数定义了自己的apply
				  方法，就只能写成Function.prototype.apply.call(fn,obj,args),采用Reflect对象可以简化这种操作
				  const ages=[11,33,12,54,18,96];
				  //旧写法
				  const youngest=Math.min.apply(Math,ages);
				  const oldest=Math.max.apply(Math,ages);
				  const type=Object.prototype.toString.call(youngest);
				  //新写法
				  const youngest=Reflect.apply(Math.min,Math,ages);
				  const oldest=Reflect.apply(Math.max,max,ages);
				  const type=Reflect.apply(Object.prototype.toString,youngest);
			》Reflect.construct(target,args);//args是一个数组或者类数组
				》等同于new target(...args),这提供了一种不使用new，来调用构造函数的方法
					function Greeting(name){
						this.name=name;
					}
					//new的写法
					const instance=new Greeting("张三");
					//Reflect.construct的写法
					const instance=Reflect.construct(Greeting,['张三']);
			》Reflect.get(target,name,receiver);
				》查找并返回target对象的name属性，如果没有该属性，则返回undefined
				》例：
					var myObject={
						foo:1,
						bar:2,
						get baz(){
							return this.foo+this.bar;
						}
					}
					Reflect.get(myObject,'foo');//1
					Reflect.get(myObject,'baz');//3
					》如果name属性部署了读取函数(getter),则读取函数的this绑定receiver
						var myReceiverObject={
							foo:4,
							bar:4
						}
						Reflect.get(myObject,'baz',myReceiverObject);//8
					》注意：如果第一个参数不是对象，Reflect.get方法会报错
						Reflect.get(1,'foo');//报错
			》Reflect.set(target,name,value,receiver);
				》设置target对象的name属性等于value
					var myObj={
						foo:1,
						set bar(value){
							return this.foo=value;
						}
					}
					Reflect.set(myObj,'foo',2);
					myObj.foo;//2
					Reflect.set(myObj,'bar',3);
					myObj.foo;//3
					//也可以定义新的属性，并设置其值
					Reflect.set(myObj,'a','新属性');
					myObj.a;//"新属性"
					》如果name属性设置了赋值函数，则赋值函数的this绑定receiver
						var myReceiverObj={foo:0}
						Reflect.set(myObj,'bar',5,myReceiverObj);
						myObj.foo;//3
						myReceiverObj.foo;//5
					》注意：如果第一个参数不是对象，Reflect.set会报错
						Reflect.set(1,'foo',{});//报错
			》Reflect.defineProperty(target,name,desc);
				》该方法基本等同于Object.defineProperty,用来为对象定义属性
					function MyDate(){}
					//旧写法
					Object.defineProperty(MyDate,'now',{
						value:()=>new Date.now();
					});
					//新写法
					Reflect.defineProperty(MyDate,'now',{
						value:()=>new Date.now();
					});
				》注意
					如果Reflect.defineProperty的第一个参数不是对象，就会抛出错误
			》Reflect.deleteProperty(target,name);
				》等同于delete obj[name],用于删除对象的属性
					const myObj={foo:"bar"}
					//旧写法
					delete myObj.foo;
					或
					delete myObj['foo'];
					//新写法
					Reflect.deleteProperty(myObj,'foo');
			》Reflect.has(target,name);
				》对应name in obj里面的in运算符
					var myObj={
						foo:1
					}
					//旧写法
					"foo" in myObj;//true
					//新写法
					Reflect.has(myObj,'foo');//true
				》注意第一个参数不是对象，Reflect.has和in运算符都会报错
			》Reflect.ownKeys(target);
				》该方法用于返回对象的所有属性，基本等同于Object.getOwnPropertyNames与Object.getOwnPropertySymbols之和
					var myObj={
						foo:1,
						bar:2,
						[Symbol.for('baz')]:3,
						[Symbol.for('bing')]:4
					}
					// 旧写法
					Object.getOwnPropertyNames(myObject)// ['foo', 'bar']
					Object.getOwnPropertySymbols(myObject)//[Symbol.for('baz'), Symbol.for('bing')]
					// 新写法
					Reflect.ownKeys(myObject)// ['foo', 'bar', Symbol.for('baz'), Symbol.for('bing')]
			》Reflect.isExtensible(target);
				》该方法对应Object.isExtensible，返回一个布尔值，表示当前对象是否可扩展
					const myObj={};
					//旧写法
					Object.isExtensible(myObj);//true
					//新写法
					Reflect.isExtensible(myObj);//true
				》注意
					如果参数不是对象，Object.isExtensible会返回false，因为非对象本来就是不可扩展的
					而Reflect.isExtensible会报错
					Object.isExtensible(1);//false
					Reflect.isExtensible(1);//报错
			》Reflect.preventExtensions(target);
				》该方法对应Object.preventExtensions方法，用于让一个对象变为不可扩展的，它返回一个布尔值，表示是否操作成功
					var myObj={};
					//旧写法
					Object.preventExtensions(myObj);//true
					//新写法
					Reflect.preventExtensions(myObj);//true
				》注意
					如果参数不是对象，Object.preventExtensions在ES5环境报错，在ES6环境返回这个参数，
					而Reflect.preventExtensions会报错
					//ES5
					Object.preventExtensions(1);//报错
					//ES6
					Object.preventExtensions(1);//1
					//新写法
					Reflect.preventExtensions(1);//报错
			》Reflect.getOwnPropertyDescriptor(target,name);
				》该方法基本等同于Object.getOwnPropertyDescriptor用于得到指定属性的描述对象
					var myObj={};
					Object.defineProperty(myObj,'hidden',{
						value:true,
						enumerable:false
					});
					//旧写法
					var theDescriptor=Object.getOwnPropertyDescriptor(myObj,'hidden');
					//新写法
					var theDescriptor=Reflect.getOwnPropertyDescriptor(myObj,'hidden');
				》注意
					Reflect.getOwnPropertyDescriptor和Object.getOwnPropertyDescriptor的一个区别是，
					如果第一个参数不是对象，Object.getOwnPropertyDescriptor(1,'foo')不会报错，返回
					undefined，而Reflect.getOwnPropertyDescriptor(1,'foo')会抛出错误，表示参数非法
			》Reflect.getPrototypeOf(target);
				》用于读取对象的__proto__属性，对应Object.getPrototypeOf(obj);
					const myObj=new FancyThing();
					//旧写法
					Object.getPrototypeOf(myObj)===FancyThing.prototype;
					//新写法
					Reflect.getPrototypeOf(myObj)===FancyThing.prototype;
				》注意：
				      Reflect.getPrototypeOf和Object.getPrototypeOf的一个区别是，如果第一个参数不是对象(包括null和undefined)
				      Object.getPrototypeOf会将这个参数转为对象，然后在运行，而Reflect.getPrototypeOf会报错
				      如：
				         Object.getPrototypeOf(1);//undefined
					 Reflect.getPrototypeOf(1);//报错
			》Reflect.setPrototypeOf(target,prototype);
				》用于设置对象的__proto__属性，对应Object.setPrototypeOf(obj,newProto);
					const myObj=new FancyThing();
					//旧写法
					Object.setPrototypeOf(myObj,OtherThing.prototype);
					//新写法
					Reflect.setPrototypeOf(myObj,OtherThing.prototype);
				》注意
					如果第一个参数不是对象，Reflect.setPrototypeOf和Object.setPrototypeOf都会报错
					Object.setPrototypeOf(1);//报错
					Reflect.setPrototypeOf(1);//报错
	》实例：使用Proxy实现观察者模式
		观察者模式(Observer mode)指的是函数自动观察数据对象，一旦对象有变化，函数就会自动执行
			//数据对象person--观察目标
			const person=observale({
				name:"张三",
				age:20
			});
			//函数print--观察者
			function print(){
				console.log(`${person.name},${person.age}`);
			}
			observe(print);
			//一旦数据对象发生变化，print就会自动执行
			person.name='李四';
			//输出--李四,20
		》使用Proxy写一个观察者模式的最简单实现，即实现observale和observe这两个函数
			思路：observable函数返回一个原始对象的Proxy代理，拦截赋值操作，触发充当观察者的各个函数
			//把所有观察者添加到set中便于统一执行
			const queuedObservers=new Set();
			const observe=fn=>queuedObservers.add(fn);
			//拦截赋值操作
			const observale=obj=>new Proxy(obj,{set});
			function set(target,key,value,receiver){
				//赋值
				const result=Reflect.set(target,key,value,receiver);
				//执行所有观察者
				queuedObservers.forEach(observer=>observer());
				return result;
			}
24.Iterator和for...of循环
	》Iterator遍历器的概念
		js原有的表示"集合"的数据结构，主要是数组Array与对象Object，ES6又添加了Map与Set。
	     这样就有了四种数据集合，并且还可以组合使用它们，定义自己的数据结构。这样就需要一种
	     统一的接口机制，来处理所有不同的数据结构。
	     遍历器Iterator--就是这样一种机制，它是一种接口，为各种不同的数据结构提供统一的访问机制。
			     任何数据结构只要部署Iterator接口就可以完成遍历操作(即依次处理该数据结构的所有成员)
	      Iterator的作用：
			》为各种数据结构提供一个统一的、简便的访问接口
			》使得数据结构的成员能够按某种次序排列
			》ES6创造了一种新的遍历命令for...of循环，Iterator接口主要供for...of消费
	      Iterator的遍历过程：
			》创建一个指针对象，指向当前数据结构的起始位置，也就是说，遍历器对象本质上，就是一个指针对象
			》第一次调用指针对象的next方法，可以将指针指向数据结构的第一个成员
			》第二次调用指针对象的next方法，指针就指向数据结构的第二个成员
			》不断调用指针对象的next方法，直到它指向数据结构的结束位置
			每次调用next方法，都会返回数据结构的当前成员的信息，具体来说，就是返回一个包含value和done属性的对象。
			其中value属性是当前成员的值，done属性是一个布尔值，表示是否结束。
			如：//模拟next方法返回值的示例
				//遍历器生成函数--返回一个遍历器对象
				function makeIterator(array){
					var nextIndex=0;
					return{
						next:function(){
							return nextIndex<array.length?{value:array[nextIndex++],done:false}:{value:undefined,done:true};
						}
					}
				}
				var it=makeIterator(['a','b']);
				//指针对象的next方法，用来移动指针并返回一个对象表示当前数据成员的信息
				it.next();//{value:"a",done:false}
				it.next();//{value:"b",done:false}
				it.next();//{value:undefined,done:true}
				》对于遍历器对象来说，done:false和value:undefined属性都是可以省略的，因此上面的makeIterator函数可以简写如下
					function makeIterator(array){
						var nextIndex=0;
						return{
							next:function(){
								return nextIndex<array.length?{value:array[nextIndex++]}:{done:true};
							}
						}
					}
				》由于Iterator只是把接口规格加到数据结构之上，所以遍历器与它所遍历的那个数据结构，实际上是分开的，完全可以
				  写出没有对应数据结构的遍历器对象，或者说用遍历器对象模拟出数据结构
					如：//无限运行的遍历器对象示例
					//该遍历器对象自己描述了一个数据结构出来
					function idMaker(){
						var index=0;
						return{
							next:function(){
								return {value:index++,done:false};
							}
						}
					}
					var it=idMaker();
					it.next().value;//0
					it.next().value;//1
					it.next().value;//2
					....
				》在ES6中，有些数据结构原生具备Iterator接口(如数组),即不用任何处理，就可以被for...of循环遍历
				  有些就不行(如对象)。原因在于这些数据结构原生部署了Symbol.iterator属性，另外一下数据结构没有。
				  凡是部署了Symbol.iterator属性的数据结构，就称为部署了遍历器接口，调用这个接口，就会返回一个遍历器对象
				》如果使用TypeScript写法，遍历器接口(Iterable)、指针对象(Iterator)和next方法返回值的规格可以描述如下
					interface Iterable{
						[Symbol.iterator]():Iterator,
					}
					interface Iterator{
						next(value?:any):IterationResult,
					}
					interface IterationResult{
						value:any,
						done:boolean,
					}
	》数据结构的默认Iterator接口
		Iterator接口的目的就是为所有数据结构，提供了一种统一的访问机制，即for...of循环。
		当使用for..of循环遍历某种数据结构时，该循环会自动去寻找Iterator接口
		一种数据结构只要部署了Iterator接口，我们就称这种数据结构是"可遍历的"(iterable)
		ES6规定，默认的Iterator接口部署在数据结构的Symbol.iterator属性，或者说，一个数据结构只要具有
		Symbol.iterator属性，就可以认为是"可遍历的"(iterable)。
		Symbol.iterator属性本身是一个函数，就是当前数据结构默认的遍历器生成函数。执行这个函数，就会返回一个遍历器。
		至于属性名Symbol.iterator，它是一个表达式，返回Symbol对象的Iterator属性，这是一个预定义好的、类型为Symbol的特殊值，所以要放在方括号内
		const obj={
			[Symbol.iterator]:function(){
				return{
					next:function(){
						return{
							value:1,
							done:true
						}
					}
				}
			}
		}
		上面代码中，对象obj是可遍历的(iterable),因为具有Symbol.iterator属性，执行这个属性，会返回一个遍历器对象。该对象
		的根本特征就是具有next方法。每次调用next方法，都会返回一个代表当前成员的信息对象，具有value和done两个属性。
		ES6中，有三类数据结构原生具备Iterator接口：数组、某些类似数组的对象、Set和Map结构
			如：
			let arr=['a','b'];
			let it=arr[Symbol.iterator]();
			it.next();//{value:"a",done:false}
			it.next();//{value:"b",done:false}
			it.next();//{value:undefined,done:true}
			上面提到，原生就部署Iterator接口的数据结构有三类，对于这三类数据结构，不用自己写遍历器生成函数，for...of循环会自动遍历它们
			除此之外，其他数据结构(主要是对象)的Iterator接口，都需要自己在Symbol.iterator属性上面部署，这样才会被for...of循环遍历。
			》对象Object之所以没有默认部署Iterator接口，是因为对象的那个属性先遍历，那个属性后遍历是不确定的，需要开发者手动指定。本质
			  上，遍历器是一种线性处理，对于任何非线性的数据结构，部署遍历器接口，就等于部署一种线性转换。不过严格地说，对象部署遍历器
			  接口并不是很必要的，因为这时对象实际上被当作Map结构使用，ES5没有Map结构，而ES6原生提供了。
			  》一个对象如果要有可被for...of循环调用的Iterator接口，就必须在Symbol.iterator的属性上部署遍历器生成方法(原型链上的对象具有该方法也可以);
				//在类部署Iterator接口的写法
					class RangeIterator{
						constructor(start,stop){
							this.value=start;
							this.stop=stop;
						}
						[Symbol.iterator](){return this;}//返回当前对象的遍历器对象
						next(){
							var value=this.value;
							if(value<this.stop){
								this.value++;
								return {done:false,value:value}
							}else{
								return {done:true,value:undefined}
							}
						}
					}
					function range(start,stop){
						return new RangeIterator(start,stop);
					}
					for(var value of range(0,3)){
						console.log(value);
					}
				//通过遍历器实现指针结构的示例--在构造函数的原型链上部署Symbol.iterator方法
					function Obj(value){
						this.value=value;
						this.next=null;
					}
					Obj.prototype[Symbol.iterator]=function(){
						var iterator={
							next:next
						}
						var current=this;
						function next(){
							if(current){
								var value=current.value;
								current=current.next;
								return{
									done:false,
									value:value
								}
							}else{
								return{done:true}
							}
						}
						return iterator;
					}
					var one=new Obj(1);
					var two=new Obj(2);
					var three=new Obj(3);
					one.next=two;
					two.next=three;
					for(var i of one){
						console.log(i);//1 2 3
					}
				//为对象添加Iterator接口
					let obj={
						data:['hello','world'],
						[Symbol.iterator](){
							const self=this;
							let index=0;
							return {
								next(){
									if(index<self.data.length){
										return {
											value:self.data[index++],
											done:false
										}
									}else{
										return{value:undefined,done:true}
									}
								}
							}
						}
					}
				//对于类数组的对象(存在数值键名和length属性)，部署Iterator接口，有一个
				//简便的方法，就是Symbol.iterator方法直接引用数组的Iterator接口
					NodeList.prototype[Symbol.iterator]=Array.prototype[Symbol.iterator];
					或
					NodeList.prototype[Symbol.iterator]=[][Symbol.iterator];
					[...document.querySelectorAll("div")]//可以执行了
				//类数组对象调用数组的Symbol.iterator方法
					let iterable={
						0:"a",
						1:"b",
						2:"c",
						length:3,
						[Symbol.iterator]:Array.prototype[Symbol.iterator]
					}
					for(let item of iterable){
						console.log(item);//'a' 'b' 'c'
					}
					》注意：普通对象部署数组的Symbol.iterator方法是无效的
						let iterable={
							a:"a",
							b:'b',
							c:"c",
							length:3，
							[Symbol.iterator]:Array.prototype[Symbol.iterator]
						}
						for(let item of iterable){
							console.log(item);//undefined  undefined  undefined
						}
				//如果Symbol.iterator方法对应的**不是**遍历器生成函数(即会返回一个遍历器对象)，解析引擎将会报错
					var obj={};
					obj[Symbol.iterator]=()=>1;
					[...obj]//报错--Uncaught TypeError: 1 is not an iterator
				//有了遍历器接口，数据结构就可以用for...of循环遍历也可以使用while循环遍历
					//获取遍历器对象
					var $iterator=ITERABLE[Symbol.iterator]();
					//获取结果对象
					var $result=$iterator.next();
					//根据done属性来判断是否继续执行
					while(!$result.done){
						var x=$result.value;
						....
						$result=$iterator.next();
					}
	》调用Iterator接口的场合
		》有些场合会默认调用Iterator接口(即Symbol.iterator方法)，如下场合会调用Iterator接口
			》解构赋值--对数组和Set结构进行解构赋值时，会默认调用Symbol.iterator方法
				let set=new Set().add('a').add('b').add('c');
				let [x,y]=set;//x='a' y='b'
				let [first,...rest]=set;//first='a' rest=['b','c']
			》扩展运算符--扩展运算符(...)也会调用默认的Iterator接口
				var str = 'hello';
				[...str] //  ['h','e','l','l','o']
				let arr = ['b', 'c'];
				['a', ...arr, 'd']// ['a', 'b', 'c', 'd']
				》实际上，这提供了一种简便机制，可以将任何部署了Iterator接口的数据结构，转为数组。
				  也就是说，只要某个数据结构部署了Iterator接口就可以对它使用扩展运算符，将其转为数组
				  let arr=[...iterable];
			》yield*--yield*后面跟的是一个可遍历的结构，它会调用该结构的遍历器接口
				let generator=function* (){
					yield 1;
					yield* [2,3,4];
					yield 5;
				}
				var iterator=generator();
				iterator.next() // { value: 1, done: false }
				iterator.next() // { value: 2, done: false }
				iterator.next() // { value: 3, done: false }
				iterator.next() // { value: 4, done: false }
				iterator.next() // { value: 5, done: false }
				iterator.next() // { value: undefined, done: true }
			》其他场合
				由于数组的遍历会调用遍历器接口，所以任何接受数组作为参数的场合，其实都调用了遍历器接口
					》for...of
					》Array.from()
					》Map() Set() WeakMap() WeakSet()
					》Promise.all()
					》Promise.race()	
	》字符串的Iterator接口--字符串是一个类似数组的对象，也原生具有Iterator接口
		var someStr='hi';
		typeof someStr[Symbol.iterator];//'function'
		var iterator=someStr[Symbol.iterator]();
		iterator.next()  // { value: "h", done: false }
		iterator.next()  // { value: "i", done: false }
		iterator.next()  // { value: undefined, done: true }
		》覆盖原生的Symbol.iterator方法，达到修改遍历器行为的目的
			var str=new String("hi");
			[...str]//['h','i']
			str[Symbol.iterator]=function(){
				return {
					next:function(){
						if(this._first){
							this._first=false;
							return{value:"bye",done:false}
						}else{
							return {done:true}
						}
					},
					_first:true
				}
			}
			[...str] // ["bye"]
			str;//'hi'
	》Iterator接口与Generator函数--Symbol.iterator方法最简单的实现还是使用Generator函数
		var myIterable={};
		myIterable[Symbol.iterator]=function* (){
			yield 1;
			yield 2;
			yield 3;
		}
		[...myIterable]//[1,2,3]
		//或者采用下面的简洁写法
		let obj={
			* [Symbol.iterator](){
				yield 'hello';
				yield 'world';
			}
		}
		for(let x of obj){
			console.log(x);//hello world
		}
		上面代码中，Symbol.iterator方法几乎不用部署任何代码，只要用yield命令给出每一步的返回值即可
	》遍历器对象的return(),throw()
		遍历器对象除了具有next方法，还可以具有return方法和throw方法。如果你自己写遍历器对象生成函数，那么
	    next方法是必须部署的，return方法和throw方法是否部署是可选的。
	        return方法的使用场合是，如果for...of循环提前退出(通常是因为出错或者有break语句或continue语句)，就会调用
	    return方法。如果一个对象在完成遍历前，需要清理或释放资源就可以部署return方法。
		function readLinesSync(file){
			return{
				next(){
					if(file.isAtEndOfFile()){
						file.close();
						return {done:true}
					}
				},
				return(){
					file.close();
					return {done:true}
				}
			}
		}
		上面代码中，函数readLinesSync接受一个文件对象作为参数，返回一个遍历器对象，其中除了next方法，还部署了return方法。
		for(let line of readLinesSync(fileName)){
			console.log(line);
			break;
		}
		//注意：return方法必须返回一个对象，这是Generator规格决定的
		throw方法主要是配合Generator函数使用，一般的遍历器对象用不到这个方法。
	》for...of循环--作为遍历所有数据结构的统一的方法
		    一个数据结构只要部署了Symbol.iterator属性，就被视为具有Iterator接口，就可以用for...of循环遍历它的成员。
		也就是说，for...of循环内部调用的是数据结构的Symbol.iterator方法。
		    for...of循环可以使用的范围包括：数组、Set、Map、某些类数组的对象(如arguments对象、DOM NodeList对象)、Generator对象
		以及字符串。
		》数组
		    数组原生具备Iterator接口(即默认部署了Symbol.iterator属性)，for...of循环本质上就是调用这个接口产生的遍历器。
			const arr=['red','green','blue'];
			for(let v of arr){
				console.log(v);//red green blue
			}
			const obj={};
			obj[Symbol.iterator]=arr[Symbol.iterator].bind(arr);
			for(let v of obj){
				console.log(v);//red green blue
			}
		    》for...of循环可以代替数组实例的forEach方法
			const arr=['red','green','blue'];
			arr.forEach(function(elem,index){
				console.log(elem);//red green blue
				console.log(index);//0    1     2
			});
		    》js原有的for...in循环，只能获取对象的键名，不能获取键值。ES6的for...of循环允许遍历获取键值
			var arr=['a','b'];
			for(let a in arr){//读取键名
				console.log(a);//0 1
			}
			for(let a of arr){//读取键值
				console.log(a);//a b
			}
			》for...of循环调用的遍历器接口，数组的遍历器接口**只返回**具有数字索引的属性，这点和for...in循环也不一样
				let arr=[3,5]
				arr.foo='hello';
				for(let i in arr){
					console.log(i);//0 1 foo
				}
				for(let i of arr){
					console.log(i);//3 5
				}
		》Set和Map结构--原生具有Iterator接口，可以直接使用for...of循环
			var engines=new Set(['Gecko','Trident','Webkit']);
			for(var e of engines){
				console.log(e);//'Gecko','Trident','Webkit'
			}
			var map=new Map().set('a',1).set('b',2);
			for(let [key,value] of map){
				console.log(key+":"+value);
			}
		》计算生成的数据结构
			有些数据结构是在现有的数据结构的基础上，计算生成的。
			如：ES6的数组、Set、Map都部署了以下三个方法，调用后都返回遍历器对象。
			》entries()返回一个遍历器对象，用来遍历**[键名,键值]**组成的数组。对于数组，键名就是索引值;对于
			  Set，键名和键值相同。Map结构的Iterator接口，默认就是调用entries方法。
			》keys()返回一个遍历器对象，用来遍历所有的键名
			》values()返回一个遍历器对象，用来遍历所有的键值
			这三个方法调用后生成的遍历器对象，所遍历的都是计算生成的数据结构
			let arr=['a','b'];
			for(let pair of arr.entries()){
				console.log(pair);//[0,'a'] [1,'b']
			}
		》类数组的对象
			》字符串
				let str='hello';
				for(let s of str){
					console.log(s);//h  e  l  l  o
				}
				对于字符串来说，for...of循环还有一个特点，就是会正确识别32位UTF-16字符
					for (let x of 'a\uD83D\uDC0A') {
					  console.log(x);// 'a'  '\uD83D\uDC0A'
					}
			》DOM NodeList对象
				let paras=document.querySelectorAll("p");
				for(let p of paras){
					p.classList.add('test');
				}
			》arguments对象
				function printArgs(){
					for(let x of arguments){
						console.log(x);
					}
				}
				printArgs('a', 'b');// 'a' 'b'
			并不是所有类数组的对象都具有Iterator接口，一个简单的解决方法，就是使用Array.from方法将其转为数组
				let arrayLike={length:2,0:'a',1:'b'}
				for(let x of arrayLike){//报错
					console.log(x);
				}
				for(let x of Array.from(arrayLike)){//正确
					console.log(x);
				}
		》对象--对于普通的对象，for...of结构不能直接使用，会报错，必须部署了Iterator接口后才能使用，
		  但是这样的情况下，for...in循环依然可以用来遍历键名。
			var  es6={
				edition:6,
				committee:"TC39",
				standard:"ECMA-262"
			}
			for(let e in es6){
				console.log(e);//edition  committee  standard
			}
			for(let e of es6){//报错--没有部署Iterator接口
				console.log(e);
			}
			》解决方式
			        方式1：使用Object.keys方法将对象的键名生成一个数组，然后遍历这个数组
				for(var key of Object.keys(someObject)){
					console.log(key+":"+someObject[key]);
				}
				方式2：在对象上部署Iterator接口的代码
					》将数组的Symbol.iterator属性直接赋值给其他对象的Symbol.iterator属性
						如：想要让for...of遍历jQuery对象
						jQuery.prototype[Symbol.iterator]=Array.prototype[Symbol.iterator];
					》使用Generator函数将对象重新包装
						function* entries(obj){
							for(let key of Object.keys(obj)){
								yield [key,obj[key]];
							}
						}
						for(let [key,value] of entries(obj)){
							console.log(key+":"+value);
						}
		》与其他遍历语法的比较
			以数组为例：
				//方式1
				for(var index=0;index<arr.length;index++){
					...
				}
				//方式2
				arr.forEach(function(value){
					...
				});
				这种写法的问题在于，无法中途跳出forEach循环，break与return命令都不能有效
				//方式3
				for(var index in arr){
					...
				}
				for...in的缺点：
					》数组的键名是数字但是for...in循环是以字符串作为键名'0','1'...等
					》for...in循环不仅遍历数字键名，还会遍历手动添加的其他键，甚至包括原型链上的键
					》某些情况下，for...in循环会以任意顺序遍历键名
					总之：for...in循环主要是为了遍历对象而设计的，不适合用于遍历数组
				//方式4
				for(let value of arr){
					...
				}
				for...of优势：
					》有着同for...in一样的简洁语法，但是没有for...in那些缺点
					》不同于forEach方法，他可以与break、continue、return配合使用
					》提供了遍历所有数据结构的统一操作接口
25.Generator函数
	》简介
		Generator函数ES6提供的一种**异步编程**解决方案，语法行为与传统函数完全不同。
		Generator函数有多种理解角度。从语法上，首先可以把它理解成,Generator函数是一个状态机，封装了多个内部状态。
		    执行Generator函数会返回一个遍历器对象，也就是说Generator函数除了状态机，还是一个遍历器对象生成函数。
		返回的遍历器对象，可以依次遍历Generator函数内部的每一个状态。
		    形式上，Generator函数是一个普通函数，但是有两个特征。
		    一是，function关键字与函数名之间有一个星号(*)
		    二是，函数体内部使用yield(产出)语句，定义不同的内部状态
			    function * generator(){
				//三个状态
				yield 'hello';
				yield 'world';
				return 'end'
			    }
			    //Generator函数的调用方法和普通函数一样，也就是在函数名后面加上一对圆括号。
			    //不同的是，调用Generator函数后，该函数并不执行，返回的也不是函数的运行结果
			    //而是一个指向内部状态的指针对象即遍历器对象
			    var hw=generator();//得到遍历器对象
			    //必须调用遍历器对象的next方法，使得指针移向下一个状态。也就是说，每次调用next方法，内部指针就从函数头部或
			    //上一次停下来的地方开始执行，直到遇到下一个yield语句(或return语句)为止。换言之，Generator函数是分段执行的，
			    //yield语句是暂停执行的标记，而next方法可以恢复执行
			    console.log(result.next());//{value: "hello", done: false}
			    console.log(result.next());//{value: "world", done: false}
			    console.log(result.next());//{value: "end", done: true}
			    console.log(result.next());//{value: undefined, done: true}	  
			    》总结：调用Generator函数，返回一个遍历器对象，代表Generator函数的内部指针。以后，每次调用遍历器对象的next方法
				    就会返回一个有值value和done两个属性的对象，value属性表示当前的内部状态值，是yield语句后面那个表达式的值
				    done属性是一个布尔值，表示是否遍历结束。
				    ES6没有规定，function关键字与函数名之间的星号，写在那个位置，这导致下面的写法都能通过。
					function * foo(x,y){...}
					function *foo(x,y){...}
					function* foo(x,y){...}
					function*foo(x,y){...}
					由于Generator函数仍然是普通函数，所以一般的写法是上面的第三种，即星号紧跟在function关键字后面。
		》yield语句
			由于Generator函数返回的遍历器对象，只有调用next方法才会遍历下一个内部状态，所以其实提供了一种可以暂停执行的函数。
		    yield语句就是暂停标志。
		    》遍历器对象的next方法的运行逻辑
				》遇到yield语句，就暂停执行后面的操作，并将紧跟在yield后面的那个表达式的值，作为返回对象的value属性值
				》下一次调用next方法时，在继续往下执行，直到遇到下一个yield语句
				》如果没有再遇到新的yield语句，就一直运行到函数结束，直到return语句为止，并将return语句后面的表达式的值
				  作为返回的对象的value属性值
				》如果该函数没有return语句，则返回的对象的value属性为undefined
				注意：yield语句后面的表达式，只有当调用next方法、内部指针指向该语句时才会执行，因此等于为js提供了手动的"惰性求值"
				      的语法功能。
				      function* gen(){
					yield 123+456;//表达式123+456不会立即求值，只会在next方法将指针移到这一句时，才会求值
				      }
				yield语句与return语句既有相似之处，也有区别：
					》相似之处在于，都能返回紧跟在语句后面的那个表达式的值。
					》区别在于每次遇到yield，函数暂停执行，下一次再从该位置继续向后执行，而return语句不具备位置记忆的功能。
					  一个函数里面只能执行一次或者说一个return语句，但是可以执行多次(或者说多个)yield语句。
					  正常函数只能返回一个值，因为只能执行一次return，Generator函数可以返回一系列的值，因为可以有任意多个yield。
					  从另一个角度看，也可以说Generator生成了一系列的值，这也就是它的名称来历。
		》Generator函数可以不用yield语句，这时就变成了一个单纯的暂缓执行函数
			function* f(){
				console.log("执行了");
			}
			var generator=f();
			generator.next();//"执行了"
		》yield语句不能用在普通函数中，否则会报错
			(function(){//SyntaxError: Unexpected number
				yield 1;
			})();
		》案例
			//报错，因为forEach方法的参数是一个普通函数，但是在里面使用了yield语句
			var arr=[1,[[2,3],4],[5,6]];
			var flat=function* (a){
				a.forEach(function(item){
					if(typeof item !=='number'){
						yield* flat(item);
					}else{
						yield item;
					}
				});
			}
			for(var f of flat(arr)){
				console.log(f);
			}
			//修改
			var flat=function* (a){
				var length=a.length;
				for(var i=0;i<length;i++){
					var item=a[i];
					if(typeof item !=='number'){
						yield* flat(item);
					}else{
						yield item;
					}
				}
			}
			for(var f of flat(arr)){
				console.log(f);// 1, 2, 3, 4, 5, 6
			}
		》yield语句如果用在一个表达式中，必须放在圆括号里面
			//报错
			console.log('hello'+yield);
			console.log('hello'+yield 123);
			//ok
			console.log('hello'+(yield));
			console.log('hello'+(yield 123));
		》yield语句用作函数参数或赋值表达式的右边，可以不加括号
			foo(yield 'a',yield 'b');
			let input=yield;
		》与Iterator接口的关系
			    任意一个对象的Symbol.iterator方法，等于该对象的遍历器生成函数，调用该函数会返回该对象的一个遍历器对象。
			    由于Generator函数就是一个遍历器生成函数，因此可以把Generator赋值给对象的Symbol.iterator属性，从而使得
			该对象具有Iterator接口。
				var myIterable={};
				myIterable[Symbol.iterator]=function* (){
					yield 1;
					yield 2;
					yield 3;
				}
				[...myIterable];//[1,2,3]
			    Generator函数执行后，返回一个遍历器对象，该对象本身也具有Symbol.iterator属性，执行后返回自身。
				function* gen(){}
				var g=gen();
				g[Symbol.iterator]()===g;//true
	》next方法的参数
		yield句**本身没有**返回值，或者说总是返回undefined。next方法可以带一个参数，该参数就会被当做**上一个yield语句**的返回值
			function* f(){
				for(var i=0;true;i++){
					var reset=yield i;
					if(reset){
						i=-1;
					}
				}
			}
			var g=f();
			g.next();//{value:0;done:false}
			g.next();//{value:1,done:false}
			g.next(true);//{value:0,done:false}
			//上面代码先定义了一个可以无限运行的Generator函数f，如果next方法没有参数，每次运行到yield语句，变量reset的值总是undefined。
			//当next方法带一个参数true时，当前的变量reset就被重置为这个参数(即true)，因此i会等于-1，下一轮循环就会从-1开始递增。
			》这个功能有很重要的语法意义。Generator函数从暂停状态到恢复运行，它的上下文状态content是不变的。通过next方法参数，就有办法
			  在Generator函数开始运行之后，继续向函数体内部注入值。也就是说可以在Generator函数运行的不同阶段，从外部向内部注入不同的值
			  从而调整函数行为。
				function* foo(x){
					var y=2*(yield (x+1));
					var z=yield(y/3);
					return (x+y+z);
				}
				var a=foo(5);
				a.next();//{value:6,done:false}
				a.next();//{value:NaN,done:false}
				a.next();//{value:NaN,done:true}
				var b=foo(5);
				b.next();//{value:6,done:false}
				b.next(12);//{value:8,done:false}
				b.next(13);//{value:42,done:true}
				》注意：由于next方法的参数表示上一个yield语句的返回值，所以第一次使用next方法时，不能带有参数。V8引擎直接忽略第一次使用
				  next方法时的参数，只有从第二次使用next方法开始，参数才是有效的。从语义上讲，第一个next方法用来启动遍历器对象，所以不用
				  带有参数。
				》如果想要第一次调用next方法时，就能够输入值，可以在Generator函数外面再包一层
					function wrapper(generatorFunction){
						return function(...args){
							let generatorObject=generatorFunction(...args);
							generatorObject.next();
							return generatorObject;
						}
					}
					const wrapped=wrapper(function* (){
						console.log(`First input:${yield}`);
						return 'DONE';
					});
					wrapped().next('hello!')// First input: hello!
				》通过next方法的参数，向Generator函数内部输入值
					function* dataConsumer(){
						console.log(`started`);
						console.log(`1.${yield}`);
						console.log(`2.${yield}`);
						return `result`;
					}
					let genObj = dataConsumer();
					genObj.next();// Started
					genObj.next('a')// 1. a
					genObj.next('b')// 2. b
	》for...of循环--可以自动遍历Generator函数时生成的Iterator对象，且此时不再需要调用next方法
		function* foo(){
			yield 1;
			yield 2;
			yield 3;
			return 6;
		}
		for(let v of foo()){
			console.log(v);//1 2 3
		}
		上面代码使用for...of循环，显示了yield语句的值，需要注意的是一旦next方法返回的对象的done属性为true时，for...of
		循环就会中止，且不包含该返回对象，所以上面return语句返回的6**不包括**在for...of循环之中。
		》利用for...of循环，可以写出遍历任意对象的方法。原生的js对象没有遍历接口，无法使用for...of循环，通过Generator函数
		  为它加上这个接口，就可以用了
			function* objectEntries(obj){
				let propKeys=Reflect.ownKeys(obj);
				for(let propKey of propKeys){
					yield [propKey,obj[propKey]];
				}
			}
			let jane={first:"Jane",last:"Doe"};
			//方式1--objectEntries(jane)
			for(let [key,value] of objectEntries(jane)){
				console.log(`${key}:${value}`);//first:"Jane" last:"Doe"
			}
			//方式2--将Generator函数加到对象Symbol.iterator属性上面
			function* objectEntries(){
				let propKeys=Object.keys(this);
				for(let propKey of propKeys){
					yield [propKey,this[propKey]];
				}
			}
			let jane={first:"Jane",last:"Doe"};
			jane[Symbol.iterator]=objectEntries;
			for(let [key,value] of jane){
				console.log(`${key}:${value}`);//first:"Jane" last:"Doe"
			}
		》除了for...of循环以外，扩展运算符(...)、解构赋值和Array.from方法内部调用的都是遍历器接口。这意味着
		  它们都可以将Generator函数返回的Iterator对象，作为参数
			function* numbers () {
			  yield 1
			  yield 2
			  return 3
			  yield 4
			}
			// 扩展运算符
			[...numbers()] // [1, 2]
			// Array.from 方法
			Array.from(numbers()) // [1, 2]
			// 解构赋值
			let [x, y] = numbers();
				x // 1
				y // 2
			// for...of 循环
			for (let n of numbers()) {
			  console.log(n);// 1 2
			}
	》Generator.prototype.throw()--Generator函数返回的遍历器对象，都有一个throw方法，可以在函数体外抛出错误，然后在Generator函数体内捕获。
		var g=function* (){
			try{
				yield;
			}catch(e){
				console.log('内部捕获',e);
			}
		}
		var i=g();
		i.next();
		try{
			i.throw('a');
			i.throw('b');
		}catch(e){
			console.log('外部捕获',e);
		}
		//内部获取 a
		//外部捕获 b
		上面代码中，遍历器对象i连续抛出两个错误。第一个错误被Generator函数体内的catch语句捕获。
		i第二次抛出的错误，由于Generator函数内部catch语句已经执行过了，不会在捕获都这个错误了，
		所以这个错误被抛出了Generator函数体，被函数体外的catch语句捕获。
		》throw方法可以接受一个参数，该参数会被catch语句接收，建议抛出Error对象的实例
			var g=function* (){
				try{
					yield;
				}catch(e){
					console.log(e);
				}
			}
			var i=g();
			i.next();
			i.throw(new Error("出错了！"));//Error:出错了!
			注意：不要混淆遍历器对象的throw方法和全局的throw命令。上面代码的错误，使用遍历器对象的throw方法抛出，
			      而不是用throw命令抛出。后者只能被函数体外的catch语句捕获
					var g=function* (){
						while(true){
							try{
								yield;
							}catch(e){
								if(e != 'a') throw e;
								console.log('内部捕获',e);
							}
						}
					}
					var i=g();
					i.next();
					try{
						throw new Error('a');
						throw new Error('b');
					}catch(e){
						console.log('外部捕获',e);
					}
					//外部捕获 [Error:a]
					上面代码之所以只捕获了a，是因为函数体外的catch语句块，捕获了抛出的a错误以后，就不会再继续try代码块剩余的语句了。
		》如果Generator函数内部没有部署try...catch代码块，那么throw方法抛出的错误，将被外部try...catch代码捕获
			var g=function* (){
				while(true){
					yield;
					console.log("内部捕获",e);
				}
			}
			var i =g();
			i.next();
			try{
				i.throw('a');
				i.throw('b');
			}catch(e){
				console.log('外部捕获',e);
			}
			//外部捕获 a
		》如果Generator函数内部和外部，都没有部署try...catch代码块，那么程序将报错，直接中断执行
			var gen=function* gen(){
				yield console.log("hello");
				yield console.log('world');
			}
			var g=gen();
			g.next();//hello
			g.throw();//Uncaught undefined
		》throw方法被捕获以后，会附带执行**下一条yield语句**。也就是说，会附带执行一次next方法
			var gen=function* gen(){
				try{
					yield console.log('a');
				}catch(e){}
				yield console.log('b');
				yield console.log('c');
			}
			var g=gen();
			g.next();//a
			g.throw();//b
			g.next();//c
			注意：只要Generator函数内部部署了try...catch代码块，那么遍历器的throw方法抛出错误，**不影响**下一次遍历
		》throw命令与g.throw方法是无关的，两者互不影响
			var gen=function* gen(){
				yield console.log('hello');
				yield console.log('world');
			}
			var g=gen();
			g.next();//hello
			try{
				throw new Error();
			}catch(e){
				g.next();//world
			}
		》Generator函数体外抛出的错误，可以在函数体内捕获，反过来Generator函数体内抛出的错误，也可以被函数体外的catch捕获。
			function* foo(){
				var x=yield 3;
				var y=x.toUpperCase();//报错
				yield y;
			}
			var it=foo();
			it.next();//{value:3,done:false}
			try{
				it.next(42);
			}catch(err){
				console.log(err);
			}
		》一旦Generator执行过程中抛出错误，且没有被内部捕获，就不会再执行下去了。如果此后还调用next方法，
		  将返回一个value属性等于undefined，done属性等于true的对象，即js引擎认为这个Generator已经运行结束了。
			function* g(){
				yield 1;
				console.log(`throwing an exception`);
				throw new Error(`generator broke`);
				yield 2;
				yield 3;
			}
			function log(generator){
				var v;
				console.log(`starting generator`);
				try{
					v=generator.next();
					console.log("第一次运行next方法",v);
				}catch(err){console.log('捕捉错误',v);}
				try{
					v=generator.next();
					console.log("第二次运行next方法",v);
				}catch(err){console.log('捕捉错误',v);}
				try{
					v=generator.next();
					console.log("第三次运行next方法",v);
				}catch(err){console.log('捕捉错误',v);}
				console.log('caller done');
			}
			log(g());
			//starting generator
			//第一次运行next方法 Object {value: 1, done: false}
			//throwing an exception
			//捕捉错误 Object {value: 1, done: false}
			//第三次运行next方法 Object {value: undefined, done: true}
			//caller done
	》Generator.prototype.return()
		    Generator函数返回的遍历器对象，还有一个return方法，可以返回给定的值，并且终结遍历Generator函数。
				function* gen(){
					yield 1;
					yield 2;
					yield 3;
				}
				var g=gen();
				g.next();//{value:1,done:false}
				g.return('foo');//{value:'foo',done:true}--返回的值value属性是return方法的参数并且Generator函数的遍历终止了
				g.next();//{value:undefined,done:true}
				》如果return方法调用时，不提供参数，则返回值的value属性为undefined
					g.next();//{value:1,done:false}
					g.return();//{value:undefined,done:true}
					g.next();//{value:undefined,done:true}
			》如果Generator函数内部有try...finally代码块，那么return方法会推迟到finally代码块执行完在执行
				function* numbers(){
					yield 1;
					try{
						yield 2;
						yield 3;
					}finally{
						yield 4;
						yield 5;
					}
					yield 6;
				}
				var g=numbers();
				g.next();//{value:1,done:false}
				g.next();//{value:2,done:false}
				//开始执行finally代码块
				g.return(7);//{value:4,done:false}
				g.next();//{value:5,done:false}
				//finally代码块执行完成  开始执行return函数
				g.next();//{value:7,done:true}
	》yield*语句--如果在Generator函数内部，调用另一个Generator函数，默认情况下是没有效果的。
			function* foo(){
				yield 'a';
				yield 'b';
			}
			function* bar(){
				yield 'x';
				foo();
				yield 'y';
			}
			for(let v of bar()){
				console.log(v);//x y
			}
		》yield*语句，用来在一个Generator函数里面执行另一个Generator函数
			function* bar(){
				yield 'x';
				yield* foo();
				yield 'y';
			}
			//等同于
			function* bar(){
				yield 'x';
				yield 'a';
				yield 'b';
				yield 'y';
			}
			//等同于
			function* bar(){
				yield 'x';
				for(let v of foo()){
					yield v;
				}
				yield 'y';
			}
			for(let v of bar()){
				console.log(v);//x a b y
			}
		》示例
			function* inner(){
				yield 'hello!';
			}
			function* outer1(){
				yield 'open';
				yield inner();
				yield 'close';
			}
			var gen=outer1();
			gen.next();//{value: "open", done: false}
			gen.next();//{value: Generator(遍历器对象), done: false}
			gen.next();//{value: "close", done: false}
			function* outer2(){
				yield 'open';
				yield* inner();
				yield 'close';
			}
			var gen=outer2();
			gen.next();//{value: "open", done: false}
			gen.next();//{value: "hello!", done: false}
			gen.next();//{value: "close", done: false}
			总结：从语法角度看，如果yield命令后面跟的是一个遍历器对象，需要在yield命令后面加上星号(*)表明它返回的是一个遍历器。这被称为yield*语句。
		》yield*后面的Generator函数(没有return语句时)，等同于在Generator函数内部部署了一个for...of循环
			function* concat(iter1,iter2){
				yield* iter1;
				yield* iter2;
			};
			//等同于
			function* concat(iter1,iter2){
				for(var value of iter1){
					yield value;
				}
				for(var value of iter2){
					yield value;
				}
			}
			上面代码说明，yield*后面的Generator函数(没有return语句)，不过是for...of的一种简写形式，完全可以用后者替代前者。
			反之，则需要用var value=yield* iterator的形式获取return语句的值。
				function* inner(){
				    yield 'hello!';
				    return 'return'
				}
				function* outer1(){
				    yield 'open';
				    var value=yield* inner();
				    yield value;//如果没有这一步，拿不到return的值
				    yield 'close';
				}
				var gen=outer1();
				for(let value of gen){
				    console.log(value);//open  hello!  return  close
				}
		》如果yield*后面跟着一个数组，由于数组原生支持遍历器，因此会遍历数组成员
			function* gen(){
				yield* ['a','b','c'];
			}
			gen().next();//{value:"a",done:false}
		》任何数据结构只要有Iterator接口，就可以被yield*遍历
			let read=(function* (){
				yield 'hello';
				yield* 'hello';
			})();
			read.next().value // "hello"
			read.next().value // "h"
		》如果被代理的Generator函数的return语句，那么就可以向代理它的Generator函数返回数据
			function* foo(){
				yield 2;
				yield 3;
				return 'foo';
			}
			function* bar(){
				yield 1;
				var v=yield* foo();
				console.log("v:"+v);
				yield 4;
			}
			var it = bar();
			it.next()// {value: 1, done: false}
			it.next()// {value: 2, done: false}
			it.next()// {value: 3, done: false}
			it.next();// "v: foo"// {value: 4, done: false}
			it.next()// {value: undefined, done: true}
		》yield*命令可以很方便地取出嵌套数组的所有成员
			function* iterTree(tree){
				if(Array.isArray(tree)){
					for(let i=0;i<tree.length;i++){
						yield* iterTree(tree[i]);
					}
				}else{
					yield tree;
				}
			}
			const tree=['a',['b','c'],['d','e']];
			for(let x of iterTree(tree)){
				console.log(x);//a b c d e
			}
		》使用yield*语句遍历完全的二叉树
			//二叉树构造函数
			function Tree(let,label,right){
				this.left=left;//左树
				this.label=label;//当前节点
				this.right=right;//右树
			}
			//遍历函数
			function* inorder(t){
				if(t){
					yield* inorder(t.left);
					yield t.label;
					yield* inorder(t.right);
				}
			}
			//生成二叉树
			function make(array){
				//判断是否为叶节点
				if(array.length==1)return new Tree(null,array[0],null);
				return new Tree(make(array[0]),array[1],make(array[2]));
			}
			let tree=make([
				[['a'],'b',['c']],
				'd',
				[['e'],'f',['g']]
			]);
			// 遍历二叉树
			var result = [];
			for (let node of inorder(tree)) {
			  result.push(node);
			}
			result// ['a', 'b', 'c', 'd', 'e', 'f', 'g']
	》作为对象的属性的Generator函数
		》如果一个对象的属性是Generator函数，可以简写如下
			let obj={
				* myGeneratorMethod(){
					...
				}
			}
			//它的完整且等价形式如下
			let obj={
				myGeneratorMethod:function* (){
					...
				}
			}
	》Generator函数的this
		    Generator函数总是返回一个遍历器，ES6规定这个遍历器是Generator函数的实例，也继承了Generator函数的prototype对象上的方法
			function* g(){}
			g.prototype.hello=function(){
				return '这是Generator的原型'
			}
			let obj=g();
			obj instanceof g;//true
			obj.hello();//'这是Generator的原型'
			》上面代码表明，Generator函数g返回的遍历器obj，是g的实例，而且继承了g.prototype。但是
			如果把g当作普通的构造函数，并不会生效，因为g返回的总是遍历器对象，而不是this对象。
				function* g(){
					this.a=11;
				}
				g().a;//undefined
			》Generator函数也不能跟new命令一起用，会报错
				function* F(){
					yield this.x=2;
				}
				new F();// TypeError: F is not a constructor
			》那么怎么样才能让Generator函数返回一个正常的对象实例，既可以用next方法，又可以获得正常的this？
				》生成一个空对象，使用call方法绑定Generator函数内部的this，这样构造函数调用以后，这个空对象
				  就是Generator函数的实例对象
					function* F(){
						this.a=1;
						yield this.b=2;
						yield this.c=3;
					}
					var obj={};
					var f=F.call(obj);
					f.next();//{value:2,done:false}
					f.next();//{value:3,done:false}
					f.next();//{value:undefined,done:true}
					obj.a;//1
					obj.b;//2
					obj.c;//3
					上面代码执行的是遍历器对象f，生成的对象实例是obj。
					》下面将这两个对象统一--将obj换成F.prototype
						function* F(){
							this.a=1;
							yield this.b=2;
							yield this.c=3;
						}
						var f=F.call(F.prototype);
						f.next();  // Object {value: 2, done: false}
						f.next();  // Object {value: 3, done: false}
						f.next();  // Object {value: undefined, done: true}
						f.a // 1
						f.b // 2
						f.c // 3
					》在将F改成构造函数，就可以对它执行new命令了
						function* gen(){
							this.a=1;
							yield this.b=2;
							yield this.c=3;
						}
						function F(){
							return gen.call(gen.prototype)
						}
						var f=new F();
						f.next();  // Object {value: 2, done: false}
						f.next();  // Object {value: 3, done: false}
						f.next();  // Object {value: undefined, done: true}
						f.a // 1
						f.b // 2
						f.c // 3		
	》含义
		》Generator与状态机
			Generator是实现状态机的最佳结构。
			var ticking=true;
			var clock=function(){
				if(ticking)console.log('Tick!');
				else console.log('Tock!');
				ticking=!ticking;
			}
			//通过Generator实现上面效果
			var clock=function* (){
				while(true){
					console.log('Tick!');
					yield;
					console.log('Tock!');
					yield;
				}
			}
		》Generator与协程
			    协程coroutine是一种程序运行的方式，可以理解成"协作的线程"或"协作的函数"。
			协程既可以用单线程实现，也可以用多线程实现。前者是一种特殊的子例程，后者是一
			个特殊的线程。
			》协程与子例程的差异
				传统的"子例程"采用堆栈式"后进先出"的执行方式，只有当调用的子函数完全
			    执行完毕，才会结束执行父函数。协程与其不同，多个线程(单线程情况下，即多个函数)
			    可以并行执行，但是只有一个线程(或函数)处于正在运行的状态，其他线程(或函数)
			    都处于暂停态，线程(或函数)之间可以交换执行权。也就是说，一个线程(或函数)执行
			    到一半，可以暂停执行，将执行权交给另一个线程(或函数)，等到稍后收回执行权的时候
			    在恢复执行。这种可以并行执行、交换执行权的线程(或函数)就称协程。
			        从实现上看，在内存中，子例程只使用一个栈，而协程是同时存在多个栈，但是只有
			    一个栈是在运行状态，也就是说，协程是以多占用内存为代价，实现多任务的并行。
			》协程与普通线程的差异
				同一时间可以有多个线程处于运行状态，但是运行的协程只能有一个，其他协程都是处于
			    暂停状态。此外，普通的线程是抢先式，到底那个线程优先得到资源，必须由运行环境决定，但是协程是
			    合作式的，执行权由协程自己分配。
			        Generator函数是ES6对协程的实现，但属于不完全实现。Generator函数被称为"半协程"，即只有Generator
			    函数的调用者，才能将程序的执行权还给Generator函数。如果是完全执行的协程，任何函数都可以让暂停的协程
			    继承执行。
	》应用
		》异步操作的同步化表达
			Generator函数的暂停执行效果，意味着可以把异步操作写在yield语句里面，等到调用next方法时再往后执行。这实际上
			等同于不需要写回调函数了，因为异步操作的后续操作可以放在yield语句下面，反正要等到调用next方法时在执行。所以
			Generator函数的一个重要实际意义就是用来处理异步操作，改写回调函数。
				function* main(){
					var result=yield request('http://some.url');
					var resp=JSON.parse(result);
					console.log(resp.value);
				}
				function request(url){
					makeAjaxCall(url,function(respone){
						it.next(response);
					});
				}
				var it=main();
				it.next();
				上面代码的main函数，就是通过ajax操作获取数据。可以看到，除了多了一个yield，它几乎与同步操作
				的写法完全一样。注意：makeAjaxCall函数中的next方法，必须加上response参数，因为yield语句构成的表达式
				本身是没有值的，总是等于undefined。
		》控制流管理
			如果有一个多步操作非常耗时，采用回调函数。
				step1(function(value1){
					step2(value1,function(value2){
						step3(value2,function(value3){
							...
						});
					});
				});
				//采用Promise改写上面代码
				Promise.resolve(step1).then(step2).then(step3).then(function(value4){
					...
				},function(error){
					...
				}).done();
				//采用Generator函数进行改写
				function* longRunningTask(value1){
					try{
						var value2=yield step1(value1);
						var value3=yield step2(value2);
						var value4=yield step3(value3);
					}catch(e){...}
				}
		》部署Iterator接口--利用Generator函数，可以在任意对象上部署Iterator接口
			function* iterEntries(obj){
				let keys=Object.keys(obj);
				for(let i=0;i<keys.length;i++){
					let key=keys[i];
					yield [key,obj[key]];
				}
			}
			let myObj={foo:3,bar:7}
			for(let [key,value] of iterEntries(myObj)){
				console.log(key,value);//foo 3//bar 7
			}
		》作为数据结构
			Generator可以看作是数据结构，更确切地说，可以看作是一个数组结构，因为Generator函数可以返回一系列的值，
			这意味着它可以对任意表达式，提供类似数组的接口。
			function *doStuff(){
				yield fs.readFile.bind(null,'hello.txt');
				yield fs.readFile.bind(null,'world.txt');
				yield fs.readFile.bind(null,'and-such.txt');
			}
			上面代码就一次返回三个函数，但是由于使用Generator函数，导致可以像处理数组那样，处理这三个返回的函数
			for(let task of doStuff()){
				//处理任务函数
			}
			//如果用ES5表达，完全可以用数组模拟Generator的这种用法
			function doStuff(){
				return [
					fs.readFile.bind(null,'hello.txt'),
					fs.readFile.bind(null,'world.txt'),
					fs.readFile.bind(null,'and-such.txt')
				]
			}
26.Promise对象
	》Promise的含义
		    Promise是异步编程的一种解决方案，比传统的解决方案(回调函数和事件)更合理和更强大。
		    所谓Promise，简单是就是一个容器，里面保存着某个未来才会结束的事件(通常是一个异步操作)的结果。
		从语法上说，Promise是一个对象，从它可以获取异步操作的消息。Promise提供了统一的API，各种异步操作都
		可以用同样的方法进行处理。
		    Promise对象有以下两个特点：
			》对象的状态不受外界影响。Promise对象代表一个异步操作，有三种状态：Pending(进行中)、Resolved(已完成，又称Fulfilled)
			  和Rejected(已失败)。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是Promise这个
			  名字的由来，它的英文意思"承诺"，表示其他手段无法改变。
			》一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise对象的状态改变，只有两种可能：从Pending变为Resolved和从
			  Pending变为Rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果。就算改变已经发生了，你再对Promise
			  对象添加回调函数，也会立即得到这个结果。这与事件(Event)完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。
		    有了Promise对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此外，Promise对象提供统一的接口，使得控制
		异步操作更加容易。
		    Promise缺点：
			》无法取消Promise，一旦新建它就会立即执行，无法中途取消
			》如果不设置回调函数，Promise内部抛出的错误，不会反应到外部
			》当处于Pending状态时，无法得知目前进展到哪一个阶段(刚刚开始还是即将完成)
		    如果某些事件不断地反复发生，一般来说，使用stream模式是比部署Promise更好的选择。
	》基本用法--ES6规定 Promise对象是一个构造函数，用来生成Promise实例
		//Promise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject，它们是两个函数，由js引擎提供，不用自己部署
		var promise=new Promise(function(resolve,reject){
			...
			if(异步操作成功){
				resolve(value);
			}else{
				reject(error);
			}
		});
		resolve函数的作用：将Promise对象的状态从Pending变为Resolved，在异步参数成功时调用，并将异步操作的结果，作为参数传递出去
		reject函数的作用，将Promise对象的状态从Pending变为Rejected，在异步操作失败是调用，并将异步操作报出的错误，作为参数传递出去。
		》Promise实例生成以后，可以用then方法分别指定Resolved状态和Reject状态的回调函数
			promise.then(function(value){
				//成功
			},function(error){
				//失败
			});
			then方法可以接受两个回调函数作为参数。第一个回调函数是Promise对象的状态变为Resolved时调用，第二个回调函数是Promise对象
			的状态变为Reject时调用。其中第二个参数是可选的，不一定要提供。这两个函数都接受Promise对象传出的值作为参数。
		》Promise新建后就会立即执行
			let promise=new Promise(function(resolve,reject){
				console.log('Promise');
				resolve();
			});
			promise.then(function(){
				console.log("Resolved");
			});
			console.log("Hi");
			//Promise
			//Hi
			//Resolved
			上面代码中，Promise新建后立即执行，所以首先输出的是"Promise"，然后then方法指定的回调函数，将在当前脚本所有同步任务执行完才会执行，所以"Resolved"最后输出。
		》异步加载图片的例子
			function loadImageAsync(url){
				return new Promise(function(resolve,reject){
					var image=new Image();

					image.onload=function(){
						resolve(image);
					}
					image.onerror=function(){
						reject(new Error("Could not load image at"+url));
					}
					image.src=url;
				});
			}
			loadImageAsync("./images/a.jpg").then(function(img){console.log(img)},function(err){console.log(err)});
			上面代码中，使用Promise包装了一个图片加载的异步操作。如果加载成功，就调用resolve方法，否则就调用reject方法。
		》用Promise对象实现Ajax操作的例子
			var getJson=function(url){
				var promise=new Promise(function(resolve,reject){
					var client=new XMLHttpRequest();
					client.open("GET",url);
					client.onreadystatechange=handler;
					client.responseType='json';
					client.setRequestHeader("Accept",'application/json');
					client.send();
					function handler(){
						if(this.readyState!==4){return;}
						if(this.status===200){resolve(this.response)}
						else{reject(new Error(this.statusText))}
					}
				});
				return promise;
			}
			getJson("test.json").then(function(json){console.log("data:"+json)},function(error){console.log("出错了："+error)})
			如果调用resolve函数和reject函数时带有参数，那么他们的参数会被传递给回调函数。reject函数的参数通常是Error对象的实例，表示
			抛出错误，resolve函数的参数除了正常的值以外，还可能是另一个Promise实例，表示异步操作的结果可能是一个值，也有可能是另一个
			异步操作。
				var p1=new Promise(function(resolve,reject){...});
				var p2=new Promise(function(resolve,reject){
					...
					resolve(p1);
				});
				注意：这是p1的状态就会传递给p2，也就是说，p1的状态决定了p2的状态。如果p1的状态是Pending，那么p2的回调函数就会
				等待p1的状态改变。如果p1的状态已经是Resolved或Rejected,那么p2的回调函数将会立即执行。
	》Promise.prototype.then()
		》Promise实例具有then方法，也就是说，then是定义在原型对象Promise.prototype上的，它的作用是为Promise实例添加状态改变时的回调函数。
		  then方法的第一个参数是Resolved状态的回调函数，第二个参数(可选)是Rejected状态的回调函数。
		  then方法返回的是一个新的Promise实例(注意：不是原来那个Promise实例)。因此可采用链式写法，即then方法后面在调用另一个then方法。
			getJSON("test.json").then(function(json){
				return json.post;
			}).then(function(post){
				...
			});
			上面的代码使用then方法，依次指定了两个回调函数。第一个回调函数完成以后，会将返回结果作为参数，传入第二个回调函数。
		》采用链式的then可以指定一组按照次序调用的回调函数。这时，前一个回调函数，有可能返回的还是一个Promise对象(即有异步操作)，
		  这时后一个回调函数，就会等待该Promise对象的状态发生变化。才会被调用。
			getJson('test.json').then(function(post){
				return getJson(post.commentURL);
			}).then(function funcA(comments){console.log("Resolved")},function funcB(err){console.log("Rejected")});
			上面代码中，第一个then方法指定的回调函数，返回的是另一个Promise对象。这时，第二个then方法指定的回调函数，
			就会等待这个新的Promise对象状态发生变化。如果变为Resolved，就调用funcA，如果状态变为Rejected，就调用funcB。
			》使用箭头函数 改写上面代码
				getJson('test.json').then(
					post=>getJson(post.commentURL);
				).then(
					comments=>console.log("Resolved"),
					err=>console.log("Rejected")
				);
	》Promise.prototype.catch()
		》Promise.prototype.catch方法是.then(null,rejection)的别名，用于指定发生错误时的回调函数
			getJson('test.json').then(function(post){...}).catch(function(error){
				//处理getJson和前一个回调函数运行时发生的错误
				console.log("发生错误"，error);
			})
			上面代码中，getJson方法返回一个Promise对象，如果该对象状态变为Resolved，则会调用then方法指定的回调函数
			如果异步操作抛出错误，状态就会变为Rejected，就会调用catch方法指定的回调函数，处理这个错误。另外，then方法
			指定的回调函数，如果运行中抛出错误，也会被catch方法捕获。
				p.then(val=>console.log("fulfilled:",val)).catch(err=>console.log("rejected:",err));
				//等同于
				p.then(val=>console.log("fulfilled:",val)).then(null,err=>console.log("rejected:",err))
		》var promise =new Promise(function(resolve,reject){
			throw new Error("test");
		  });
		  promise.catch(function(err){
			console.log(error);//Error: test
		  });
		  //等同于
		  var promise=new Promise(function(resolve,reject){
			try{
				throw new Error("test");
			}catch(e){
				reject(e);
			}
		  });
		  promise.catch(function(error){
			console.log(error);
		  });
		  //等同于
		  var promise=new Promise(function(resolve,reject){
			reject(new Error('test'));
		  });
		  promise.catch(function(error){
			console.log(error);
		  });
		  比较上面两种写法，可以发现reject方法的作用，等同于抛出错误
		 》如果Promise状态已经变成Resolved，再抛出错误是无效的
			var promise=new Promise(function(resolve,reject){
				resolve("ok");
				throw new Error('test');
			});
			promise.then(value=>console.log(value)).catch(error=>console.log(error));//ok
			//即Promise在resolve语句后面，在抛出错误，不会被捕获，等于没有抛出
		》Promise对象的错误具有"冒泡"性质，会一直向后传递，直到被捕获为止。也就是说，错误总是会被下一个catch语句捕获
			getJson('test.json').then(function(post){
				return getJson(post.commentURL);
			}).then(function(comments){
				//some code
			}).catch(function(error){
				//处理前面三个Promise产生的错误
			});
		》一般来说，不要在then方法里面定义Reject状态的回调函数(即then的第二个参数)，总是使用catch方法
			//不推荐
			promise.then(function(data){...},function(error){...})
			//推荐
			promise.then(function(data){...}).catch(function(error){...});
			上面代码中，第二种写法要好于第一种写法，理由是第二种写法可以捕获前面then方法执行中的错误，也更接近同步的写法
			(try/catch),因此建议总是使用catch方法，而不使用then方法的第二个参数
		》根传统的try/catch代码块不同的是，如果没有使用catch方法指定错误处理的回调函数，Promise对象抛出的错误不会传递到外层代码，即
		  不会有任何反应
			var someAsyncThing=function(){
				return new Promise(function(resolve,reject){
					//会出错的代码
					resolve(x+2);//x为定义
				})
			}
			someAsyncThing().then(function(){
				console.log('everything is great');
			});
			上面代码中，someAsynThing函数产生的promise对象会报错，但是由于没有指定catch方法，这个错误不会被捕获，也不会传递到外层代码。导致运行后没有
			任何输出。
			注意有些浏览器并不遵守这条规定，如chrome会抛出x is not defined错误
		》Node有一个unhandleRejection事件，专门监听未捕获的reject错误
			process.on("unhandledRejection",function(err,p){//err--错误对象 p--报错的Promise实例
				console.log(err.stack);
			})
		》需要注意的是，catch方法返回的还是一个Promise对象，因此后面还可以接着调用then方法
			var someAsyncThing=function(){
				return new Promise(function(resolve,reject){
					//没有声明x  报错
					resolve(x+2);
				});
			}
			someAsyncThing().catch(function(error){
				console.log('oh no',error);// oh no [ReferenceError: x is not defined]
			}).then(function(){
				console.log('carry on');// carry on
			});
			//如果没有报错，则会跳过catch方法，执行后面的then方法。此时要是then方法里面报错就与前面的catch无关了
		》catch方法之中，还能再抛出错误
			var someAsyncThing=function(){
				return new Promise(function(resolve,reject){
					//没有声明x  报错
					resolve(x+2);
				});
			}
			someAsyncThing().catch(function(error){
				console.log('oh no',error);// oh no [ReferenceError: x is not defined]
				y+2;//报错 y没有声明
			}).catch(function(error){
				console.log('carry on',error);// carry on [ReferenceError: y is not defined]
			});
	》Promise.all()--用于将多个Promise实例，包装成一个新的Promise实例
		var p=Promise.all([p1,p2,p3]);
		上面代码中，Promise.all方法接受一个**数组**作为参数，p1,p2,p3都是Promise对象的实例，如果不是，就会先调用Promise.resolve方法
		将参数转为Promise实例，在进一步处理。Promise.all方法的参数可以不是数组，但必须具有Iterator接口，且返回的每一个成员都是Promise实例
		》p的状态由p1、p2、p3决定，分成两种情况
			》只有p1 p2 p3的状态都变成了fulfilled，p的状态才会变成fulfilled，此时p1 p2 p3的返回值组成一个数组，传递给p的回调函数。
			》只有p1 p2 p3之中有一个被rejected,p的状态就变成rejected，此时第一个被reject的实例的返回值，会传递给p的回调函数。
		》实例
			//生成一个Promise对象的数组
			var promises=[2,3,4].map(function(id){
				return getJson('test'+id+".json");
			});
			Promise.all(promises).then(function(posts){
				...
			}).catch(function(reason){
				...
			})
			上面代码中，Promises中的所有Promise实例状态都变为fulfilled，或者其中有一个变为rejected，才会调用Promise.all方法后面
			的回调函数。
	》Promise.race()--同样是将多个Promise实例，包装成一个新的Promise实例
		var p=Promise.race([p1,p2,p3]);
		上面代码中，只要p1 p2 p3之中有一个实例率先改变状态，p的状态就跟着改变。那个率先改变的Promise实例的返回值，就传递给p的回调函数
		Promise.race方法的参数与Promise.all方法一样，如果不是Promise实例，就会先调用Promise.resalve方法，将参数转为Promise实例，在进一步处理
		》实例--如果指定时间内没有获得结果，就将Promise的状态变为reject，否则变为resolve
			var p =Promise.race([
				fetch('/resource-that-may-take-a-while'),
				new Promise(function(resolve,reject){
					setTimeout(()=>reject(new Error('request timeout')),5000)
				})
			]);
			p.then(response=>console.log(response)).catch(error=>console.log(error));
			上面代码中，如果5秒内fetch方法无法返回结果，变量p的状态就会变为rejected，从而触发catch方法指定的回调函数
	》Promise.resolve()--有时需要将现有对象转为Promise对象，Promise.resolve方法就起到这个作用
		var jsPromise=Promise.resolve($.ajax('test.json'));
		Promise.resolve等价于下面的写法：
			》Promise.resolve("foo")
			等价于
			new Promise(resolve=>resolve('foo'))
		》Promise.resolve方法的参数分成四种情况
			》参数是一个Promise实例
				如果参数是Promise实例，那么Promise.resolve将不做任何修改、原封不动地返回这个实例
			》参数是一个thenable对象--具有then方法的对象
				如：
				let thenable={
					then:function(resolve,reject){
						resolve(42);
					}
				}
				Promise.resolve方法会将这个对象转为Promise对象，然后立即执行thenable对象then方法
				let p1=Promise.resolve(thenable);
				p1.then(function(value){
					console.log(value);//42
				});
				上面代码中，thenable对象的then方法执行后，对象p1的状态就变为resolved，从而立即执行最后那个then方法指定的回调函数输出42
			》参数不是具有then方法的对象，或者根本就不是对象
				如果参数是一个原始值，或者是一个具有then方法的对象，则Promise.resolve方法返回一个新的Promise对象，状态为Resolved。
				var p=Promise.resolve('hello');
				p.then(function(s){
					console.log(s);//hello
				});
			》不带有任何参数
				Promise.resolve方法允许调用时不带参数，直接返回一个Resolved状态的Promise对象，所以如果希望得到一个Promise对象，比较方便的方法
				就是直接调用Promise.resolve方法。
				var p=Promise.resolve();
				p.then(function(){
					...
				});
				》需要注意的是，立即resolve的Promise对象是在本轮"事件循环"的结束时，而不是在下一轮"事件循环"的开始时
					//在下一轮"事件循环"的开始时执行
					setTimeout(function () {
					  console.log('three');
					}, 0);
					//本轮"事件循环"的结束时执行
					Promise.resolve().then(function () {
					  console.log('two');
					});
					//立即执行
					console.log('one');
					// one
					// two
					// three
	》Promise.reject()--也会返回一个新的Promise实例，该实例的状态为rejected
		var p=Promise.reject("出错了");
		等同于
		var p=new Promise((resolve,reject)=>reject("出错了"));
		p.then(null,function(error){
			console.log(error);//出错了
		})
		》注意：Promise.reject方法的参数，会***原封不动地***作为reject的理由，变成后续方法的参数。这一点与Promise.resolve方法不一致	
	》两个有用的附加方法
		ES6的Promise API提供的方法不是很多，有些有用的方法可以自己部署。
		》done()
			Promise对象的回调链，不管以then方法或catch方法结尾，要是最后一个方法抛出错误，都有可能无法捕捉到(因为Promise内部的错误不会冒泡到全局)。因此
			我们可以提供一个done方法，总是处于回调链的尾端，保证抛出任何可能出现的错误。
			asyncFunc().then(f1).catch(r1).done();
			》done方法实现
				Promise.prototype.done=function(onFulfilled,onRejected){
					this.then(onFulfilled,onRejected).catch(function(reason){
						//抛出全局错误
						setTimeout(()=>{throw reason},0);
					});
				}
		》finally()--用于指定不管Promise对象最后的状态如果，都会执行的操作，它与done方法最大的区别，它接受一个普通的回调函数作为参数
			     ，该函数不管怎样都必须执行。
			     》实例--服务器使用Promise处理请求，然后使用finally方法关掉服务器
				server.listen(0).then(function(){
					...
				}).finally(server.stop);
			     》finally实现
				Promise.prototype.finally=function(callback){
					let p=this.constructor;
					return this.then(
						value=>p.resolve(callback()).then(()=>value),
						reason => P.resolve(callback()).then(() => { throw reason })
					);
				}
	》应用
		》加载图片--可以将图片的加载写成一个Promise,一旦加载完成，Promise的状态就发生变化
			const preloadImage=function(path){
				return new Promise(function(resolve,reject){
					var image=new Image();
					image.onload=resolve;
					image.onerror=reject;
					image.src=path;
				});
			}
		》Generator函数与Promise的结合--使用Generator函数管理流程，遇到异步操作的时候，通常返回一个Promise对象
			function getFoo(){
				return new Promise(function(resolve,reject){
					resolve('foo');
				});
			}
			var g=function* (){
				try{
					var foo=yield getFoo();
					console.log(foo);
				}catch(e){
					console.log(e);
				}
			}
			function run(generator){
				var it =generator();
				function go(result){
					if(result.done){
						return result.value;
					}
					return result.value.then(function(value){
						return go(it.next(value));
					},function(error){
						return go(it.throw(error));
					});
				}
				go(it.next());
			}
			run(g);
	》Promise.try()
		实际开发中，经常遇到一种情况，不知道或者不想区分，函数f是同步函数还是异步操作，但是想用Promise来处理它。因为这样就可以不管f
		是否包含异步操作，都用then方法指定下一步流程，用catch方法处理f抛出的错误。
		》一般就会采用这种写法：
			Promise.resolve().then(f);
			》这种写法的缺点：就是如果f是同步函数，那么它会在本轮事件循环的末尾执行
				const f=()=>console.log("now");
				Promise.resolve().then(f);
				console.log("next");
				//next
				//now
				上面代码中，函数f是同行，但是用Promise包装了以后，就变成异步执行了
			》让同步函数同步执行，异步函数异步执行
				》方式1--用async函数来写
					const f=()=>console.log("now");
					//async函数自调，如果是同步函数就会得到同步结果，如果f是异步，就可以用then指定下一步async ()=>f())().then(...)
					(async ()=>f())();
					console.log('next');
					//now
					//next
					注意：async()=>f()会吃掉f()抛出的错误，所以如果想捕获错误，要使用Promise.catch方法
						(async()=>f())().then(...).catch(...)
				》方式2--使用new Promise()
					const f=()=>console.log('now');
					(
						()=>new Promise(resolve=>resolve(f()))
					)();
					console.log('next');
					//now
					//next
					上面代码也是使用立即执行的匿名函数，执行new Promise(),这种情况下，同步函数也是同步执行
				》鉴于这是一个很常见的需求，所以现在有一个提案，提供了Promise.try方法替代上面的写法
					const f=()=>console.log('now');
					Promise.try(f);
					console.log('next');
					//now
					//next
					事实上，Promise.try就是模拟try代码块，就像promise.catch模拟的是catch代码块
27.异步操作和Async函数
	》基本概念
		》异步
			所谓"异步"简单说就是一个任务不是连续完成的，可以理解成该任务被人分成两段，先执行第一段，然后转而执行
		    其他任务，等做好了准备，在回过头执行第二段。
		        相应地，连续的执行就叫同步。由于是连续执行，不能插入其他任务。
		》ES6诞生以前，异步编程的方法
			》回调函数
				js语言对异步编程的实现就是回调函数。所谓回调函数就是把任务的第二段单独写在一个函数里面，等到重新执行这个任务的时候
				就直接调用这个函数。
				如：读取文件进行处理
					fs.readFile('/etc/passwd','utf-8',function(err,data){
						if(err){throw err};
						console.log(data);
					});
					上面代码中，readFile函数的第三个参数，就是回调函数，也就是任务的第二段。等到操作系统返回了文件以后，回调
					函数才会执行。
			》事件监听
			》发布/订阅
			》Promise对象
				回调函数本身并没有问题，它的问题出现在多个回调函数的嵌套。假定读取A文件之后再读取B文件。
					fs.readFile(fileA,'utf-8',function(err,data){
						fs.readFile(fileB,'utf-8',function(err,data){
							...
						});
					})
				Promise对象就是为了解决这个问题而提出的。它不是新的语法功能，而是一种新的写法，允许将回调函数的嵌套，改成链式调用。
					//返回一个Promise版本的readFile函数
					var readFile=require('fs-readfile-promise');
					readFile(fileA).then(function(data){
						console.log(data);
					}).then(function(){
						return readFile(fileB);
					}).then(function(data){
						console.log(data);
					}).catch(function(err){
						console.log(err);
					});
					//上面的缺点：代码冗余
	》Generator函数
		》协程
			传统的编程语言早有异步编程的解决方案(其实是多任务的解决方案)。其中有一种叫做"协程"，即多个线程互相协作，完成异步任务。
			协程有点像函数，又有点像线程。它的运行流程如下：
				》第一步，协程A开始执行
				》第二步，协程A执行到一半，进入暂停，执行权转移到协程B
				》第三步，一段时间后协程B交还执行权
				》第四步，协程A恢复执行
				上面流程的协程A就是异步任务，因为它分为两段(或多段)执行
		》Generator函数的概念
			Generator函数是协程在ES6的实现，最大特点就是可以交出函数的执行权--即暂停执行
			整个Generator函数就是一个封装的异步任务，或者说是异步任务的容器。异步操作需要暂停的地方都用yield语句注明。
			function* gen(x){
				var y =yield x+2;
				return y;
			}
			var g=gen(1);
			g.next();//{value:3,done:false}
			g.next();//{value:undefined,done:true}
		》Generator函数的数据交换和错误处理
			Generator函数可以暂停执行和恢复执行，这是它能封装异步任务的根本原因。除此之外，它还有两个特性，使它
			可以作为异步编程的完整解决方案：函数体内外的数据交换和错误处理机制
			》next方法返回值的value属性是Generator函数向外输出数据；next方法还可以接受参数，这是向Generator函数体内输入数据
				function* gen(x){
					var y=yield x+2;
					return y;
				}
				var g=gen(1);
				g.next();//{value:3,done:false}
				g.next(2);//{value:2,done:true}
			》Generator函数内部还可以部署错误处理代码，捕获函数体外抛出的错误
				function* gen(x){
					try{
						var y=yield x+2;
					}catch(e){
						console.log(e);
					}
					return y;
				}
				var g=gen(1);
				g.next();
				g.throw('出错了');//"出错了"
				上面代码,Generator函数体外使用指针对象的throw方法抛出的错误，可以被函数体内的try...catch代码块捕获。
				这意味着，出错的代码与处理错误的代码，实现了时间和空间上的分离，这对于异步编程无疑是很重要的。
		》异步任务的封装
			var fetch=require('node-fetch');
			function* gen(url){
				var result =yield fetch(url);//Fetch模块返回的是一个Promise对象
				console.log(result);
			}
			var g=gen('https://api.github.com/users/github');
			var result=g.next();
			result.value.then(function(data){return data.json()}).then(function(data){g.next(data)});
			缺点：Generator函数将异步操作表示的很简洁，但是流程管理却不方便即何时执行第一阶段、何时执行第二阶段
	》Thunk函数
		》参数的求值策略--即函数的参数到底应该何时求值
			var x=1;
			function f(m){
				return m*2;
			}
			f(x+5);
			》传值调用--即在进入函数体之前，就计算参数表达式的值，再将这个值传入函数之中。
				f(x+5);
				等同于
				f(6);
			》传名调用--即直接将表达式传入函数体，只在用到它的时候求值。
				f(x+5);
				等同于
				(x+5)*2;
		》Thunk函数的含义
			编译器的"传名调用"实现，往往是将参数放到一个临时函数之中，再将这个临时函数传入函数体。这个临时函数就叫做--Thunk函数
				function f(m){return m*2}
				f(x+5);
				//等同于
				var thunk=function(){return x+5;}
				function f(thunk){
					return thunk()*2;
				}
				即Thunk函数是"传名调用"的一种实现策略，用来替换某个表达式。
		》js语言的Thunk函数
			js语言是传值调用，它的Thunk函数含义有所不同。在js语言中，Thunk函数替换的不是表达式，
			而是多参数函数，将其替换成单参数的版本，且只接受回调函数作为参数
			//正常版本的readFile--多参数
				fs.readFile(fileName,callback);
			//Thunk版本的readFile--单参数
				var Thunk=function(fileName){
					return function(callback){
						return fs.readFile(fileName,callback);
					}
				}
				var readFileThunk=Thunk(fileName);
				readFileThunk(callback);
			上面代码中，fs模块的readFile方法是一个多参数函数，两个参数分别为文件名和回调函数。经过转换器处理，变成了一个单参数函数
			只接受回调函数作为参数。这个单参数版本就叫做Thunk函数
			》任何函数，只要参数有回调函数就能写成Thunk函数的形式
				Thunk函数转换器：
					》ES5
						var Thunk=function(fn){
							return function(){
								var args=Array.prototype.slice.call(arguments);
								return function (callback){
									args.push(callback);
									return fn.apply(this,args)
								}
							}
						}
					》ES6
						var Thunk=function(fn){
							return function(...args){
								return function(callback){
									return fn.call(this,...args,callback);
								}
							}
						}
					//使用上面转换器 生成fs.readFile的Thunk函数
						var readFileThunk=Thunk(fs.readFile);
						readFileThunk(fileA)(callback);
		》Thunkify模块--生产环境的转换器，建议使用Thunkify模块
			》首先安装  npm install thunkify
			》使用方式
				var thunkify=require('thunkify');
				var fs=require('fs');
				var read=thunkify(fs.readFile);
				read('package.json')(function(err,str){
					//...
				});
		》Generator函数的流程管理
			Thunk函数可以用于Generator函数的自动流程管理。
			》Generator函数的自动执行
				function* gen(){
					...
				}
				var g=gen();
				var res=g.next();
				while(!res.done){
					console.log(res.value);
					res=g.next();
				}
				上面代码中，Generator函数gen会自动执行完所有步骤，但是这不适合异步操作。如果必须保证前一步执行完，才能执行后一步，
				上面的自动执行就不可行。这是Thunk函数就能派上用处了。
				》实例--Generator函数封装了两个异步操作
					var fs=require('fs');
					var thunkify=require('thunkify');
					var readFile=thunkify(fs.readFile);
					var gen=function* (){
						var r1=yield readFile('test1');
						console.log(r1.toString());
						var r2=yield readFile('test2');
						console.log(r2.toString());
					}
					上面代码中，yield命令用于将程序的执行权移出Generator函数，而Thunk函数用于将执行权还给Generator函数
					因为Thunk函数可以在回调函数中将执行权还给Generator函数
					var g=gen();
					var r1=g.next();
					r1.value(function(err,data){
						if(err)throw err;
						var r2=g.next(data);
						r2.value(function(err,data){
							if(err) throw err;
							g.next(data);
						})
					});
					上面代码，可以发现Generator函数的执行过程，其实就是将同一个回调函数，反复传入next方法的value属性。这使得我们可以
					用**递归**来自动完成这个过程
		》Thunk函数的自动流程管理
			Thunk函数真正的威力，在于可以自动执行Generator函数。下面就是一个基于Thunk函数的Generator执行器
			//Generator函数自动执行器
			function run(fn){
				var gen=fn();
				//Thunk函数的回调函数
				function next(err,data){
					var result=gen.next(data);
					if(result.done){return;}
					result.value(next);
				}
				next();
			}
			function* g(){...}
			run(g);
			有了这个执行器，执行Generator函数方便多了。不管内部有多少个异步操作，直接把Generator函数传入run函数即可。当然前提是
			每一个异步操作，都要是Thunk函数，也就是说跟在yield命令后面的必须是Thunk函数。
				var g=function* (){
					var f1=yield readFile('fileA');
					var f2=yield readFile('fileB');
					...
					var fn=yield readFile('fileN');
				}
				run(g);
			注意：Thunk函数并不是Generator函数自动执行的唯一方案。因为自动执行的关键是，必须有一种机制，自动控制Generator函数的流程，
			      接收和交换程序的执行权。回调函数可以做到这点，Promise对象也可以做到这一点。
	》co模块
		》基本用法
			co模块是著名程序猿TJ Holowaychuk于2013年6月发布的一个小工具，用于Generator函数的自动执行。
			如：有一个Generator函数用于依次读取两个文件
				var gen=function* (){
					var f1=yield readFile('file1');
					var f2=yield readFile('file2');
					console.log(f1.toString());
					console.log(f2.toString());
				}
				co模块可以让你不用编写Generator函数的执行器
				var co=require('co');
				co(gen);
				上面代码中，Generator函数只要传入co函数，就会自动执行。
				co函数返回一个Promise对象，因此可以用then方法添加回调函数。
				co(gen).then(function(){
					console.log('Generator 函数执行完成');
				});
		》co模块的原理
			Generator就是一个异步操作的容器。它的自动执行需要一种机制，当异步操作有了结果，能够自动交回执行权。
			以下两种方式可以做到：
				》回调函数--将异步操作包装成Thunk函数，在回调函数里面交回执行权
				》Promise对象--将异步操作包装成Promise对象，用then方法交回执行权。
				co模块其实就是将两种自动执行器(Thunk函数和Promise对象)，包装成一个模块。使用co的前提条件是，Generator
				函数yield命令后面，只能是Thunk函数或Promise对象。
			》基于Promise对象的自动执行
				》把fs模块的readFile方法包装成一个Promise对象
					var fs=require('fs');
					var readFile=function(fileName){
						return new Promise(function(resolve,reject){
							fs.readFile(fileName,function(err,data){
								if(err){return reject(err)}
								resolve(data);
							})
						})
					}
					var gen=function* (){
						var f1=yield readFile('file1');
						var f2=yield readFile('file2');
						console.log(f1.toString());
						console.log(f2.toString());
					}
				》手动执行上面的Generator函数
					var g=gen();
					g.next().value.then(function(data){
						g.next(data).value.then(function(data){
							g.next(data);
						})
					});
				》手动执行其实就是用then方法，层层添加回调函数。--理解这个就可以写一个自动执行器
					function run(gen){
						var g=gen();
						function next(data){
							var result=g.next(data);
							if(result.done)return result.value;
							result.value.then(function(data){
								next(data);
							});
						}
						next();
					}
					run(gen);
			》co模块的源码
				》首先，co函数接受Generator函数作为参数，返回一个Promise对象
					function co(gen){
						var ctx=this;
						return new Promise(function(resolve,reject){
							//检查参数gen是否为Generator函数
								//如果是就执行该函数 得到内部指针对象
								if(typeof gen==='function'){
									gen=gen.call(ctx);
								}
								//不是就返回，并将Promise对象的状态改为resolved
								if(!gen || typeof gen.next !==='function') return resolve(gen);
								》接着，co将Generator函数的内部指针对象的next方法，包装成onFulfilled函数--为了捕捉抛出的错误
									onFulfilled();
									function onFulfilled(res){
										var ret;
										try{
											ret=gen.next(res);
										}catch(e){
											return reject(e);
										}
										next(ret);
									}
								》最后，就是关键的next函数，它会反复调用自身
									function next (ret){
										if(ret.done)return resolve(ret.value);
										//确保每一步的返回值，是 Promise 对象
										var value=toPromise.call(ctx,ret.value);
										//使用then方法，为返回值加上回调函数，然后通过onFulfilled函数再次调用next函数。
										if(value&&isPromise(value)){
											return value.then(onFulfilled,onRejected)
										}
										return onRejected(
											new TypeError(
												'You may only yield a function, promise, generator, array, or object, '
											      + 'but the following object was passed: "'
											      + String(ret.value)
											      + '"'
											)
										);
									}
						});
					}
				》处理并发的异步操作
					co支持并发的异步操作，即允许某些操作同时进行，等到他们全部完成，才进行下一步
					这时，要把并发的操作都放在**数组或对象**里面，跟在yield语句后面
					//数组写法
					co(function* (){
						var res=yield [
							Promise.resolve(1),
							Promise.resolve(2)
						];
						console.log(res);
					}).catch(onerror);
					//对象的写法
					co(function* (){
						var res=yield {
							1:Promise.resolve(1),
							2:Promise.resolve(2)
						};
						console.log(res);
					}).catch(onerror);
	》async函数--ES2017标准提供了async函数
		》含义
			async函数是Generator函数的语法糖。
			》用Generator函数依次读取两个文件
				var fs=require('fs');
				var readFile=function(fileName){
					return new Promise(function(resolve,reject){
						fs.readFile(fileName,function(error,data){
							if(error) reject(error);
							resolve(data);
						});
					});
				}
				var gen=function* (){
					var f1=yield readFile('file1');
					var f2=yield readFile('file2');
					console.log(f1.toString());
					console.log(f2.toString());
				}
			》用async函数
				var asyncReadFile=async function(){
					var f1=await readFile('file1');
					var f2=await readFile('file2');
					console.log(f1.toString());
					console.log(f2.toString());
				}
				一比较就会发现，async函数就是将Generator函数的星号(*) 替换成async 将yield替换成await，仅此而已
			》async函数对Generator函数的改进体现在以下四点
				》内置执行器--Generator函数的执行必须靠执行器，所以才有了co模块，而async函数自带执行器。也就是说async函数
					      的执行与普通函数一样，只要一行
					      var result  =asyncReadFile();
				》更好的语义--async和await比起星号和yield语义更清楚了。async表示函数里有异步操作，await表示紧跟在后面的表达式需要等待结果
				》更广的适用性--co模块约定，yield命令后面只能是Thunk函数或Promise对象，而async函数的await命令后面可以是Promise对象和原始类型的值(数值、字符串和布尔值，但这时等同于同步操作)
				》返回值是Promise--async函数的返回值是Promise对象，这比Generator函数返回值是Iterator对象方便多了。你可以用then方法指定下一步操作
				进一步说，async函数完全可以看作多个异步操作，包装成的一个Promise对象，而await命令就是内部then命令的语法糖
		》语法
			async函数的语法规则总体上比较简单，难点是错误处理机制
			》async函数返回一个Promise对象
				async function f(){
					return 'hello world';
				}
				f().then(v=>console.log(v));//'hello world'
				上面代码中，函数f内部return命令返回的值，会被then方法回调函数接收到
			》async函数内部抛出错误，会导致返回的Promise对象变为reject状态。抛出的错误对象会被catch方法回调函数接收到
				async function f(){
					throw new Error('屌丝，出错了');
				}
				f().then(
					v=>console.log(v),
					e=>console.log(e)
				);//Error：出错了
			》async函数返回的Promise对象，必须等到内部所有await命令的Promise对象执行完，才会发生状态改变，除非遇到return语句或抛出错误。
			  也就是说，只有async函数内部的异步操作执行完，才会执行then方法指定的回调函数
				async function getTitle(url){
					let response=await fetch(url);
					let html=await response.text();
					return html.match(/<title>([\s\S]+)<\/title>/i)[1]; 
				}
				getTitle('https://tc39.github.io/ecma262/').then(console.log)
			》正常情况下，await命令后面是一个Promise对象，如果不是，会被转成一个立即resolve的Promise对象
				async function f(){
					return await 123;
				}
				f().then(console.log);//123
			》await命令后面的Promise对象如果变为reject状态，则reject的参数会被catch方法的回调函数接收到
				async function f(){
					await Promise.reject("屌丝，出错了");
				}
				f().then(console.log).catch(console.log);
				注意，上面代码中，await语句前面没有return，但是reject方法的参数依然传入了catch方法的回调函数。这里如果
				在await前面加上return，效果一样的。
			》只要一个await语句后面的Promise变为reject，那么整个async函数都会中断执行
				async function f(){
					await Promise.reject('出错了');
					await Promise.resolve('hello');//不会执行
				}
				f().then(console.log).catch(console.log);
				》为了避免这个问题，可以将第一个await放在try...catch结构里面，这样第二个await就会执行
					async function f(){
						try{
							await Promise.reject('出错了');
						}catch(e){
							console.log(e);//出错了
						}
						return await Promise.resolve('hello');
					}
					f().then(console.log).catch(console.log);//'hello'
				》另一种方法是await后面的Promise对象再跟一个catch方法，处理前面可能出现的错误
					async function f(){
						await Promise.reject('出错了').catch(console.log);//'出错了'
						return await Promise.resolve('hello');
					}
					f().then(console.log);//'hello'
				》如果有多个await命令，可以统一放在try...catch结构中
					async function main(){
						try{
							var val1=await firstStep();
							var val2=await secondStep(val1);
						}catch(err){console.error(err)}
					}
			》如果await后面的异步操作出错，那么等同于async函数返回的Promise对象被reject
				async function f(){
					await new Promise(function(resolve,reject){
						throw new Error('出错了');
					});
				}
				f().then(console.log).catch(console.error)
				》防止出错的方法，也是将其放在try...catch代码块中
					async function f() {
						  try {
						    await new Promise(function (resolve, reject) {
						      throw new Error('出错了');
						    });
						  } catch(e) {
						  }
						  return await('hello world');
					}
		》async函数的实现--就是将Generator函数和自动执行器包装在一个函数里
			async function fn(args){
				//...
			}
			等同于
			function fn(args){
				return spawn(function* (){
					//...
				});
			}
			//自动执行器
			function spawn(genF){
				return new Promise(function(resove,reject){
					var gen=genF();
					function step(nextF){
						try{
							var next=nextF();
						}catch(e){return reject(e)}
						if(next.done){return resolve(next.value)}
						Promise.resolve(next.value).then(function(v){
							step(function(){return gen.next(v)});
						},function(e){
							step(function(){return gen.throw(e)});
						});
					}
					step(function(){return gen.next(undefined)});
				});
			}
		》async函数的用法
			async函数返回一个Promise对象，可以使用then方法添加回调函数。当函数执行的时候，一旦遇到await就会先返回，等到触发的异步操作
			完成，再接着执行函数体内后面的语句。
			async function getStockPriceByName(name){
				var symbol=await getStockSymbol(name);
				var stockPrice=await getStockPrice(symbol);
				return stockPrice;
			}
			getStockPriceByName('good').then(function(result){
				console.log(result);
			});
			》Async函数有多种使用形式
				》函数声明
					async function foo(){...}
				》函数表达式
					const foo=async function(){...}
				》对象的方法
					let obj={
						async foo(){
							...
						}
					}
					obj.foo().then(...);
				》class的方法
					class Storage{
						constructor(){
							this.cachePromise=caches.open('avatars');
						}
						async getAvatar(name){
							const cache=await this.cachePromise;
							return cache.match(`/avatars/${name}.jpg`);
						}
					}
					const storage=new Storage();
					storaget.getAvatar('jake').then(...);
				》箭头函数
					const foo=async ()=>{}
			》注意点
				》第一点
					await命令后面的Promise对象，运行结果可能是rejected，所以最好把await命令放在try...catch代码块中
					async function myfun(){
						try{
							await something();
						}catch(err){
							console.log(err);
						}
					}
					或者
					async function myfun(){
						await something().catch(function(err){
							console.log(err);
						});
					}
				》第二点
					多个await命令后面的异步操作，如果不存在继发关系，最好让它们同时触发
					let foo=await getFoo();
					let bar=await getBar();
					上面代码中，getFoo与getBar是两个独立的异步操作(即互不依赖)，被写成继发关系，这样比较耗时，因为
					只有getFoo完成以后才会执行getBar，完全可以让他们同时触发
					//方式1
					let [foo,bar]=await Promise.all([getFoo(),getBar()]);
					//方式2
					let fooPromise=getFoo();
					let barPromise=getBar();
					let foo=await fooPromise;
					let bar=await barPromise;
				》第三点
					await命令只能用在async函数之中，如果用在普通函数就会报错
					async function dbFuc(db){
						let docs=[{},{},{}];
						//报错
						docs.forEach(function(doc){
							await do.post(doc);
						});
					}
					上面代码会报错，因为await用在普通函数之中了，但是如果将forEach方法的参数改成
					async函数也有问题
					async function dbFuc(db) {
					  let docs = [{}, {}, {}];
					  // 可能得到错误结果
					  docs.forEach(async function (doc) {
					    await db.post(doc);
					  });
					}
					上面代码可能不会正常工作，原因是这时三个db.post操作将是并发执行，也就是同时执行而不是继发执行，正确
					的写法是采用for循环
					async function dbFun(db){
						let docs=[{},{}];
						for(let doc of docs){
							await db.post(doc);
						}
					}
					//如果确实希望多个请求并发执行，可以使用Promise.all方法
						async function dbFuc(db){
							let docs=[{},{}];
							let promises=docs.map(doc=>db.post(doc));
							let results=await Promise.all(promises);
							console.log(result);
						}
						或者
						async function dbFuc(db){
							let docs=[{},{}];
							let promises=docs.map(doc=>db.post(doc));
							let results=[];
							for(let promise of promises){
								results.push(await promise)
							}
							console.log(results);
						}
					ES6将await增加为保留字，使用这个词作为标识符，在ES5是合法的，在ES6将抛出SyntaxError
		》与Promise、Generator的比较
			假定某个DOM元素上面，部署了一系列的动画，前一个动画结束，才能开始后一个。如果当中有一个动画出错，就不在往下执行，返回上一个成功执行的动画的返回值
			》Promise的写法
				function chainAniPromise(elem,anis){
					//ret用来保存上一个动画的返回值
					var ret=null;
					//新建一个空的Promise
					var p=Promise.resolve();
					//使用then方法添加所有动画
					for(var ani of anis){
						p=p.then(function(val){
							ret=val;
							return ani(elem);
						});
					}
					//返回一个部署了错误捕捉机制的Promise
					return p.catch(function(e){
					
					}).then(function(){
						return ret;
					});
				}
				//操作本身的语义不明确
			》Generator函数
				function chainAniPromise(elem,anis){
					return spawn(function*(){
						var ret=null;
						try{
							for(var ani of anis){
								ret=yield ani(elem);
							}
						}catch(e){}
						return ret;
					});
				}
				//必须有一个任务运行器--spawn
				//必须保证yield语句后面的表达式必须返回一个Promise对象
			》Async函数
				async function chainAniPromise(elem,anis){
					var ret=null;
					try{
						for(var ani of anis){
							ret=await ani(elem);
						}
					}catch(e){}
					return ret;
				}
				//最简洁 最符合语义 不需要用户自己提供自动执行器
		》实例--按顺序完成异步操作
			实际开发中，经常遇到一组异步操作，需要按照顺序完成，如，依次远程读取一组URL，然后按照读取的顺序输出结果。
			》Promise写法
				function logOrder(urls){
					//远程读取所有url
					const textPromises=urls.map(url=>{
						return fetch(url).then(response=>response.text());
					});
					//按次序输出
					textPromises.reduce((chain,textPromise)=>{
						return chain.then(()=>textPromise).then(text=>console.log(text))
					},Promise.resolve());
				}
			》async函数实现
				//继发
				async function logInOrder(urls){
					for(const url of urls){
						const response=await fetch(url);
						console.log(await response.text());
					}
				}
				//并发
				async function logInOrder(urls){
					//并发读取远程url
					const textPromises=urls.map(async url=>{
						const response=await fetch(url);
						return response.text();
					});
					//按次序输出
					for(const textPromise of textPromises){
						console.log(await textPromise);
					}
				}
	》异步遍历器
		目前的解决方法是，Generator函数里面的异步操作，返回一个Thunk函数或者Promise对象，即value属性是一个Thunk函数或Promise对象，等待以后返回真正的值，
		而done属性则还是同步产生。
		目前有一个提案，为异步操作提供原生的遍历器接口，即value和done这两个属性都是异步产生--异步遍历器
		》异步遍历器接口
			异步遍历器的最大的语法特点就是调用遍历器的next方法返回的是一个Promise对象
				asyncIterator.next().then(
					({value,done})=>{...}
				)
				上面代码中，asyncIterator是一个异步遍历器，调用next方法以后返回一个Promise对象。因此
				可以使用then方法指定，这个Promise对象的状态变为resolve以后的回调函数。回调函数的参数则是
				一个具有value与done两个属性的对象，这个根同步遍历器是一样的
			》对象的异步遍历器接口部署在Symbol.asyncIterator属性上面。不管是什么样的对象，只要它的Symbol.asyncIterator属性有值
			  就表示应该对他进行异步遍历
				const asyncIterable=createAsyncIterable(['a','b']);
				const asyncIterator=asyncIterable[Symbol.asyncIterator]();
				asyncIterator.next().then(iter1=>{
					console.log(iter1);// { value: 'a', done: false }
					return asyncIterator.next();
				}).then(iter2=>{
					console.log(iter2);// { value: 'b', done: false }
					return asyncIterator.next();
				}).then(iter3=>{
					console.log(iter3);// { value: undefined, done: true }
				});
				//异步遍历器其实返回了两次值，第一次调用的时候，返回一个Promise对象，等到Promise对象resolve了再返回一个
				//表示当前数据成员信息的对象
			》由于异步遍历器的next方法返回的是一个Promise对象，因此可以把它放在await命令后面
				async function f(){
					  const asyncIterable = createAsyncIterable(['a', 'b']);
					  const asyncIterator = asyncIterable[Symbol.asyncIterator]();
					  console.log(await asyncIterator.next());// { value: 'a', done: false }
					  console.log(await asyncIterator.next());// { value: 'b', done: false }
					  console.log(await asyncIterator.next());// { value: undefined, done: true }
				}
			》注意：
				异步遍历器的next方法是可以连续调用的，不必等到上一步产生的Promise对象resolve以后在调用。这种情况下
				next方法会累计起来，自动按照每一步的顺序运行下去
					const asyncGenObj=createAsyncIterator(['a','b']);
					const [{value:v1},{value:v2}]=await Promise.all([asyncGenObj.next(),asyncGenObj.next()]);
					console.log(v1,v2);//a b
				》另一种方法是一次性调用所有的next方法 然后await最后异步操作
					const writer=openFile('someFile.txt');
					writer.next('hello');
					writer.next('world');
					await writer.return();
		》for await...of--用于遍历异步的Iterator接口
			async function f(){
				for await (const x of createAsyncIterable(['a','b'])){
					console.log(x);//a  b
				}
			}
			上面代码中，createAsyncIterator()返回一个异步遍历器，for...of循环自动调用这个遍历器的next方法，会得到一个Promise对象。
			await用来处理这个Promise对象，一旦resolve，就把得到的值x传入for...of的循环体
			》for await...of循环的一个用途是部署了asyncIterator操作的异步接口，可以直接放入这个循环
				let body='';
				for await(const data of req){
					body +=data;
				}
				const parsed=JSON(body);
				console.log('got',parsed);
			》如果next方法返回的Promise对象被reject那么就要用try...catch捕捉
				async function(){
					try{
						for await(const x of createRejectingIterable()){
							console.log(x);
						}
					}catch(e){
						console.error(e);
					}
				}
			》注意：for await...of循环也可以用于同步遍历器
				(async function(){
					for await (const x of ['a','b']){
						console.log(x);//a b
					}
				})();
		》异步Generator函数
			就像Generator函数返回一个同步遍历器对象一样，异步Generator函数的作用是返回一个异步遍历器对象
			在语法上，异步Generator函数就是async函数与Generator函数的结合
				async function* readLines(path){
					let file=await fileOpen(path);
					try{
						while(!file.EOF){
							yield await file.readLine();
						}
					}finally{
						await file.close();
					}
				}
				上面代码中，异步操作前面使用await关键字标明，即await后面的操作应该返回Promise对象。凡是使用yield关键字的地方
				就是next方法的停下来的地方，它后面的表达式即await file.readLine()的值，会作为next返回对象的value属性，这点是于
				同步Generator函数一致的。
				》使用上面代码定义的异步Generator函数
					for await (const line of readLines(filePath)){
						console.log(line);
					}
			》异步Generator函数可以与for await...of循环结合起来使用
				async function* prefixLines(asyncIterable){
					for await (const line of asyncIterable){
						yield '>'+line;
					}
				}
			》yield命令依然是立即返回的，但是返回的是一个Promise对象
				async function* asyncGenerator(){
					console.log('Start');
					const result=await dosomethingAsync();//A
					yield 'Result:'+result;//B
					console.log("Done");
				}
				上面代码中，调用next方法以后，会在B处暂停执行，yield命令立即返回一个Promise对象。这个Promise对象
				不同于A处await命令后面的那个Promise都系。主要有两点不同，一是A处的Promise对象resolve以后产生的值会
				放入result变量；二是B处的Promise对象resolve以后产生的值是表达式'Result:'+result的值，A处Promise对象一定先于
				B处的Promise对象的resolve。
			》如果异步Generator函数抛出错误会被Promise对象reject，然后抛出的错误被catch方法捕获
				async function* asyncGenerator(){
					throw new Error('Proble');
				}
				asyncGenerator().next().catch(err=>console.log(err));//Error:Problem!
			》注意 普通的async函数返回的是一个Promise对象，而异步Generator函数返回的是一个异步Iterator对象。基本上可以这样理解
			       async函数和异步Generator函数是封装异步操作的两种方法，都用来达到同一种目的。区别在于，前者自带执行器，后者通过
			       for await...of执行或者自己编写执行器。
			       》异步Generator函数的执行器
					async function takeAsync(asyncIterable,count=Infinity){
						const result=[];
						const iterator=asyncIterable[Symbol.asyncIterator]();
						while(reult.length<count){
							const {value,done}=await iterator.next();
							if(done)break;
							result.push(value);
						}
						return result;
					}
				》自动执行器实例
					async function f(){
						async function* gen(){
							yield 'a';
							yield 'b';
							yield 'c';
						}
						return await takeAsync(gen());
					}
					f().then(function (result){
						console.log(result);//['a','b','c']
					});
					注意：异步Generator函数出现以后，js就有四种函数形式：普通函数、async函数、Generator函数和异步Generator函数。
				》同步的数据结构也可以使用异步Generator函数
					async function* createAsyncIterable(syncIterable){
						for (const elem of syncIterable){
							yield elem;
						}
					}
			》yield* 语句--也可以跟一个异步遍历器
				async function* gen1(){
					yield 'a';
					yield 'b';
					return 2;
				}
				async function* gen2(){
					const result =yield* gen1();
				}
				》与同步Generator函数一样，for await...of循环会展开yield*。
					(async function(){
						for await (const x of gen2()){
							console.log(x);// a  b
						}
					})();
28.Class
	》Class基本语法
		》概述
			js语言的传统方法是通过构造函数定义并生成新对象。
				function Point(x,y){
					this.x=x;
					this.y=y;
				}
				Point.prototype.toString=function(){
					return '('+this.x+','+this.y+')';
				}
				var p=new Point(1,2);
			ES6提供了更接近传统语言的写法，引入Class(类)的概念，作为对象的模板。通过class关键字，可以定义类。
			基本上ES6的class可以看作一个语法糖，它的绝大部分功能ES5都可以做到，新的class写法只是让对象原型的写法更
			加清晰、更像面向对象编程的语法而已。
				//通过类改写上面代码
				class Point{
					//构造方法--与上面的Point构造函数相对应
					constructor(x,y){
						//this表示实例对象
						this.x=x;
						this.y=y;
					}
					//注意 定义"类"的方法时，前面不需要加function这个关键字，直接把函数定义放进去了就可以了
					//另外方法之间不需要逗号分隔 加了会报错
					toString(){
						return '('+this.x+','+this.y+')';
					}
				}
			》ES6的类完全可以看作构造函数的另一种写法
				class Point{
					...
				}
				typeof Point;//'function'--类的数据类型就是函数
				Point===Point.prototype.constructor;//true--类本身就指向构造函数
			》使用的时候也是直接对类使用new命令，跟构造函数的用法完全一致
				class Bar{
					doStuff(){
						console.log('class');
					}
				}
				new Bar().doStuff();//'class'
			》构造函数的prototype属性，在ES6的"类"上面继续存在。事实上，类的所有方法都定义在类的prototype属性上面
				class Point{
					constructor(){
						...
					}
					toString{...}
					toValue{...}
				}
				//等同于
				Point.prototype={
					toString{...},
					toValue{...}
				}
			》在类的实例上调用方法其实就是在调用原型上的方法
				class B{}
				let b=new B();
				b.constructor===B.prototype.constructor;//true
			》由于类的方法都定义在prototype对象上面，所以类的新方法可以添加在prototype对象上面。
			  Object.assign方法可以很方便的一次向类添加多个方法
				  class Point{
					constructor(){
						...
					}
				  }
				  Object.assign(Point.prototype,{
					toString(){},
					toValue(){}
				  });
			》prototype对象的constructor属性直接指向"类"的本身，这与ES5的行为是一致的
				Point.prototype.constructor===Point;//true
			》类的内部所有定义的方法都是不可枚举的
				class Point{
					constructor(){
						...
					}
					toString(){...}
				}
				Object.keys(Point.prototype);//[]
				Object.getOwnPropertyNames(Point.prototype);//["constructor","toString"]
				上面代码中，toString方法是Point类内部定义的方法，它是不可枚举的，这点与ES5的行为不一致
					//ES5写法--可枚举
					var Point=function(){...}
					Point.prototype.toString=function(){...}
					Object.keys(Point.prototype)// ["toString"]
					Object.getOwnPropertyNames(Point.prototype)// ["constructor","toString"]
			》类的属性名可以采用表达式
				let methodName='getArea';
				class Square{
					[methodName](){
						...
					}
				}
		》constructor方法
			constructor方法是类的默认方法，通过new命令生成对象实例时，自动调用该方法。一个类必须有constructor方法。如果没有
			显示定义，一个空的constructor方法会被默认添加。
				constructor(){}
			》constructor方法默认返回实例对象即this，完全可以指定返回另一个对象
				class Foo{
					constructor(){
						return Object.create(null);
					}
				}
				new FOO() instanceof FOO;//false
			》类的构造函数不使用new是没法调用的，会报错。这是它跟普通构造函数的一个主要区别，后者不用new也可以执行
				class Foo{
					constructor(){
						return Object.create(null);
					}
				}
				Foo();//报错
		》类的实例对象
			生成类的实例对象的写法，与ES5完全一样，也是使用new命令。如果忘记加上new，像函数那样调用class将会报错
				class Point{}
				//报错
				var point =Point();
				//正确
				var point=new Point();
			》与ES5一样，实例属性除非显示定义在其本身(即定义在this对象上)，否则都是定义在原型上(即定义在class上)
				//定义类
				class Point{
					constructor(x,y){
						//定义实例对象自身的属性
						this.x=x;
						this.y=y;
					}
					//定义原型对象上的属性
					toString() {
					        return '(' + this.x + ', ' + this.y + ')';
					}
				}
				var p=new Point(2,3);
				p.hasOwnProperty('x');//true
				p.hasOwnProperty('toString');//false
				p.__proto__.hasOwnProperty('toString');//true
				》与ES5一样 类的所有实例共享一个原型对象
					new Point(2,3).__proto__===new Point(5,6).__proto__;//true
				》可以通过实例的__proto__属性为Class添加方法
					var p1=new Point(2,3);
					var p2=new Point(5,6);
					p1.__proto__.printName=function(){return 'p1'}
					p1.printName();//'p1'
					p2.printName();//'p1'
		》不存在变量提升
			Class不存在变量提升，这点与ES5完全不同
				//报错
				new Foo();
				class Foo{}
				上面代码中Foo类使用在前，定义在后，这样会报错，因为ES6不会把类的声明提升到代码头部。这种规定的原因与
				下文要提到的继承有关，必须保证子类在父类之后定义
					{
						let Foo=class {...};
						class Bar extends Foo{
							...
						}
					}
		》Class表达式
			》与函数一样，类也可以使用表达式的形式定义
				const MyClass=class Me{
					getClassName(){
						return Me.name;
					}
				}
				上面代码使用表达式定义了一个类。需要注意的是，这个类的名字是MyClass而不是Me，Me只是Class的内部代码可用，指代当前类
					let inst=new MyClass();
					inst.getClassName();//Me
					Me.name;//报错
				》如果类的内部没有用到Me，可以省略Me
					const MyClass=class{...}
				》采用Class表达式可以写出立即执行的Class
					let person=new class{
						constructor(name){
							this.name=name;
						}
						sayName(){
							console.log(this.name);
						}
					}('张三');
					person.sayName();//'张三'
		》私有方法
			私有方法是常见需求，但ES6不提供，只能通过变通方法模拟实现
			》一种做法是在命名上加以区别--缺点：在类的外部还是可以调用到这个方法
				class Widget{
					//公有方法
					foo(baz){
						this._bar(baz);
					}
					//私有方法--表示这是一个只限于内部使用的私有方法
					_bar(baz){
						return this.snaf=baz;
					}
				}
			》另一种方法就是索性将私有方法移出模块，因为模块内部的所有方法都是对外可见的
				function bar(baz){
					return this.snaf=baz;
				}
				class Widget{
					foo(baz){
						bar.call(this,baz);
					}
				}
			》还有一种方法是利用Symbol值的唯一性，将私有方法的名字命名为一个Symbol值
				const bar=Symbol('bar');
				const snaf=Symbol('snaf');
				export default class myClass{
					//公有方法
					foo(baz){
						this[bar](baz);
					}
					//私有方法
					[bar](baz){
						return this[snaf]=baz;
					}
				}
				上面代码中，bar和snaf都是Symbol的值，导致第三方无法获取到它们，因此达到了私有方法和私有属性的效果
		》this的指向
			类的方法内部如果含有this，它默认指向类的实例。但是必须小心一旦单独使用该方法时很可能报错
				class Logger{
					print(text){
						console.log(text);	
					}
					printName(name='there'){
						this.print(`Hello ${name}`);
					}
				}
				const logger=new Logger();
				const {printName}=logger;
				printName();//报错  不能够阅读undefined的print属性--因为printName中的this表示Logger实例，此时单独使用没有该实例
				//就无法找到print函数
				》解决上面问题--在构造方法中绑定this，这样就不会找不到print方法了
					class Logger{
						constructor(){
							this.printName=this.printName.bind(this);
						}
						//...
					}
				》另一种解决方法是使用箭头函数
					class Logger{
						constructor(){
							this.printName=(name='there')=>{
								this.print(`Hello ${name}`);
							}
						}
						//...
					}
				》还有一种解决方法是使用Proxy，获取方法的时候 自动绑定this
					function selfish(target){
						const cache=new WeakMap();
						const handler={
							get(target,key){
								const value=Reflect.get(target,key);
								if(typeof value!=='function'){
									return value;
								}
								if(!cache.has(value)){
									cache.set(value,value.bind(target));
								}
								return cache.get(value);
							}
						}
						const proxy=new Proxy(target,handler);
						return proxy;
					}
					const logger=selfish(new Logger());
		》严格模式
			类和模块的内部默认就是严格模式，所以不需要使用use strict指定运行模式。只要你的代码写在类或模块之中，就只有严格模式可用。
			考虑到未来所有的代码其实都是运行在模块之中，所以ES6实际上把整个语言升级到了严格模式
		》name属性
			由于本质上，ES6的类只是ES5的构造函数的一层包装，所以函数的许多特性都被Class继承，包括name属性
			class Point{...}
			Point.name;//'Point'
			name属性总是返回紧跟在class关键字后面的类名
	》Class继承
		》基本用法
			Class之间可以通过extends关键字实现继承，这比ES5的通过修改原型链实现继承要清晰和方便的很多
				class ColorPoint extends Point{
					constructor(x,y,color){
						//调用父类的constructor(x,y);
						super(x,y);
						this.color=color;
					}
					toString(){
						return this.color+" "+super.toString();//调用父类的toString()
					}
				}
				上面代码定义了一个ColorPoint类 该类通过extends关键字继承了Point类的所有属性和方法。
				super关键字，它在这里表示父类的构造函数，用来新建父类的this对象。
				
				注意：子类必须在constructor方法中调用super方法，否则新建实例时会报错。这是因为子类没有
				自己的this对象，而是继承父类的this对象，然后对其进行加工。如果不调用super方法，子类就得
				不到this对象。
				》ES5的继承实质是先创造子类的实例对象this，然后再将父类的方法添加到this上面(Parent.apply(this))。
				  ES6的继承机制完全不同，实质是先创造父类的实例对象this，所以必须先调用super方法，然后再用子类的构造函数
				  修改this。
				》如果子类没有定义constructor方法，这个方法会被默认添加，代码如下。也就是说不管有没有显示定义，任何一个子类都有
				  constructor方法
					constructor(...args){
						super(...args);
					}
				》另一个需要注意的地方是，在子类的构造函数中，只有调用super之后，才可以使用this关键字，否则会报错。
				  这是因为子类实例的构建是基于父类实例加工，只有super方法才能返回父类实例。
					class Point{
						constructor(x,y){
							this.x=x;
							this.y=y;
						}
					}
					class ColorPoint extends Point{
						constructor(x,y,color){
							this.color=color;//ReferenceError
							super(x,y);
							this.color=color;//正确
						}
					}
				》生成子类实例的代码
					let cp=new ColorPoint(25,8,'green');
					cp instanceof ColorPoint;//true
					cp instanceof Point;//true
					上面代码中，实例对象cp同时是ColorPoint和Point两个类的实例，这与ES5的行为完全一致
			》类的prototype属性和__proto__属性
				大多数浏览器的ES5实现中，每一个对象都有__proto__属性，指向对应的构造函数的prototype属性。Class
				作为构造函数的语法糖，同时有prototype属性和__proto__属性，因此同时存在两条继承链
				》子类的__proto__属性，表示构造函数的继承，总是指向父类
					class Point{}
					class ChildExtends extends Point{}
					ChildExtends.__proto__;//Point类
				》子类的prototype属性的__proto__属性，表示方法的继承，总是指向父类的prototype属性
					class A {}
					class B extends A {}
					B.__proto__ === A // true
					B.prototype.__proto__ === A.prototype // true
				》类的继承是按照以下模式实现的
					class A {}
					class B {}
					//B的实例继承A的实例
					Object.setPrototypeOf(B.prototype,A.prototype);
					const b=new B();
					//B的实例继承A的静态属性
					Object.setPrototypeOf(B,A);
					const b=new B();
					//Object.setPrototypeOf方法的实现
					Object.setPrototypeOf=function(obj,proto){
						obj.__proto__=proto;
						return obj;
					}
					因此
					Object.setPrototypeOf(B.prototype,A.prototype);
					//等同于
					B.prototype.__proto__=A.prototype;

					Object.setPrototypeOf(B,A);
					//等同于
					B.__proto__=A;

					Object.creatte(A.prototype);
					//等同于
					B.prototype.__proto__=A.prototype;
			》Extends的继承目标
				extends关键字后面可以跟很多类型的值
					class B extends A{}
					上面代码的A只要是一个有prototype属性的函数，就能被B继承。
					由于函数都有prototype属性(除了Function.prototype函数)，因此A可以是任意函数
				讨论三种特殊情况：
					》第一种特殊情况  子类继承Object类
						class A extends Object{
						
						}
						A.__proto__===Object;//true
						A.prototype.__proto__===Object.prototype;//true
						这种情况下，A其实就是构造函数Object的复制，A的实例就是Object的实例
					》第二种特殊情况  不存在任何继承
						class A{}
						A.__proto__===Function.prototype;//true
						A.prototype.__proto__===Object.prototype;//true
						这种情况下，A作为一个基类 即不存在任何继承 就是一个普通的函数，所以直接继承Function.prototype。
						但是A调用后返回一个空对象即Object实例，所以A.prototype.__proto__指向构造函数Object的prototype属性
					》第三种特殊情况  子类继承null
						class A extends null{}
						A.__proto__===Function.prototype;//true
						A.prototype.__proto===undefined;//true
						这种情况与第二种情况非常像。A也是一个普通的函数，所以直接继承Function.prototype。但是
						A调用后返回的对象不继承任何方法。但是A调用后返回的对象不继承任何方法，所以它的__proto__
						执行Function.prototype。即实质执行了下面的代码
							class c extends null{
								constructor(){
									return Object.create(null);
								}
							}
			》Object.getPrototypeOf()--可以用来从子类上获取父类
				Object.getPrototypeOf('子类名称')==='父类名称'--可以判断一个类是否继承了另一个类
			》super关键字
				super关键字既可以当做函数使用，也可以当做对象使用。在这两种情况下，它的用法完全不同。
				》第一种情况，super作为函数调用时，代表父类的构造函数。ES6要求，子类的构造函数必须执行一次super函数
					class A{}
					class B extends A{
						constructor(){
							super();//调用父类的构造函数--这是必须的  否则js引擎报错
						}
					}
					注意：super虽然代表了父类A的构造函数，但是返回的是子类B的实例，即super内部的this指的是B
					      因此super()在这里相当于A.prototype.constructor.call(this);
					      class A{
						constructor(){
							console.log(new.target.name);//new.target指向当前正在执行的函数
						}
					      }
					      class B extends A{
						constructor(){
							super();
						}
					      }
					      new A();//A
					      new B();//B
					  》作为函数时，super只能用在子类的构造函数之中，用在其他地方就会报错
						class A{}
						class B extends A{
							m(){
								super();//报错
							}
						}
				》第二种情况 super作为对象时，指向父类的原型对象
					class A{
						p(){
							return 2;
						}
					}
					class B extends A{
						constructor(){
							super();
							console.log(super.p());//2
						}
					}
					注意：由于super指向父类的原型对象，所以定义在父类实例上的方法或属性是无法通过super调用
						class A{
							constructor(){
								this.p=2;//A的实例属性 super.p就引用不到它
							}
						}
						class B extends A{
							get m(){
								return super.p;
							}
						}
						new B().m//undefined
						》如果属性定义在父类的原型对象上，super就可以取到
							class A{}
							A.prototype.x=2;
							class B extends A{
								constructor(){
									super();
									console.log(super.x);//2
								}
							}
						》ES6规定通过super调用父类的方式时，super会绑定子类的this
							class A{
								constructor(){
									this.x=1;
								}
								print(){
									console.log(this.x);
								}
							}
							class B extends A{
								constructor(){
									super();
									this.x=2;
								}
								m(){
									super.print();
									//实际上执行的是super.print.call(this);
								}
							}
							new B().m();//2
						》由于绑定了子类的this，所以如果通过super对某个属性赋值，这时super就是this，赋值的属性会变成子类
						  实例的属性。
						  class A{
							constructor(){
								this.x=1;
							}
						  }
						  class B extends A{
							constructor(){
								super();
								this.x=2;
								super.x=3;
								console.log(super.x);//undefined
								console.log(this.x);//3
							}
						  }
						 》注意使用super的时候，必须**显示**指定是作为函数还是作为对象使用否则会报错
							class A{}
							class B extends A{
								constructor(){
									super();
									console.log(super);//报错
								}
							}
						  》由于对象总是继承其他对象的，所以可以在任意一个对象中，使用super关键字
							var obj={
								toString(){
									return 'MyObject:'+super.toString();
								}
							}
							obj.toString(); // MyObject: [object Object]
			》实例的__proto__属性
				子类实例的__proto__属性的__proto__属性，指向父类实例的__proto__属性。也就是说子类的原型的原型是父类的原型
				var p1=new Point(2,3);
				var p2=new ColorPoint(2,3,'red');
				p2.__proto__===p1.__proto__;//false
				p2.__proto__.__proto__===p1.__proto__;//true
				》因此通过子类实例的__proto__.__proto__属性，可以修改父类实例的行为
					p2.__proto__.__proto__.printName=function(){
						console.log('Ha');
					}
					p1.printName();//'Ha'
	》原生构造函数的继承
		原生构造函数是指语言内置的构造函数，通常用来生成数据结构。
		ECMAScript的原生构造函数：
			》Boolean()
			》Number()
			》String()
			》Array()
			》Date()
			》Function()
			》RegExp()
			》Error()
			》Object()
			以前这些原生构造函数是无法继承的，如不能自己定义一个Array的子类
				function MyArray(){
					Array.applay(this,arguments);
				}
				MyArray.prototype=Object.create(Array.prototype,{
					constructor:{
						value:MyArray,
						writable:true,
						configurable:true,
						enumerable:true
					}
				});
				上面代码定义了一个继承Array的MyArray类，但是这个类的行为与Array完全不一致
					var colors=new MyArray();
					colors[0]='red';
					colors.length;//0
					colors.length=0;
					colors[0];//'red'
					之所以会发生这种情况，是因为子类无法获取原生构造函数的内部属性，通过Array.apply()或者分配给
					原型对象都不行。原生构造函数会忽略apply方法传入的this，也就是说，原生构造函数的this无法绑定，导致
					拿不到内部属性。
					ES5是先新建子类的实例对象this，再将父类的属性添加到子类上，由于父类的内部属性无法获取，导致无法继承原生
					的构造函数。
				》让一个普通对象继承Error对象实例
					var e={}
					Object.getOwnPropertyNames(Error.call(e));//['stack']
					Object.getOwnPropertyNames(e);//[]
					上面代码中我们想通过Error.call(e)这种写法，让普通对象e具有Error对象的实例属性。但是Error.call()完全忽略
					了传入的第一个参数，而是返回一个新的对象，e本身没有任何变化。这证明了Error.call(e)这种写法无法继承原生构造
					函数。
			》Es6允许继承原生构造函数定义子类，因为ES6是先新建父类的实例对象this，然后在用子类的构造函数修饰this，使得父类的所有行为
			  都可以继承。
				//继承Array的实例
					class MyArray extends Array{
						constructor(...args){
							super(...args);
						}
					}
					var arr=new MyArray();
					arr[0]=12;
					arr.length;//1
					arr.length=0;
					arr[0];//undefined
					//上面代码意味着，ES6可以自定义原生数据结构的子类，这是ES5无法做到的
				//上面代码也说明，extends关键字不仅可以用来继承类，还可以用来继承原生的构造函数。因此
				//可以在原生数据结构的基础上，定义自己的数据结构
					//如定义一个带有版本功能的数组
					class VersiondArray extends Array{
						constructor(){
							super();
							this.history=[[]];
						}
						commit(){
							this.history.push(this.slice());
						}
						revert(){
							this.splice(0,this.length,...this.history[this.history.length-1]);
						}
					}
					var x=new VersiondArray();
					x.push(1);
					x.push(2);
					x;//[1,2]
					x.history;//[[]]
					x.commit();
					x.history;//[[],[1,2]]
					x.push(3);
					x;//[1,2,3]
					x.revert();
					x;//[1,2]
					//转成ES5之后可能会报错
			》注意继承Object的子类有一个行为差异
				class NewObj extends Object{
					constructor(){
						super(...arguments);
					}
				}
				var o=new NewObj({attr:true});
				console.log(o.attr===true);//false
				上面代码中，NewObj继承了Object，但是无法通过super方法向父类Object传递参数。这是因为
				ES6改变了Object构造函数的行为，一旦发现Object方法不是通过new Object()这种形式调用，ES6
				规定Object构造函数会忽略参数。
	》Class的取值函数和存值函数
		》与ES5一样，在Class内部可以使用get和set关键字，对某个属性设置存值函数和取值函数，拦截该属性的存取行为。
			class MyClass{
				get prop(){
					return 'getter';
				}
				set prop(value){
					console.log('setter:'+value);
				}
			}
			let inst=new MyClass();
			inst.prop=123;//setter:123
			inst.prop;//'getter'
		》存值函数和取值函数是设置在属性的descriptor对象上
			class CustomHTMLElement{
				constructor(elem){
					this.elem=elem;
				}
				get html(){
					return this.elem.innerHTMl;
				}
				set html(value){
					this.elem.innerHTMl=value
				}
			}
			var descriptor=Object.getOwnPropertyDescriptor(CustomHTMLElement.prototype,'html');
			'get' in descriptor;//true
			'set' in descriptor;//true
	》Class的Generator方法
		》如果某个方法之前加上星号(*),就表示该方法是一个Generator函数
			class Foo{
				constructor(...args){
					this.args=args;
				}
				//返回一个Foo类的默认遍历器
				* [Symbol.iterator](){
					for(let arg of this.args){
						yield arg;
					}
				}
			}
			for(let x of new Foo('hello','world')){//自动调用定义的遍历器
				console.log(x);
			}
	》Class的静态方法
		》类相当于实例的原型，所有在类中定义的方法，都会被实例继承。如果在一个方法前，加上static关键子，就表示该
		  方法不会被实例继承，而是直接通过类来调用，这就称为'静态方法'。
			class Foo{
				//静态方法
				static classMethod(){
					return 'hello';
				}
			}
			//通过类调用静态方法
			Foo.classMethod();//'hello'
			var foo=new Foo();
			//在实例上调用静态方法，会抛出错误，表示不存在该方法
			foo.classMethod();//Uncaught TypeError: foo.classMethod is not a function
		》父类的静态方法，可以被子类继承
			class Foo{
				static classMethod(){
					return '静态方法的继承';
				}
			}
			class Bar extends Foo{}
			Bar.classMethod();//'静态方法的继承'
		》静态方法也是可以从super对象调用的
			class Foo{
				static classMethod(){
					return 'hello';
				}
			}
			class Bar extends Foo{
				static classMethod(){
					return super.classMethod()+',too';
				}
			}
			Bar.classMethod();//hello,too
	》Class的静态属性和实例属性
		》静态属性指的是Class本身的属性，即Class.propname,而不是定义在实例对象(this)上的属性
			class Foo{}
			Foo.prop=1;
			Foo.prop;//1
			上面的写法为Foo类定义了一个静态属性prop
		》目前，只有上面这种写法可行，因为ES6明确规定，Class内部只有静态方法，没有静态属性
			//一下两种写法都是无效的
			class Foo{
				//写法1
				prop:2
				//写法2
				static prop:2
			}
			Foo.prop;//undefined
		》ES7有一个静态属性的提案，目前babel转码器支持
			》类的实例属性--用等式写入类的定义之中
				class MyClass{
					//实例属性
					myProp=42;
					constructor(){
						console.log(this.myProp);//42
					}
				}
				//以前我们定义实例属性，只能写在类的constructor方法里面
				class ReactCounter extends React.Component{
					constructor(props){
						super(props);
						//定义实例属性
						this.state={
							count:0
						}
					}
				}
				//现在定义实例属性
				class ReactCounter extends React.Component{
					state={
						count:0
					}
				}
				//为了可读性的目的，对于那些在constructor里面已经定义的实例属性，新写法允许直接列出
				class ReactCounter extends React.Component{
					constructor(props){
						super(props);
						this.state={
							count:0
						}
					}
					state;
				}
			》类的静态属性
				》类的静态属性只要在上面的实例属性写法前面，加上static关键字就可以了
					class MyClass{
						static myStaticProp=42;
						constructor(){
							console.log(MyClass.myProp);//42
						}
					}
					//同样的，这个新写法大大方便了静态属性的表达式
						//老写法
						class Foo{}
						Foo.prop=1;
						//新写法
						class Foo{
							static prop=1;
						}
	》类的私有属性
		目前，有一个提案，为class加了私有属性。方法是在属性名之前使用#表示
			class Point{
				#x;//表示私有属性x
				constructor(x=0){
					#x=+x;
				}
				get x(){
					return #x;
				}
				set x(value){
					#x=+value;
				}
			}
			》私有属性可以指定初始值，在构造函数执行时进行初始化
				class Point{
					#x=0;
					constructor(){
						#x;
					}
				}
				之所以要引入一个新的前缀#表示私有属性，而没有采用private关键字，是因为js是一门动态语言，使用独立的符号
				似乎是唯一可靠的方法，能够准确的区分一个属性是私有属性。另外Ruby语言使用 @ 表示私有属性，ES6没有用这个
				符号而是使用#，是因为 @ 已经留给了Decorator
			》该提案只规定了私有属性的写法。但是很自然的，它也可以用来写私有方法
				class Foo{
					#a;
					#b;
					#sum(){
						return #a+#b;
					}
					printSum(){
						console.log(#sum());
					}
					constructor(a,b){
						#a=a;
						#b=b;
					}
				}
	》new.target属性
		》new是从构造函数生成实例的命令。ES6为new命令引入了一个new.target属性，在构造函数中返回new命令作用于的那个构造函数
		  如果构造函数不是通过new命令调用的，new.target会返回undefined，因此这个属性可以用来确定构造函数是怎么调用的
			function Person(name){
				if(new.target !== undefined){
					this.name=name;
				}else{
					throw new Error("必须使用new生成实例");
				}
			}
			//另一种写法
			function Person(name){
				if(name.target === Person){
					this.name=name;
				}else{
					throw new Error("必须使用new生成实例");
				}
			}
			var person=new Person('张三');//正确
			var notAPerson=Person.call(person,'张三');//报错
			上面地面确保构造函数只能通过new命令调用
		》class内部调用new.target，返回当前class
			class Rectangle{
				constructor(length,width){
					console.log(new.target===Rectangle);
					this.length=length;
					this.width=width;
				}
			}
			var obj=new Rectangle(3,4);//true
		》子类继承父类时，new.target会返回子类
			class Rectangle{
				constructor(length,width){
					console.log(new.target===Rectangle);
				}
			}
			class Square extends Rectangle{
				constructor(length){
					super(length,length);
				}
			}
			var obj=new Square(3);//false
			》利用这个特点，可以写出不能独立使用，必须继承后才能使用的类
				//Shape类不能被实例化，只能用于继承
				class Shape{
					constructor(){
						if(new.target === Shape){
							throw new Error('本类不能实例化');
						}
					}
				}
				class Rectangle extends Shape{
					constructor(length,width){
						super();
						...
					}
				}
				new Shape();//报错
				new Rectangle(3,4);//正确
		》注意：在函数外部使用new.target会报错
	》Mixin模式的实现
		》Mixin模式指的是，将多个类的接口"混入mixin"另一个类。它在ES6的实现如下
			function mix (...mixins){
				class Min{}
				for(let mixin of mixins){
					copyProperties(Min,mixin);
					copyProperties(Min.prototype,mixin.prototype);
				}
				return Min;
			}
			function copyProperties(target,source){
				for(let key of Reflect.ownKeys(source)){
					if(
						key !== 'constructor'&&
						key !== 'prototype' &&
						key !== 'name'
					){
						let desc=Object.getOwnPropertyDescriptor(source,key);
						Object.defineProperty(target,key,desc);
					}
				}
			}
			//上面的代码min函数，可以将多个对象合成一个类。使用的时候只要继承这个类即可
			class DistributeEdit extends min(a,b){//min(a,b)返回的是一个类
			
			}
29.Decorator			
	》类的修饰
		修饰器(Decorator)是一个函数，用来修改类的行为。这是ES7的一个提案，目前Babel转码器已经支持。
		修饰器对类的行为的改变是代码编译时发生的，而不是在运行时。这意味着修饰器能在编译阶段运行代码。
		function testable(target){
			target.isTestable=true;
		}
		@testable
		class MyTestableClass{}
		console.log(MyTestableClass.isTestable);//true
		上面代码中， @testable就是一个修饰器。它修改了MyTestableClass这个类的行为，为它加上了静态属性isTestable
		》基本上，修饰器的行为就是下面这样
			@decorator
			class A{}
			//等同于
			class A{}
			A=decorator(A) || A;
			也就是说，修饰器本质就是**编译时执行的函数**
		》修饰器函数的第一个参数就是所要修饰的目标类
			function testable(target){//target--目标类
			
			}
			》如果觉得一个参数不够用，可以在修饰器外面再封装一层函数。
				function testable(isTestable){
					return function (target){
						target.isTestable=isTestable;
					}
				}
				@testable(true)
				class MyTestableClass{}
				MyTestableClass.isTestable//true

				@testable(false)
				class MyClass {}
				MyClass.isTestable // false
			》前面的例子是为类添加一个静态属性，如果想添加实例属性，可以通过目标类的prototype对象操作
				function testable(target){
					target.prototype.isTestable=true;
				}
				@testable
				class MyTestableClass{}
				new MyTestableClass().isTestable;//true
			》案例
				//mixins.js
				export function mixins(...list){
					return function(target){
						Object.assign(target.prototype,...list);
					}
				}
				//main.js
				import {mixins} from './mixins'

				const Foo={
					foo(){
						console.log('foo');
					}
				}

				@mixins(Foo)
				class MyClass{}

				new MyClass().foo();//'foo'
				上面代码通过修饰器mixins,把Foo类的方法添加到了MyClass的实例上面。可以通过Object.assign()模拟这个功能
					const Foo={
						foo(){console.log('foo')}
					}
					class MyClass{}
					Object.assign(MyClass.prototype,Foo);
					let obj=new MyClass();
					obj.foo();//'foo'
	》方法的修饰
		修饰器不仅可以修饰类，还可以修饰**类的属性**
		class Person{
			@readonly
			name(){return `${this.first} ${this.last}`}
		}
		上面代码中，修饰器readonly用来修饰类的name方法
		此时，修饰器函数一个可以接受三个参数，第一个参数是所要修饰的目标对象，第二个参数是所要修饰的属性名，第三个参数是该属性的描述对象
		function readonly(target,name,descriptor){
			descriptor.writable=false;
			return descriptor;
		}
		readonly(Person.prototype,'name',descriptor);
		//类似于
		Object.defineProperty(Person.prototype,'name',descriptor);
		》案例--修改属性的描述对象的enumerable属性，使得该属性不可遍历
			class Person{
				@nonenumerable
				get kidCount(){
					return this.children.length;
				}
			}
			function nonenumerable(target,name,descriptor){
				descriptor.enumerable=false;
				return descriptor;
			}
		》 @log修饰器，可以起到输出日志的作用
			class Math{
				@log
				add(a,b){
					return a+b;
				}
			}
			function log(target,name,descriptor){
				var oldValue=descriptor.value;
				descriptor.value=function(){
					console.log(`Calling "${name}" with`,arguments);
					return oldValue.apply(null,arguments);
				}
				return descriptor;
			}
			new Math().add(2,4);
			//上面代码中， @log修饰器的作用就是在执行原始的操作之前，执行一次console.log,从而达到输出日志的目的
		》修饰器有注释的作用
			@testable
			class Person{
				@readonly
				@nonenumerable
				name(){
					return `${this.first} ${this.last}`;
				}
			}
			从上面代码中，我们一眼就能看出，Person类是可测试的，而name方法是只读和不可枚举的
		》如果同一方法有多个修饰器，先从外到内进入，然后由内向外执行
			function dec(id){
				console.log(`evaluated`,id);
				return (target,property,descriptor)=>console.log('executed',id);
			}
			class Example {
			    @dec(1)
			    @dec(2)
			    method(){}
			}
			// evaluated 1
			// evaluated 2
			// executed 2
			// executed 1
			除了注释，修饰器还能用来类型检查，所以，对于类来说，这项功能相当有用。从长期来看，它将是js代码静态分析的重要工具。
	》为什么修饰器不能用于函数
		修饰器只能用于类和类的方法，不能用于函数，因为存在函数提升
		var counter=0；
		var add=function(){
			counter++;
		}
		@add
		function foo(){}
		上面代码意图是执行后counter等于1，但是实际上结果是counter等于0，因为函数提升使得实际执行的代码如下
			@add
			function foo(){}
			var counter;
			var add;
			counter=0;
			add=function(){
				counter++;
			}
		》案例
			var readonly=require('some-decorator');
			@readOnly
			function foo(){}
			//实际执行如下
			var readonly;
			@readOnly
			function foo(){}
			readonly=require('some-decorator');
		总之，由于存在函数提升，使得修饰器不能用于函数。类是不会提升的，所以就没有这方面的问题。
	》core-decorator.js--是一个第三方模块，提供了几个常见的修饰器，通过它们可以更好地理解修饰器
		》 @autobind
		   autobind修饰器使得方法中的this对象，绑定原始对象
		   import {autobind} from 'core-decorators';
		   class Person{
			@autobind
			getPerson(){
				return this;
			}
		   }
		   let person=new Person();
		   let getPerson=person.getPerson;
		   getPerson()===person;//true
		》 @readonly
		   readonly修饰器使得属性或方法不可写
		   import {readonly} from 'core-decorators';
		   class Meal{
			@readonly
			entree='steak';
		   }
		   var dinner=new Meal();
		   dinner.entree='salmon';// Cannot assign to read only property 'entree' of [object Object]
		》 @override
		   override修饰器检查子类的方法，是否正确覆盖了父类的同名方法，如果不正确会报错
		   import {override} from 'core-decorators';
		   class Parent{
			speak(first,second){}
		   }
		   class Child extends Parent{
			@override
			speak(){}// SyntaxError: Child#speak() does not properly override Parent#speak(first, second)
		   }
		》 @deprecate(别名 @deprecated)
		   deprecate或deprecated修饰器在控制台显示一条警告，表示方法将废除
		   import {deprecate} from 'core-decorators';
		   class Person{
			@deprecate
			facepalm(){}

			@deprecate('We stopped facepalming')
			facepalmHard(){}

			@deprecate('We stopped facepalming', { url: 'http://knowyourmeme.com/memes/facepalm' })
			facepalmHard(){}
		   }
		   let person = new Person();
		   person.facepalm();
		   // DEPRECATION Person#facepalm: This function will be removed in future versions.
		   person.facepalmHard();
		   // DEPRECATION Person#facepalmHard: We stopped facepalming
		   person.facepalmHarder();
		   // DEPRECATION Person#facepalmHarder: We stopped facepalming
		   //     See http://knowyourmeme.com/memes/facepalm for more details.
		》 @suppressWarning
		   suppressWarning修饰器抑制decorated修饰器导致的console.warn()调用。但是异步代码发出的调用除外
		   import {suppressWarnings} from 'core-decorators';
		   class Person{
			@deprecated
			facepalm(){}

			@suppressWarning
			facepalmWithpoutWarning(){
				this.facepalm();
			}
		   }
		   let person=new Person();
		   person.facepalmWithpoutWarning();//无警告信息输出
	》使用修饰器实现自动发布事件
		我们可以使用修饰器，使得对象的方法被调用时，自动发出一个事件
		import postal from 'postal/lib/postal.lodash';
		export default function publish(topic,channel){
			return function (target,name,descriptor){
				const fn=descriptor.value;
				descriptor.value=function(){
					let value=fn.apply(this,arguments);
					postal.channel(channel||target.channel||"/").publish(topic,value);
				}
			}
		}
		上面代码定义了一个名为publish的修饰器，它通过改写descriptor.value，使得原方法被调用时，会自动发出一个事件。它使用的事件"发布/订阅"库是Postal.js
		//它的用法如下
		class FooComponent{
			@publish('foo.some.message','component')
			someMethod(){
				return {
					my:"data"
				}
			}
			@publish('foo.some.other')
			anotherMethod(){
				//...
			}
		}
		//以后只要调用someMethod或者anotherMethod就会自动发出一个事件
		let foo=new FooComponent();
		foo.someMethod() // 在"component"频道发布"foo.some.message"事件，附带的数据是{ my: "data" }
		foo.anotherMethod() // 在"/"频道发布"foo.some.other"事件，不附带数据
	》Mixin
		在修饰器的基础上，可以实现Mixin模式。所谓Mixin模式，就是对象继承的一种替代方案。意为在一个对象之中混入另外一个对象的方法
		》案例
			const Foo={
				foo(){console.log('foo')}
			}
			class MyClass{}
			//将foo方法混入MyClass类
			Object.assign(MyClass.prototype,Foo);
			let obj=new MyClass();
			obj.foo();//'foo'
		》部署一个通用脚本mixins.js，将mixin写成一个修饰器
			export function mixins(...list){
				return function(target){
					Object.assign(target.prototype,...list);
				}
			}
			//使用上面修饰器，为类混入各种方法
			import {mixins} from './mixins';
			const Foo={
				foo(){
					console.log('foo');
				}
			}
			@mixins(Foo)
			class MyClass{}
			let obj=new MyClass();
			obj.foo();//'foo'
			//不过上面方法会改写MyClass类的prototype对象，如果不喜欢这一点，也可以通过类的继承实现mixin
			class MyClass extends MyBaseClass{
				//...
			}
			//上面代码中，MyClass继承了MyBaseClass。如果我们想在MyClass里面混入一个foo方法，一个办法是在MyClass和MyBaseClass
			//之间插入一个混入类，这类具有foo方法，并且继承了MyBaseClass的所有方法，然后MyClass在继承这个类
			let MyMixin=(superclass)=>class extends superclass{
				foo(){
					console.log('foo from MyMixin');
				}
			}
			上面代码中，MyMixin是一个混入类生成器，接受superclass作为参数，然后返回一个继承superclass的子类，该子类包含一个foo方法
			//接着，目标类再去继承这个混入类，就达到了混入foo方法的目的
			class MyClass extends MyMixin(MyBaseClass){
				...
			}
			let c=new MyClass();
			c.foo();//'foo from MyMixin'
			//如果需要混入多个方法，就需要生成多个混入类
			class MyClass extends Mixin1(Mixin2(MyBaseClass)){
				...
			}
			这种写法的好处是可以调用super，因此可以避免在混入过程中覆盖父类的同名方法
			let Mixin1=(superclass)=>class extends superclass{
				foo(){
					console.log(`foo from Mixin1`);
					if(super.foo) super.foo();
				}
			}
			let Mixin2=(superclass)=>class extends superclass{
				foo(){
					console.log(`foo from Mixin2`);
					if(super.foo) super.foo();
				}
			}
			class s{
				foo(){
					console.log(`foo from s`);
				}
			}
			class c extends Mixin1(Mixin2(s)){
				foo(){
					console.log(`foo from c`);
					super.foo();
				}
			}
			new C().foo()
			// foo from C
			// foo from Mixin1
			// foo from Mixin2
			// foo from S
			上面代码中，每一次混入发生时，都调用了父类的super.foo方法，导致父类的同名方法没有被覆盖，行为被保留了下来
	》Trait
		Trait也是一种修饰器，效果与Mixin类似，但是提供更多功能，比如防止同名方法的冲突，排除混入某些方法，为混入的方法起别名等等
		import {traits} from 'traits-decorator';//traits-decorator第三方模块提供了traits修饰器，不仅可以接受对象，还可以接受ES6类作为参数
		class TFoo{foo(){console.log('foo')}}
		const TBar={
			bar(){
				console.log('bar');
			}
		}
		@traits(TFoo,TBar)
		class MyClass{}
		let obj=new MyClass();
		obj.foo();//foo
		obj.bar();//bar
		》Trait不允许混入同名方法
			import {traits} from 'traits-decorator';
			class TFoo{
				foo(){
					console.log('foo')
				}
			}
			const TBar={
				bar(){
					console.log('bar')
				}
				foo(){
					console.log('foo')
				}
			}
			@traits(TFoo,TBar)
			class MyClass{}//报错--Error: Method named: foo is defined twice.
			上面代码中TFoo与TBar都有foo方法，结果traits修饰器报错
			》一种解决方法是排除TBar中的foo方法
				import {traits,excludes} from 'traits-decorator';
				class TFoo{
					foo(){}
				}
				const TBar={
					bar(){}
					foo(){}
				}
				//使用绑定运算符(::)在TBar上排除foo方法
				@traits(TFoo,TBar::excludes('foo'))
				clas MyClass{}
			》另一种方法是为TBar的foo方法起一个别名
				import {traits,alias} from 'traits-decorator';
				class TFoo{
					foo(){console.log('foo')}
				}
				const TBar={
					bar(){console.log('bar')}
					foo(){console.log('foo')}
				}
				@traits(TFoo,TBar::alias({foo:"aliasFoo"}));
				class MyClass{}
				let obj=new MyClass();
				obj.foo();//foo
				obj.aliasFoo();//foo
			》alias和excludes方法可以结合起来使用
				@traits(TExample::excludes('foo','bar')::alias({baz:"exampleBaz"}))
				class MyClass{}
				//as方法则为上面代码提供了另一种写法
				@traits(TExample::as({excludes:['foo','bar'],alias:{baz:"exampleBaz"}}))
				class MyClass{}
	》Babel转码器的支持
		目前Babel转码器已经支持Decorator
		》首先安装babel-core和babel-plugin-transform-decorators由于后者包括在babel-preset-stage-0之中，所以改为安装babel-preset-stage-0亦可。
		  $ npm install babel-core babel-plugin-transform-decorators
		》然后设置配置文件.babelrc
			{
			  "plugins": ["transform-decorators"]
			}
		》脚本中打开的命令如下
			babel.transform("code", {plugins: ["transform-decorators"]})
			注意：Babel的官方网站提供一个在线转码器，只要勾选Experimental，就能支持Decorator的在线转码。
30.Module
	在ES6之前，社区制定了一些模块加载方案，最主要的有commonJs和AMD两种，前者用于服务器，后者用于浏览器。ES6在语言
	标准的层面上，实现了模块功能，而且实现的相当简单，完全可以取代现有的commonJs和AMD规范，成为浏览器和服务器通用
	的模块解决方案。
	ES6模块的设计思想，是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。CommonJs和AMD模块，
	都只能在运行时确定这些东西。如：CommonJs模块就是对象，输入时必须查找对象属性。
		//CommonJs模块--整体加载fs模块，即加载fs的所有方法，生成一个对象_fs,然后再从这个对象上面读取方法--运行时加载
		//因为只有运行时才能得到这个对象，导致完全没有办法在编译时做"静态优化"
		let {stat,exists}=require('fs');
		//等同于
		let _fs=require('fs');
		let stat=_fs.stat;
		let exists=_fs.exists;
	ES6模块不是对象而是通过export命令显示指定输出的代码，在通过import命令输入。
		//ES6模块
		import {stat,exists} from 'fs';
		上面代码的实质是从fs模块加载3个方法，其他方法不加载--这种加载称为"编译时加载"或静态加载
		即ES6可以在编译时就完成模块加载，效率要比CommonJs模块的加载方式高。当然，这也导致没法引入ES6模块本身，因为它不是对象
		由于ES6模块是编译时加载，使得静态分析成为可能。有了它，就能进一步拓宽js语言，比如引入宏macro和类型检验type system这些只能靠
		静态分析实现的功能
		除了静态加载带来的各种好处，ES6模块还有以下好处。
			》不在需要UMD模块格式了，将来服务器和浏览器都会支持ES6模块格式。目前，通过各种工具库，其实已经做到了这点
			》将来浏览器的新API就能用模块格式提供，不再必须做成全局变量或者navigator对象的属性
			》不再需要对象作为命名空间如Math对象，未来这些功能可以通过模块提供
	》严格模式
		ES6的模块自动采用严格模块，不管你有没有在模块头部加上"use strict";
		严格模式主要有以下限制：
			》变量必须声明后再使用
			》函数的参数不能有同名属性，否则报错
			》不能使用with语句
			》不能对只读属性赋值，否则报错
			》不能使用前缀0表示八进制数，否则报错
			》不能删除不可删除的属性，否则报错
			》不能删除变量delete prop，会报错，只能删除属性delete global[prop];
			》eval不会在它的外层作用域引入变量
			》eval和arguments不能被重新赋值
			》arguments不会自动反应函数参数的变化
			》不能使用arguments.callee
			》不能使用arguments.caller
			》禁止this指向全局对象--ES6模块中，顶层的this指向undefined，即不应该在顶层代码使用this
			》不能使用fn.caller和fn.arguments获取函数调用的堆栈
			》增加了保留字如protected static interface
	》export命令
		模块功能主要由两个命令构成：export和import。export命令用于规定模块的对外接口，import命令用于输入其他模块提供的功能
		一个模块就是一个独立的文件，该文件内部的所有变量，外部无法获取。如果你希望外部能够读取模块内部的某个变量。就必须使用
		export关键字输出该变量。
			//profile.js--ES6将该文件视为一个模块，里面用export命令对外部输出两个变量
			export var firstName='Michael';
			export var lastName='Jackson';
			//export的写法，除了上面的写法还有另外一种
			var firstName='Michael';
			var lastName='Jackson';
			export {firstName,lastName};//使用大括号指定所要输出的一组变量。它与前一种写法(直接放置在var语句前)是等价的，但是应该
			优先考虑使用这种写法。因为这样就可以在脚本尾部，看清输出了那些变量。
			》export命令除了输出变量还可以输出函数或类
				export function multiply(x,y){//对外输出一个函数multiply
					return x*y;
				}
			》通常情况下，export输出的变量就是本来的名字，但是可以使用as关键重命名
				function v1(){}
				export{
					v1 as streamV1
				}
				上面代码使用as关键字，重命令了函数，重命名后，v1可以用不同的名字输出两次
			》注意：export命令规定的是对外的接口，必须与模块内部的变量建立一一对应的关系
				export 1;//报错
				var m=1;
				export m;//报错
				》正确写法
					//方式1
					export var m=1;
					//方式2
					var m=1;
					export {m};
					//方式3
					var n=1;
					export {n as m}
					//同样function与class的输出，也必须遵守这样的写法
			》export语句输出的接口，与其对应的值是动态绑定关系，即通过该接口可以取到模块内部实际的值
				export var foo='bar';
				setTimeout(()=>foo='baz',500);
				上面代码输出变量foo，值为bar，500ms之后变成baz
				这点与CommonJs规范完全不同。CommonJs模块输出的是值的缓存，不存在动态更新
			》最后 export命令可以出现在模块的任何位置，只要是处于模块顶层就可以。如果处于块级作用域内就会报错，import命令也是如此。这是
			  因为处于条件代码块之中，就没法做静态优化了，违背了ES6模块的设计初衷。
				function foo(){
					export default 'bar';//报错
				}
				foo();
	》import命令
		使用export命令定义了模块的对外接口以后，其他Js文件可以通过import命令加载这个模块
		//main.js
		import {firstName,lastName} from './profile';
		console.log(firstName,lastName);//'Michael' 'Jackson'
		上面代码的import命令，用于加载profile.js，并从中输入变量。import命令接受一对大括号，里面指定要从其他模块导入的变量名，大括号里面
		的变量名**必须与被导入模块profile.js对外接口的名称相同**
		》如果想要为输入的变量重新取一个名字，import命令要使用as关键字，将输入的变量重命名
			import {lastName as surname} from "./profile";
			import后面的from指定模块文件的位置，可以是相对路径也可以是绝对路径，".js"路径可以省略。如果只是模块名，不带有路径，那么必须
			有配置文件告诉js引擎该模块的位置
				import {myMethod} from "util";//只有模块文件名，必须通过配置告诉引擎怎么取到这个模块
		》注意：import命令具有提升效果，会提升到整个模块的头部，首先执行
			foo();
			import{foo} from 'my_module';
			上面的代码不会报错，因为import的执行早于foo的调用。这种行为的本质是import命令是编译阶段执行的，在代码运行之前
		》由于import 是静态执行，所以不能使用表达式和变量。这些只有在运行时才能得到的结果的语法结构
			》import {'f'+'oo'} from 'my_module';//报错
			》let module ='my_module';
			  import {foo} from module;//报错
			》// 报错
			  if (x === 1) {
			    import { foo } from 'module1';
			  } else {
			    import { foo } from 'module2';
			  }
		》最后 import语句会执行所加载的模块，因此可以有下面的写法
			import 'lodash';//仅仅执行lodash模块，但是不输入任何值
		》如果多次重复执行同一句import语句，那么只会执行一次，而不会执行多次
			import 'lodash';
			import 'lodash';//加载了两次，只执行一次
		》import {foo} from 'my_module';
		  import {bar} from 'my_module';
		  //等同于
		  import {foo,bar} from 'my_module';
		  上面代码中，虽然foo和bar在两个语句中加载，但是它们对应的是同一个my_module实例。即import语句是Singleton模式
	》模块的整体加载
		除了指定加载某个输出值，还可以使用整体加载，即用星号(*)指定一个对象，所有的输出值都加载在这个对象上面
		》下面是一个circle.js文件，它输出两个方法area和circumference
			//circle.js
			export function area(radius){
				return Math.PI*radius*radius;
			}
			export function circumference(radius){
				return 2*Math.PI*radius;
			}
		》现在加载这个模块
			//main.js
			import{area,circumference} from './circle';//逐一指定要加载的方法
			console.log('圆面积：' + area(4));
			console.log('圆周长：' + circumference(14));

			import * as circle from './circle';//整体加载
			console.log('圆面积：' + circle.area(4));
			console.log('圆周长：' + circle.circumference(14));
	》export default命令
		从前面的例子可以看出，使用import命令的时候，用户需要知道所要加载的变量名或函数名，否则无法加载，但是用户肯定希望快速上手
		未必愿意阅读文档，去了解模块有哪些属性和方法。
		为了给用户提供方便，让他们不用阅读就能加载模块就要用到export default命令，为模块指定默认输出。
		//export-default.js
		export default function (){
			console.log('foo');
		}
		上面代码是一个模块文件export-default.js，它默认输出的是一个函数
		//其他模块加载该模块时，import命令可以为匿名函数指定任意名字
		//import-default.js
		import customName from './export-default';
		customName();//'foo'
		注意：这时import命令后面不使用大括号
		》export default命令用在非匿名函数前面
			//export-default.js
			export default function foo(){
				console.log('foo');
			}
			//或者写成
			function foo(){
				console.log('foo');
			}
			export default foo;
			上面代码中foo函数的函数名foo，在模块外部是无效的。加载的时候，视同匿名函数加载
		》默认输出和正常输出的比较
			//默认输出
			export default function crc32(){}
			import crc32 from 'crc32';//不需要使用大括号
			//正常输出
			export function crc32(){}
			import {crc32} from 'crc32';//需要使用大括号
			注意：export default命令用于指定模块的默认输出。显然一个模块**只能**有一个默认输出，
			因此export default命令只能使用一次，所以import命令后面才不用加大括号，因为只可能对应一个方法
		》本质上export default 就是输出一个叫default的变量或方法，然后系统允许你为它取任意名字，所以下面的写法是有效的
			//modules.js
			function add(x,y){
				return x*y;
			}
			export {add as default}
			//等同于
			export default add;

			//app.js
			import {default as xxx} from 'modules';
			//等同于
			import xxx from 'modules';
			》正是因为export default命令其实只是输出一个叫做default的变量，所以它后面不能根变量声明语句
				export var a=1;//正确

				var a=1;
				export default a;//正确

				export default var a=1;//错误
				上面代码中，export default a的含义是将变量a的值赋给变量default，所以最后一种写法会报错
				》同样地，因为export default本质是将命令后面的值，赋给default变量以后再默认，所以直接将一个值
				  写在export default之后
				  export default 42;//正确--指定了外对接口
				  export 42;//报错--没有指定对外接口
			》如果想在一条import语句中，同时输入默认方法和其他变量
				import _,{each} from 'lodash';
			》export default也可以用来输出类
				//MyClass.js
				export default class{...}
				//main.js
				import MyClass from 'MyClass';
				let o=new MyClass();
	》export与import的复合写法
		如果在一个模块中，先输入后输出同一个模块，import语句可以和export语句写在一起
		export {foo,bar} from 'my_module';
		//等同于
		import {foo,bar} from 'my_module';
		export {foo,bar}
		》模块的接口改名和整体输出也可以采用这种写法
			//接口改名
			export {foo as myFoo} from 'my_module';
			//整体输出
			export * from 'my_module';
		》默认接口的写法
			export {default} from 'foo';
		》具名接口改为默认接口的写法
			export {es6 as default} from './someModule';
			//等同于
			import {es6} from './someModule';
			export default es6;
		》默认接口改名为具名接口
			export {default as es6} from './someModule';
		》下面三种import语句，没有对应的复合写法
			import * as someIdentifier from 'someModule';
			import someIdentifier from 'someModule';
			import someIdentifier,{namedIdentifier} from 'someModule';
		》现在有提案，提出补上这三种复合写法
			export * as someIdentifier from "someModule";
			export someIdentifier from "someModule";
			export someIdentifier, { namedIdentifier } from "someModule";
	》模块的继承
		模块之间也是可以继承的
		假设有一个circleplus模块，继承了circle模块
		//circleplus.js
		export * from 'circle';//表示在输出circle模块的所有属性和方法。注意export * 命令会忽略circle模块的default方法
		export var e=2.7;
		export default function(x){
			return Math.exp(x);
		}
		》这时，也可以将circle的属性或方法，改名后在输出
			//circleplus.js
			export {area as circleArea} from 'circle';
		》加载上面模块的写法
			//main.js
			import * as math from 'circleplus';
			import exp from 'circleplus';//加载默认的方法
	》ES6模块加载的实质
		ES6的模块加载的机制，与CommonJs模块完全不同。CommonJs模块输出的是一个值的拷贝，而ES6模块输出的是值的引用。
		》CommonJs模块输出的是被输出值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。
			//lib.js
			var counter=3;
			function incCounter(){
				counter++;
			}
			module.exports={
				counter:counter,
				incCounter:incCounter
			}
			//main.js加载模块
			var mod =require('./lib');
			console.log(mod.counter);//3
			mod.incCounter();
			console.log(mod.counter);//3
			上面代码说明，lib.js模块加载以后，它的内部变化就影响不到输出的mod.counter了。这是因为mod.counter是一个原始类型的值
			，会被缓存。除非写成一个函数，才能得到内部变动后的值
				//lib.js
				var counter=3;
				function incCounter(){
					counter++;
				}
				module.exports={
					get counter(){//输出取值器函数才可以正确读取内部变量的counter的变动了
						return counter;
					},
					incCounter:incCounter
				}
				//main.js加载模块
				var mod =require('./lib');
				console.log(mod.counter);//3
				mod.incCounter();
				console.log(mod.counter);//4
		》ES6模块的运行机制与CommonJs不一样，js引擎对脚本静态分析的时候，遇到模块加载命令import，就会生成一个只读引用。
		  等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。换句话说，ES6的import有点像Unix系统的"符号连接"，
		  原始值变了，import加载的值也会跟着变。因为ES6模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块
			//lib.js
			export let counter=3;
			export function incCounter(){
				counter++;
			}
			//main.js
			import {counter,incCounter} from './lib';
			console.log(counter);//3
			incCounter();
			console.log(counter);//4
		》案例
			//m1.js
			export var foo='bar';
			setTimeout(()=>foo='baz',500);
			//m2.js
			import {foo} from './m1.js';
			console.log(foo);//'bar'
			setTimeout(()=>console.log(foo),500);//'baz'
			上面代码表明，ES6模块加载不会缓存运行结果，而是动态地去被加载的模块取值，并且变量总是绑定其所在的模块
		》由于ES6输入的模块变量，只是一个'符号连接'，所以这个变量是**只读的**，对它进行重新赋值会报错
			//lib.js
			export let obj={}
			//main.js
			import {obj} from './lib';
			obj.prop=123;//ok
			obj={};//报错 TypeError--因为变量obj指向的地址是只读的，不能重新赋值，这就好比main.js创造了一个名为obj的const变量
		》export通过接口，输出的是同一值。不同的脚本加载这个接口，得到的都是同样的实例
			//mod.js
			function C(){
				this.sum=0;
				this.add=function(){
					this.sum+=1;
				}
				this.show=function(){
					console.log(this.sum);
				}
			}
			export let c=new C();//不同的脚本加载这个模块，得到的都是同一个实例
			//x.js
			import {c} from './mod';
			c.add();
			//y.js
			import {c} from './mod';
			c.show();
			//main.js
			import './x';
			import './y';//1
	》浏览器的模块加载
		浏览器使用ES6模块的语法如下
		<script type='module' src='foo.js'></script>
		上面代码在页面中插入一个模块foo.js，由于type属性设为module，所以浏览器知道这是一个ES6模块
		浏览器对于带有type='module'的<script>都是异步加载外部脚本，不会造成堵塞浏览器
		对于外部的模块脚本，有几点需要注意：
			》该脚本自动采用严格模式
			》该脚本内部的顶层变量，都只在该脚本内部有效，外部不可见
			》该脚本内部的顶层的this关键字，返回undefined，而不是指向window
	》Node的加载处理
		》Node对于ES6模块的处理比较麻烦，因为它有自己的CommonJs模块格式，与ES6模块格式是不兼容的，目前解决方案是将两者分开，ES6模块和
		  Commonjs采用各自的加载方案。
		》在静态分析阶段，一个模块脚本只要有一行import或export语句，Node就会认为该脚本为ES6模块，否则则为CommonJs模块。如果不输出任何接口
		  但是希望被Node认为是ES6模块，可以在脚本中加一行语句 
			export{}//并不是输出一个空对象，而是不输出任何接口的ES6标准写法
		》ES6模块中，顶层this指向undefined；CommonJs模块的顶层this指向当前模块，这是两者的一个重大差异
		》import命令加载CommonJs模块
			Node采用CommonJs模块格式，模块的输出都定义在module.exports这个属性上面。在Node环境中，使用import命令加载CommonJs模块，
			Node会自动将module.exports属性，当作模块的默认输出，即等同于export default
			》下面是一个CommonJs模块
				//a.js
				module.exports={
					foo:"hello",
					bar:'world'
				}
				//等同于
				export default{
					foo:'hello',
					bar:'world'
				}
			》import 命令加载上面的模块，module.exporst会被视为默认输出
				//写法1
				import baz from './a';// baz = {foo: 'hello', bar: 'world'};
				//写法2
				import {default as baz} from './a';// baz = {foo: 'hello', bar: 'world'};
			》如果采用整体输入的写法，default会取代module.exports，作为输入的接口
				import * as baz from './a';
				// baz = {
				//   get default() {return module.exports;},
				//   get foo() {return this.default.foo}.bind(baz),
				//   get bar() {return this.default.bar}.bind(baz)
				// }
				上面代码中，this.default取代了module.exports。需要注意的是，Node会自动为baz添加default属性，
				通过baz.default拿到module.exports。
				//b.js
				module.exports=null;
				//es.js
				import foo from './b';//foo=null
				import * as bar from './b';//bar={default:null}--需要通过bar.default才能拿到module.exports
			》案例
				//c.js
				module.exports=function two(){
					return 2;
				}
				//es.js
				import foo from './c';
				foo();//2

				import * as bar from './c';
				bar.default();//2
				bar(); // throws, bar is not a function
			》CommonJs模块输出的缓存机制，在ES6加载方式下依然有效
				//foo.js
				module.exports=123;
				setTimeout(_=>module.exports=null);
				上面代码中，对于加载foo.js的脚本，module.exports将一直是123，而不会变为null
			》由于ES6模块是编译时确定输出接口，CommonJs模块是运行时确定输出接口，所以采用import命令
			  加载CommonJs模块时，不允许采用下面的写法
				import {readfile} from 'fs';
				上面写法不正确，因为fs是CommonJs格式，只有在运行时才能确定readfile接口，而不是import命令要求编译时
				就确定这个接口。解决方法就是改为整体输入
				//整体输入
				import * as express from 'express';
				const app=express.default();
				//或
				//默认加载
				import express from 'express';
				const app=express();
		》require命令加载ES6模块
			采用require命令加载ES6模块时，ES6模块的所有输出接口，会成为输入对象的属性
				//es.js
				let foo={bar:"my-default"}
				export default foo;
				foo=null;
				//cjs.js
				const es_namespace=require('./es');
				console.log(es_namespace.default);{bar:"my-default"}
				上面代码中，default接口变成了es_namespace.default属性，
				另外由于存在缓存机制，es.js对foo的重新赋值**没有**在模块外部反映出来
			》案例
				//es.js
				export let foo={bar:"my-default"}
				export {foo as bar}
				export function f(){}
				export class c{}
				//cjs.js
				const es_namespace=require('./es');
				// es_namespace = {
				//   get foo() {return foo;}
				//   get bar() {return foo;}
				//   get f() {return f;}
				//   get c() {return c;}
				// }
	》循环加载
		"循环加载"指的是，a脚本的执行依赖b脚本，而b脚本的执行又依赖a脚本
			//a.js
			var b=require('b');
			//b.js
			var a=require('a');
			通常循环加载表示存在强耦合，如果处理不好，还可能导致递归加载，使得程序无法执行，因此应该避免出现
			但是实际上，这是很难避免的，尤其是依赖关系复杂的大项目，很容易出现这种情况。这意味着模块加载机制
			必须考虑循环加载的情况
			》对于js语言来说，目前最常见的两种模块格式CommonJs和ES6，处理循环加载的方法是不一样的，返回结果也是不一样的。
		》CommonJs
			》CommonJs模块的加载原理
				CommonJs的一个模块，就是一个脚本文件。require命令第一次加载该脚本，就会执行整个脚本，
				然后在内存中生成一个对象
				{
					id:"...",//模块名
					exports:{...}
					loaded:true,
					...
				}
				上面代码就是Node内部加载模块后生成的一个对象。
				该对象的id属性是模块名
				exports属性是模块输出的各个接口
				loaded属性是一个布尔值，表示该模块的脚本是否执行完毕
				》以后需要用到这个模块的时候，就会到exports属性上面取值，即使再次执行require命令，也不会再次执行该模块，
				  而是到缓存之中取值。也就是说CommonJs模块无论加载多少次，都只会在第一次加载时运行一次，以后在加载，返回
				  第一次运行的结果，除非手动清除系统缓存
			》CommonJs模块的循环加载
				CommonJs模块的重要特性是加载时执行，即脚本代码在require的时候，就会全部执行。一旦出现某个模块被"循环加载"，
				就只输出已经执行的部分，还未执行的部分不会输出。
				//a.js
				exports.done=false;
				var b=require('./b.js');//此时a.js代码停留，等待b.js执行完毕再往下执行
				console.log('在a.js之中，b.done=%j',b.done);//b.done=true
				exports.done=true;
				console.log('a.js执行完毕');
				//b.js
				exports.done=false;
				var a=require('./a.js');//发生循环加载--输入变量a.done=false
				console.log('在b.js之中，a.done=%j',a.done);
				exports.done=true;
				console.log('b.js执行完毕');
				此时，发生"循环加载"。系统会去a.js对应对象的exports取值，可是因为a.js还没有执行完，从exports属性只能取回
				已经执行的部分，而不是最后的值
				即a.js已经执行的部分只有一行，exports.done=false
				//main.js结果
				var a=require('./a.js');//a.done=true
				var b=require('./b.js');//b.done=true--输出的是缓存值
				总之，CommonJs输入的是被输出值的拷贝，不是引用
				》另外由于CommonJs模块遇到循环加载时，返回的是当前已经执行的部分的值，而不是代码全部执行后的值，两者可能
				  存在差异。所以输入变量的时候，必须小心
				  var a=require('a');//安全的写法
				  var foo=require('a').foo;//危险的写法

				  exports.good=function(arg){
					return a.foo('good',arg);//使用的是a.foo的最新值
				  }
				  exports.bad=function(arg){
					return foo('bad',arg);//使用的是一部分加载时的值
				  }
				  上面代码中，如果发生循环加载，require('a').foo的值很可能后面会被改写，改用require('a')会更保险一点
		》ES6模块的循环加载
			ES6处理"循环加载"与CommonJs有本质的不同。ES6模块是动态引用，如果使用import从一个模块加载变量，那么这些变量不会被缓存
			，而是成为一个指向被加载模块的引用，需要开发者自己保证，真正取值的时候能够取到值。
			//a.js
			import {bar} from './b';//开始执行b.js
			console.log('a.js');//b.js执行完了 继续执行a.js
			console.log(bar);
			export let foo='foo';
			//b.js
			import {foo} from './a';//a.js已经开始执行，不再重复执行
			console.log('b.js');
			console.log(foo);//a.js未执行完，取不到foo的值
			export let bar='bar';
			上面的循环加载执行a.js的结果
			//'b.js'
			//undefined
			//'a.js'
			//bar
			》案例
				//a.js
				import {bar} from './b.js';//开始执行b.js bar为一个函数
				export function foo(){
					console.log('foo');//foo
					bar();//'bar'
					console.log('执行完毕');
				}
				foo();
				//b.js
				import {foo} from './a';//foo=undefined
				export function bar (){
					console.log('bar');//'bar'
					if(Math.random()>.5){
						foo();
					}
				}
				//执行a.js的结果分析如上
				CommonJs是无法执行上面的代码的，ES6则可以
			》案例
				//even.js
				import {odd} from './odd';
				export var counter=0;
				export function even (n){
					counter++;
					return n==0||odd(n-1);
				}
				//odd.js
				import {even} from './even';
				export function odd(n){
					return n!=0 && even(n-1);
				}
				这个例子用CommonJs也是无法执行的
	》跨模块常量
		const声明的常量只在当前代码块中有效。如果想设置跨模块的常量(即跨多个文件)，可以采用下面的写法
			//constants.js
			export const A=1;
			export const B=3;
			//test1.js模块
			import * as constants from './constants';
			console.log(constants.A);//1
			console.log(constants.B);//3
			//test2.js
			import {A,B} from './constants';
			console.log(A);//1
			console.log(B);//3
		》如果要使用的常量非常多，可以建一个专门的constants目录，将各种常量写在不同的文件里面，保存在该目录下
			//constants/db.js
			export const db={
				url:"#",
				admin_username:"admin",
				admin_password:"admin"
			}
			//constants/user.js
			export const users=['root','admin'];
			》然后将这些文件输出的常量合并在index.js
				//constants/index.js
				export {db} from './db';
				export {users} from './users';
			》使用的时候直接加载index.js即可
				//script.js
				import {db,users} from './constants';
	》import()
		import语句会被js引擎静态分析，先于模块内的其他模块执行--叫做连接更合适。所以下面的代码会报错
			if(x===2){//报错
				import MyModual from './myModual';
			}
			上面代码中，引擎处理import语句是在执行之前，所以import语句放在if代码块之中毫无意义，因此会报语法错误，而不是执行时
			错误
			这样的设计，固然有利于编译器提高效率，但也导致无法在运行时加载模块。从长远来看，import语句会取代Node的require方法
			但是require是运行时加载模块，import语句显然无法取代这种动态加载功能
				const path='./'+fileName;
				const myModual=require(path);
			》因此鉴于上面情况，有提案建议引入import()函数，完成动态加载
				import(specifier);//specifier--指定所要加载的模块的位置
				import语句能够接受什么参数，import()函数就能接受什么参数，两者区别主要是后者为动态加载
			》import()返回一个Promise对象
				const main=document.querySelector('main');
				import(`./section-modules/${someVariable}.js`).then(module=>{
					module.loadPageInto(main);
				}).catch(err=>{
					main.textContent=err.message;
				})
			》import()函数可以用在任何地方，不仅仅是模块，非模块的脚本也可以使用。它是运行时执行，也就是说，什么时候运行
			  到这句，也会加载指定的模块。另外，import函数与所加载的模块没有静态连接关系，这点也是与import语句不相同的。
			  import()类似与Node的require方法，区别主要是前者是异步加载，后者是同步加载。
	》ES6模块的转码
		浏览器目前还不支持ES6模块，为了现在就能使用，可以将转为ES5的写法。除了Babel可以用来转码之外，还有以下两种方法也可以用来转码
		》ES6 module transpiler--是square公司开源的一个转码器，可以将ES6模块转为CommonJs模块或AMD模块的写法，从而在浏览器中使用
			》首先安装这个转码器
				$ npm install -g es6-module-transpiler
			》然后使用compile-modules convert命令，将ES6模块文件转码
				$ compile-modules convert file1.js file2.js
			》-o参数可以指定转码后的文件名
				$ compile-modules convert -o out.js file1.js
		》SystemJs--是一个垫片库polyfill，可以在浏览器内加载ES6模块，AMD模块和CommonJs模块，将其转为ES5格式。它在后台调用的是Google的
		  Traceur转码器
			》使用时，先在网页内载入system.js文件
				<script src='system.js'></script>
			》然后使用System.import方法加载模块文件
				<script>
					Symtem.import("./app.js");
				</script>
				注意：System.import使用异步加载，返回一个Promise对象，可以针对这个对象编程。
			》案例
				//模块文件 app/es6-file.js
				export class q{
					constructor(){
						this.es6='hello';
					}
				}
				//然后在页面内部加载这个模块文件
				<script>
					System.import('app/es6-file').then(function(m){
						console.log(new m.q().es6);//hello
					})
					//System.import方法返回的是一个Promise对象，所以可以用then方法指定回调函数
				</script>
31.编程风格
	》块级作用域
		》let取代var
			ES6提出了两个新的声明变量的命令：let和const。其中let完全可以取代var，因为两者语义相同，而且let没有副作用。
			'use strict';
			if(true){let x='hello';}
			for(let i=0;i<10;i++){console.log(i)}
			上面代码如果用var替代let，实际上就声明了两个全局变量，这显然不是本意。
			变量应该只在其声明的代码块内有效，var命令做不到这一点
			》var命令存在变量提升效用，let命令没有这个问题
				if(true){
					console.log(x);//报错
					let x='hello';
				}
			》全局变量和线程安全
				在let和const之间，建议优先使用const，尤其是在全局环境，不应该设置变量，只应设置常量。
				const优于let有几个原因：
					》const可以提醒阅读程序的人，这个变量不应该改变
					》防止了无意间修改变量值所导致的错误
					》const比较符合函数式编程思想，运算不改变值，只是新建值，而且这样也有利于将来的分布式运算
					》js编译器会对const进行优化，所以多使用const有利于提供程序的运行效率，也就是说let和const的
					  本质区别，其实是编译器内部的处理不同
				//bad
				var a=1,b=2;
				//good
				const a=1,
				const b=2;
				//best
				const [a,b]=[1,2];
				所有的函数都应该设置为常量
				长远来看，js可能会有多线程的实现，这时let表示的变量，只应该出现在单线程运行的代码中，不能是多线程共享的
				这样有利于保证线程安全。		
	》字符串
		静态字符串一律使用单引号或反引号，不使用双引号。动态字符串使用反引号
		//bad
		const a="foobar";
		const b='foo'+a+'bar';
		//good
		const a='foobar';
		const b=`foo${a}bar`;
	》解构赋值
		使用数组成员对变量赋值时，优先使用解构赋值
			const arr=[1,2,3,4];
			//bad
			const first=arr[0];
			const second=arr[1];
			//good
			const [first,second]=arr;
		函数参数如果是对象的成员，优先使用解构赋值
			//bad
			function getFullName(user){
				const firstName=user.firstName;
				const lastName=user.lastName;
			}
			//good
			function getFullName(obj){
				const {firstName,lastName}=obj;
			}
			//best
			function getFullName({firstName,lastName}){
				...
			}
		如果函数返回多个值，优先使用对象的解构赋值，而不是数组的解构赋值。
		这样便于以后添加返回值，以及更改返回值的顺序
			//bad
			function processInput(input){
				return [left,right,top,bottom];
			}
			//good
			function processInput(input){
				return {let,right,top,bottom};
			}
			const {left,right}=processInput(input);
	》对象
		单行定义的对象，最后一个成员不以逗号结尾，多行定义的对象，最后一个成员以逗号结尾
			//bad
			const a={k1:v1,k2:v2,}
			const b={
				k1:v1,
				k2:v2
			}
			//good
			const a={k1:v1,k2:v2}
			const b={
				k1:v1,
				k2:v2,
			}
		对象尽量静态化，一旦定义，就不得随意添加新的属性。如果添加属性不可避免，要使用Object.assign方法
			//bad
			const a={};
			a.x=3;
			//good
			const a={}
			Object.assign(a,{x:3});
			   或
			const a={x:null};
			a.x=3;
		如果对象的属性名是动态的，可以在创造对象的时候，使用属性表达式定义
			//bad
			const obj={
				id:5,
			}
			obj[getKey('enabled')]=true;
			//good
			const obj={
				id:5,
				[getkey('enabled')]:true,//属性名需要计算得到，采用属性表达式
			}
		对象的属性和方法，尽量采用简洁表达式，这样易于描述和书写
			var ref='some value';
			//bad
			const atom={
				ref:ref,
				value:1,
				addValue:function(value){
					return atom.value+value;
				},
			}
			//good
			const atom={
				ref,
				value:1,
				addValue(value){
					return atom.value+value;
				},
			}
	》数组
		使用扩展运算符(...)拷贝数组
			//bad
			const len=items.length;
			const itemsCopy=[];
			let i;
			for(i=0;i<len;i++){
				itemsCopy[i]=items[i];
			}
			//good
			const itemsCopy=[...items];
		使用Array.from方法，将类似数组的对象转为数组
			const foo=document.querySelectorAll('.foo');
			const nodes=Array.from(foo);
	》函数
		立即执行函数可以写成箭头函数的形式
			(()=>{
				console.log('哈哈');
			})();
		那些需要使用函数表达式的场合，尽量用箭头函数代替，因为这样更简洁，而且绑定了this
			//bad
			[1,2,3].map(function(x){
				return x*x;
			});
			//good
			[1,2,3].map((x)=>{
				return x*x;
			});
			//best
			[1,2,3].map(x=>x*x);
		箭头函数取代Function.prototype.bind,不应该再用self/_this/that绑定this了
			//bad
			const self=this;
			const boundMethod=function(...params){
				return method.apply(self,params);
			}
			//best
			const boundMethod=(...params)=>method.apply(this,params);
			简单的，单行的，不会复用的函数，建议采用箭头函数。如果函数体较为复杂，行数较多，
			还是采用传统的函数写法
		所有配置项都应该集中在一个对象，放在最后一个参数，布尔值不可以直接作为参数
			//bad
			function divide(a,b,option=false){}
			//good
			function divide(a,b,{option=false}={}){}
		不要在函数体内使用arguments变量，使用rest运算符(...)代替。因为rest运算符显示表明你想要获取参数，而且arguments是一个类似数组
		的对象，而rest运算符可以提供一个真正的数组
			//bad
			function concatenateAll(){
				const args=Array.prototype.slice.call(arguments);
				return args.join('');
			}
			//good
			function concatenateAll(...args){
				return args.join('');
			}
		使用默认值语法设置函数参数的默认值
			//bad
			function handleThings(opts){
				opts=opts||{};
			}
			//good
			function handleThings(opts={}){
				//...
			}
	》Map结构
		注意区分Object和Map，只有模拟现实世界的实体对象时，才使用Object。如果只是需要key:value的数据结构，使用Map结构。
		因为Map有内建的遍历机制
		let map=new Map(arr);
		for(let key of map.keys()){}
		for(let value of map.values()){}
		for(let item of map.entries()){
			console.log(item[0],item(1));
		}
	》Class
		总是用class取代需要的prototype的操作。因为class的写法更简洁，更易于理解
			//bad
			function Queue(contents=[]){
				this._queue=[...contents];
			}
			Queue.prototype.pop=function(){
				const value=this._queue[0];
				this._queue.splice(0,1);
				return value;
			}
			//good
			class Queue{
				constructor(contents=[]){
					this._queue=[...contents];
				}
				pop(){
					const value=this._queue[0];
					this._queue.splice(0,1);
					return value;
				}
			}
		使用extends实现继承，因为这样更简单不会破坏instanceof运算的危险
			//bad
			const inherits=require('inherits');
			functin PeekableQueue(contents){
				Queue.apply(this,contents);
			}
			inherits(PeekableQueue,Queue);
			PeekableQueue.prototype.peek=function(){
				return this._queue[0];
			}
			//good
			class PeekableQueue extends Queue{
				peek(){
					return this._queue[0];
				}
			}
	》模块
		首先，Module语法是js模块的标准写法，坚持使用这种写法。使用import取代require
			//bad
			const moduleA=require('moduleA');
			const func1=moduleA.func1;
			const func2=moduleA.func2;
			//good
			import {func1,func2} from 'moduleA';
		使用export取代module.exports
			//commonJs的写法
			var React =require('react');
			var Breadcrumbs=React.createClass({
				render(){
					return <nav/>
				}
			})
			module.exports=Breadcrumbs;
			//ES6的写法
			import React from 'react';
			const Breadcrumbs=React.createClass({
				render(){
					return <nav/>
				}
			});
			export default Breadcrumbs;
			如果模块只有一个输出值，就使用export default，如果模块有多个输出值，就不使用export default，
			不要export default与普通的export同时使用
		不要在模块输入使用使用通配符,因为这样可以确保你的模块之中，有一个默认输出
			//bad
			import * as myObject './importModule';
			//good
			import myObject from './importModule';
		如果模块默认输出一个函数，函数名的首字母应该小写
			function makeStyleGuide(){}
			export default makeStyleGuide;
		如果模块默认输出一个对象，对象名的首字母应该大写
			const StyleGuide={
				es6:{}
			}
			export default StyleGuide;
	》ESLint的使用
		ESLint是一个语法规则和代码风格的检查工具，可以用来保证写出的语法正确、风格统一的代码
		》首先 安装 ESLint
			npm i -g eslint
		》然后 安装 Airbnb的语法规则
			npm i -g eslint-config-airbnb
		》最后，在项目的根目录下新建一个.eslintrc文件 配置ESLint
			{
			  "extends": "eslint-config-airbnb"
			}
		》开始检查
			//index.js
			var unusued = 'I have no purpose!';
			function greet() {
			    var message = 'Hello, World!';
			    alert(message);
			}
			greet();
			//使用ESLint检查
			$ eslint index.js
32.读懂规格
	》概述
		ECMAScript 6的规格，可以在ECMA国际标准组织的官方网站（www.ecma-international.org/ecma-262/6.0/）免费下载和在线阅读。
33.二进制数组
	二进制数组ArrayBuffer对象、TypedArray视图和DataView视图是js操作二进制数据的一个接口。这些对象早就存在，属于独立的规格。ES6
	将他们纳入了ECMAScript规格，并且增加了新的方法。
	这个接口的原始设计目的，与WebGL项目有关。所谓的WebGL就是指浏览器与显卡之间的通信接口，为了满足js与显卡之间的大量的、
	实时的数据交换，它们之间的数据通信必须是二进制的，而不能是传统的文本格式。文本格式传递一个32位整数，两端的js脚本与显卡都要进行
	格式转化，将非常耗时。这时要是存在一种机制，可以像c语言那样，直接操作字符，将4个字节的32位整数以二进制形式原封不懂的送入显卡，脚本的性能就会
	大幅提升。二进制数组就是在这种背景下诞生的。它很像c语言的数组，**允许开发者以数组下标的形式，直接操作内存**，大大增强了js处理二进制数据的能力，
	使得开发者有可能通过js与操作系统的的原生接口进行二进制通信。
	二进制数组由三类对象组成：
		》ArrayBuffer对象(代表原始的二进制数据)：代表内存之中的一段二进制数据，可以通过"视图"进行操作。
		  "视图"部署了数组接口，这意味着可以用数组的方法操作内存
		》TypedArray视图(用来读写简单类型的二进制数据)：共包括9中类型的视图
			TypedArray视图支持的数据类型一共有9种，DataView视图支持除了Uint8c以外的其他8种：
				数据类型	字节长度	含义
				Int8		1		8位带符号整数
				Uint8		1		8位不带符号整数
				Uint8C		1		8位不带符号整数 自动过滤溢出
				Int16		2		16位带符号整数
				Uint16		2		16位不带符号整数
				Int32		4		32位带符号整数
				Uint32		4		32位不带符号的整数
				Float32		4		32位浮点数
				Float64		8		64位浮点数
		》DataView视图(用来读写复杂类型的二进制数据)：可以自定义复合格式的视图以及自定义字节序
		注意：二进制数据并不是真正的数组，而是类似数组的对象
		很多浏览器操作的API用到了二进制数组操作二进制数据如：
			》File API
			》XMLHttpRequest
			》Fetch API
			》Canvas
			》WebSockets
	》ArrayBuffer对象
		》概述
			ArrayBuffer对象代表存储二进制数据的一段内存，它不能直接读写，只能通过视图(TypeArray和DataView视图)来读写，
			视图的作用是以指定格式解读二进制数据。
			》ArrayBuffer也是一个构造函数，可以分配一段可以存放数据的连续内存区域
				var buf=new ArrayBuffer(32);//参数是所需要的内存大小，单位字节
				上面代码生成了一段**32字节**的内存区域，每个字节的值默认都是0。
			》为了读写这段内容，需要为它指定视图。DataView视图的创建，需要提供ArrayBuffer对象实例作为参数
				//建立DataView视图
				var dataView=new DataView(buf);
				//然后以不带符号的8位整数格式，读取第一个元素
				dataView.getUint8(0);//0
			》另一种TypedArray视图，与DataView视图的一个区别是，它不是一个构造函数而是一组构造函数，代表不同的数据格式
				Var buffer=new ArrayBuffer(12);
				var x1=new Int32Array(buffer);
				x1[0]=1;
				var x2=new Uint8Array(buffer);
				x2[0]=2;
				x1[0]//2
				上面代码对同一段内存，分别建立两种视图：32为带符号整数和8位不带符号整数。由于
				两个视图对应的是同一段内存，一个视图修改底层内存，会影响到另一个视图。
				》TypedArray视图的构造函数除了接受ArrayBuffer实例作为参数，还可以接受普通数据作为参数，直接分配内存生成底层的
				  ArrayBuffer实例，并同时完成对这段内存的赋值
				  var typedArray=new Unit8Array([0,1,2]);
				  typedArray.length;//3
		》ArrayBuffer.prototype.byteLength
			ArrayBuffer实例的byteLength属性，返回所分配的内存区域的字节长度
			var buffer=new ArrayBuffer(32);
			buffer.byteLength;//32
			//如果要分配的内存区域很大，有可能分配失败，因为没有那么多的连续空余内存，所以有必要检查是否分配成功
			  if(buffer.byteLength===n){
				//成功
			  }else{
				//失败
			  }
		》ArrayBuffer.prototype.slice()
			ArrayBuffer实例有一个slice方法，允许将内存区域的一部分，拷贝生成一个新的ArrayBuffer对象
				var buffer=new ArrayBuffer(8);
				var newBuffer=buffer.slice(0,3);//拷贝buffer对象的前3个字节，从0开始到第3个字节前面结束，生成一个新的ArrayBuffer对象
				slice方法其实包含两步：第一步是先分配一段新内存，第二步将原来的那个ArrayBuffer对象拷贝过去
				slice方法接受两个参数：
					》第一个参数表示拷贝开始的字节序号--含该字节
					》第二个参数表示拷贝截止的字节序号--不含该字节，如果省略第二个参数，则默认到原ArrayBuffer对象的结尾
				除了splice方法ArrayBuffer对象不提供任何直接读写内存的方法，只允许在其上方建立视图，然后通过视图读写
		》ArrayBuffer.isView()
			ArrayBuffer有一个静态方法isView，返回一个布尔值，表示参数是否为ArrayBuffer的视图实例。这个方法大致相当于判断参数
			是否为TypedArray实例或DataView实例
				var buf=new ArrayBuffer(8);
				ArrayBuffer.isView(buf);//false

				var v=new Int32Array(buf);
				ArrayBuffer.isView(v);;//true
	》TypedArray视图
		》概述
			ArrayBuffer对象作为内存区域，可以存放多种类型的数据。同一段内存，不同数据有不同的解读方式--这就叫"视图"(view)。
			ArrayBuffer有两种视图，一种是TypedArray视图，另一种是DataView视图。前者的数组成员都是同一数据类型，后者的数组成员
			可以是不同的数据类型。
			目前，TypedArray视图一共包括9种类型，每一种视图都是一种构造函数
				》Int8Array：8位有符号整数，长度1个字节
				》Uint8Array：8位无符号整数，长度1个字节
				》Uint8ClampeArray：8位无符号整数，长度1个字节，溢出处理不同
				》Int16Array：16位有符号整数，长度2个字节
				》Uint16Array：16位无符号整数，长度2个字节
				》Int32Array：32位有符号整数，长度4个字节
				》Uint32Array：32位无符号整数，长度4个字节
				》Float32Array：32位浮点数，长度4个字节
				》Float64Array：64位浮点数，长度8个字节
				这9个构造函数生成的数组，统称为TypedArray视图。它们很像普通数组，都有length属性，都能用方括号([])运算符获取
				单个元素，所有数组的方法，在它们上面都能使用。
				普通数组与TypedArray数组的差异主要在以下方面：
					》TypedArray数组的所有成员，都是同一种类型
					》TypedArray数组的成员是连续的，不会有空位
					》TypedArray数组成员的默认值为0。如new Array(10)返回一个普通数组，里面没有任何成员，只是10个空位；
					  new Uint8Array(10)返回一个TypedArray数组，里面10个成员都是0。
					》TypedArray数组只是一层视图，本身不存储数据。它的数据都存储在底层的ArrayBuffer对象之中，
					  要获取底层对象必须使用buffer属性。
		》构造函数
			TypedArray数组提供9种构造函数，用来生成相应类型的数组实例
			构造函数的多种用法：
				》TypedArray(buffer,byteOffset=0,length?)
					》参数分析
						buffer--必须的，视图对应的底层ArrayBuffer对象
						byteOffset--可选，视图开始的字节序号，默认从0开始
						length--可选，视图包含的数据个数，默认直到本段内存区域结束
					》同一个ArrayBuffer对象之上，可以根据不同的数据类型，建立多个视图
						//创建一个8字节的ArrayBuffer
						var b=new ArrayBuffer(8);
						//创建一个指向b的Int32视图，开始于字节0，直到缓存区的末尾
						var v1=new Int32Array(b);
						//创建一个指向b的Uint8视图，开始于字节2，直到缓存区的末尾
						var v2=new Uint8Array(b,2);
						//创建一个指向b的Int16视图，开始于字节2，长度为2
						var v3=new Int16Array(b,2,2);
						注意：只要任何一个视图对内存有所修改，就会在另外两个视图上反应出来，因为针对的是同一段内存
					》byteOffset必须与所要建立的数据类型一致，否则会报错
						var buf=new ArrayBuffer(8);
						var i16=new Int16Array(buf,1);//报错，因为带符号的16位整数需要两个字节所以byteOffset参数必须能够被2整除
						如果想从任意字节开始解读ArrayBuffer对象，必须使用DataView视图，因为TypedArray视图只提供9种固定的解读格式
				》TypedArray(length)
					视图还可以不通过ArrayBuffer对象，直接分配内存而生成
					var f64a=new Float64Array(8);//生成一个8个成员的Float64Array数组，共64字节
					f64a[0]=10;//赋值
				》TypedArray(typedArray)
					TypedArray数组的构造函数，可以接受另一个TypedArray实例作为参数
					var typedArray=new Int8Array(new Uint8Array);
					注意：此时生成的新数组，**只是复制了参数数组的值，对应的底层内存是不一样的**，新数组会开辟
					一段新的内存存储数据，不会在原数组的内存之上建立视图
					var x=new Int8Array([1,1]);
					var y=new Int8Array(x);
					x[0];//1
					x[0]=2;
					y[0];//1
					》如果想基于同一段内存，构造不同的视图，可以采用下面的写法
						var x=new Int8Array([1]);
						var y=new Int8Array(x.buffer);
						x[0];//1
						y[0];//1
						x[0]=2;
						y[0];//2
				》TypedArray(arrayLikeObject)
					构造函数的参数也可以是一个普通数组，然后直接生成TypedArray实例
					var typedArray=new Uint8Array([1,2]);
					注意：这时TypedArray视图会重新开辟内存，**不会**在原数组的内存上建立视图
					》TypedArray数组也可以转为普通数组
						var normalArray=Array.prototype.slice.call(typedArray)
		》数组方法
			普通数组的操作方法和属性，对TypedArray数组完全适用
				》TypedArray.prototype.copyWithin(target, start[, end = this.length])
				》TypedArray.prototype.entries()
				》TypedArray.prototype.every(callbackfn, thisArg?)
				》TypedArray.prototype.fill(value, start=0, end=this.length)
				》TypedArray.prototype.filter(callbackfn, thisArg?)
				》TypedArray.prototype.find(predicate, thisArg?)
				》TypedArray.prototype.findIndex(predicate, thisArg?)
				》TypedArray.prototype.forEach(callbackfn, thisArg?)
				》TypedArray.prototype.indexOf(searchElement, fromIndex=0)
				》TypedArray.prototype.join(separator)
				》TypedArray.prototype.keys()
				》TypedArray.prototype.lastIndexOf(searchElement, fromIndex?)
				》TypedArray.prototype.map(callbackfn, thisArg?)
				》TypedArray.prototype.reduce(callbackfn, initialValue?)
				》TypedArray.prototype.reduceRight(callbackfn, initialValue?)
				》TypedArray.prototype.reverse()
				》TypedArray.prototype.slice(start=0, end=this.length)
				》TypedArray.prototype.some(callbackfn, thisArg?)
				》TypedArray.prototype.sort(comparefn)
				》TypedArray.prototype.toLocaleString(reserved1?, reserved2?)
				》TypedArray.prototype.toString()
				》TypedArray.prototype.values()
				》注意：TypedArray数组没有concat方法，如果想要合并多个TypedArray数组，可以采用下面这个函数
					function concatenate(resultConstructor,...arrays){
						let totalLength=0;
						for(let arr of arrays){
							totalLength+=arr.length;
						}
						let result=new resultConstructor(totalLength);
						let offset=0;
						for(let arr of arrays){
							result.set(arr,offset);
							offset+=arr.length;
						}
						return result;
					}
					concatenate(Uint8Array, Uint8Array.of(1, 2), Uint8Array.of(3, 4));// Uint8Array [1, 2, 3, 4]
				》TypedArray数组与普通数组一样，部署了Iterator接口，所以可以被遍历
					let ui8=Uint8Array.of(0,1,2);
					for(let byte of ui8){
						console.log(byte);//0 1 2
					}
		》字节序
			字节序指的是数值在内存中的表示方式
			var buffer=new ArrayBuffer(16);//生成16字节的Arraybuffer对象
			var int32View=new Int32Array(buffer);//每个32位整数占据4个字节(1字节8位)
			for(let i=0;i<int32View.length;i++){//int32View.length--4
				int32View[i]=i*2;//0 2 4 6
			}
			》如果在这段数据上接着奖励一个16位整数的视图，则可以读出完全不一样的结果
				var int16View =new Int16View(buffer);
				for(let i=0;i<int16View.length;i++){//int16View.length--每个16位整数占据2个字节 故length--8
					console.log(int16View[i]);
				}
			TypedArray数组内部采用小端字节序读写数据。故无法正确解析大端字节序，但DataView对象，可以设定字节序。
			总之，与普通数组相比，TypedArray数组的最大优点就是可以直接操作内存，不需要数据类型转换，所以速度快的多。
		》BYTES_PER_ELEMENT属性
			每一种视图的构造函数，都一个BYTES_PER_ELEMENT属性，表示这种数据类型占据的字节数
			Int8Array.BYTES_PER_ELEMENT;//1
			》这个属性在TypedArray实例上也能获取即有TypedArray.prototype.BYTES_PER_ELEMENT
		》ArrayBuffer与字符串的互相转换
			ArrayBuffer转为字符串，或字符串转为ArrayBuffer，有一个前提即字符串的编码方法是确定的，假定字符串采用UTF-16编码(js
			内部的编码方式)，可以自己编写转换函数
			//ArrayBuffer转为字符串，参数为ArrayBuffer对象
			function ad2str(buf){
				return String.fromCharCode.apply(null,new Uint16Array(buf));
			}
			//字符串转为ArrayBuffer对象，参数为字符串
			function str2ab(str){
				var buf=new ArrayBuffer(str.length*2);//每个字符占用2个字节
				var bufView=new Uint16Array(buf);
				for(let i=0,strLen=str.length;i<strLen;i++){
					bufView[i]=str.charCodeAt(i);
				}
				return buf;
			}
		》溢出
			不同的视图类型，所能容纳的数值范围是确定的。超过这个范围，就会出现溢出。如8位视图只能容纳一个8位的二进制值，如果放入一个
			9位的值，就会溢出。
			TypedArray数组的溢出处理规则，简单来说就是抛弃溢出的位，然后按照视图类型进行解释
			var uint8=newUint8Array(1);
			uint8[0]=256;
			uint8[0];//0
			uint8[0]=-1;
			uint[0];//255
			上面代码中，uint8是一个8位视图，而256的二进制形式是一个9位的值100000000，这时就会发生溢出。
			根据规则，只会保留后8位，即00000000。uint视图的就是规则是无符号的8位整数
			负数在计算机内部采用"2的补码"表示，也就是说，将对应的正数值进行否运算，然后加1。如-1的对应正直
			是1，进行否运算以后得到11111110再加上1就是补码形式11111111。unit8按照无符号的8位整数解释11111111，返回结果就是255。
			一个简单转换规则可以这样表示：
				正向溢出：当输入值大于当前数据类型的最大值，结果等于当前数据类型的最小值加上余值再减去1
				负向溢出：当输入值小于当前数据类型的最小值。结果等于当前数据类型的最大值减去余值再加上1
				var int8=new Int8Array(1);
				int8[0]=128;
				int8[0]//-128
				int8[0]=-129;
				int8[0];//127
				上面例子中，int8是一个带符号的8位整数视图，它的最大值是127，最小值是-128。
				输入值为128时，相当于正向溢出1，根据最小值加上余值(128%127=1)再减去1的规则就会返回-128
				输入值为-129时，相当于负向溢出1，根据最大值减去余值(-129%-128的余值是1)再加上1的规则，返回127
			》Uint8ClampedArray视图的溢出规则与上面的规则不同。它规定凡是发生正向溢出该值一律等于当前数据类型的最大值即255；
			  如果发生负向溢出，该值一律等于当前数据类型的最小值即0
				var uint8c=new Uint8ClampedArray(1);
				uint8c[0]=256;
				uint8c;//255
				uint8c[0]=-1;
				uint8c[0];0
		》TypedArray.prototype.buffer
			TypedArray实例的buffer属性，返回整段内存区域对应的ArrayBuffer对象。该属性为只读属性
			var a=new Float32Array(64);
			var b=new Uint8Array(a.buffer);
			上面代码的a视图对象和b视图对象，对应同一个ArrayBuffer对象，即同一段内存
		》TypedArray.prototype.byteLength，TypedArray.prototype.byteOffset
			byteLength属性返回TypedArray数组占据的内存长度，单位字节
			byteOffset属性返回TypedArray数组从底层ArrayBuffer对象的那个字节开始。这两个属性是只读属性
			var b=new ArrayBuffer(8);
			var v1=new Int32Array(b);
			var v2=new Uint8Array(b,2);
			var v3=new Int16Array(b,2,2);
			v1.byteLength//8
			v2.byteLength//6
			v3.byteLength;//4
			v1.byteOffset // 0
			v2.byteOffset // 2
			v3.byteOffset // 2
		》TypedArray.prototype.length
			length属性表示TypedArray数组含有多少个成员。注意将byteLength属性和length属性区分，前者是字节长度，后者是成员长度
			var a=new Int16Array(8);
			a.length//8
			a.byteLength//16
		》TypedArray.prototype.set()
			TypedArray数组的set方法用于复制数组(普通数组或TypedArray数组)，也就是将一段内容完全复制到另一段内存
			new Uint8Array(8).set(new Uint8Array(8));//它是整段内存的复制，比一个个拷贝成员的那种复制快的多
			》set方法还可以接受第二个参数，表示b对象的那个成员开始复制a对象
				var a=new Uint16Array(8);
				var b=new Uint16Array(10);
				b.set(a,2);//上面代码b数组比a数组多两个成员，所以从b[2]开始复制a
		》TypedArray.prototype.subarray()
			subarray方法是对于TypedArray数组的一部分，再建一个新的视图
			var a=new Uint16Array(8);
			var b=a.subarray(2,3);
			a.byteLength//16
			b.byteLength//2
			第一个参数：起始的成员序号
			第二个参数：结束的成员序号，不含该成员，如果省略则包含剩余的全部成员
		》TypedArray.prototype.slice()
			slice方法可以返回一个指定位置的新的TypedArray实例
			let ui8=Uint8Array(0,1,2);
			ui8.slice(-1);//Uint8Array[2]
			slice方法的参数表示原数组的具体位置，开始生成新数组，负值表示逆向的位置，即-1为倒数第一个位置
		》TypedArray.of()
			TypedArray数组的所有构造函数，都有一个静态方法of，用于将参数转为一个TypedArray实例
			Float32Array.of(1,2);//Float32Array[1,2]
			》下面三种方法都会生成同样一个TypedArray数组
				//方法1
				let tar=new Uint8Array([1,2,3]);
				//方法2
				let tar=Uint8Array.of(1,2,3);
				//方法3
				let tar=new Uint8Array(3);
				tar[0]=1;
				tar[1]=2;
				tar[2]=3;
		》TypedArray.from()
			静态方法from接受一个可遍历的数据结构(如数组)作为参数，返回一个基于这个结构的TypedArray实例
			Uint16Array.from([0,1]);
			》这个方法还可以将一种TypedArray实例，转为另一种
				var ui16=Uint16Array.from(Uint8Array.of(0,1));
				ui16 instanceof Uint16Array;//true
			》from方法还可以接受一个函数，作为第二个参数，用来对每一个元素进行遍历，功能类似map方法
				Int16Array.from(Int8Array.of(1,2),x=>2*x);
				from会将第一个参数指定的TypedArray数组，拷贝到另一段内存之中，处理之后再将结果转成指定的数组格式
	》复合视图
		由于视图的构造函数可以指定起始位置和长度，所以在同一段内存之中，可以依次存放不同类型的数据--复合视图
		var buffer=new ArrayBuffer(24);
		var idView=new Uint32Array(buffer,0,1);
		var usernameView=new Uint8Array(buffer,4,16);
		var amountDueview=new Float32Array(buffer,20,1);
		上面代码将一个24字节长度的ArrayBuffer对象，分成了三个部分：
			》字节0到字节3:1个32位无符号整数
			》字节4到字节19,16个8位整数
			》字节20到字节23:1个32位浮点数
	》DataView视图
		如果一段数据包括多种类型(如：服务器传来的http数据)，这时除了建立ArrayBuffer对象的复合视图以外还可以通过DataView视图进行操作。
		DataView视图提供更多操作选项，而且支持设定字节序。本来在设计目的上，ArrayBuffer对象的各种TypedArray视图，是用来向网卡、声卡之类的
		本机设备传递数据，所以使用本机的字节序就可以了；而DataView视图的设计目的，是用来处理网络设备传来的数据，所以大端字节序或小端字节序
		是可以自行设定的。
		》DataView视图本身也是构造函数，接受一个ArrayBuffer对象作为参数，生成视图
			DataView(ArrayBuffer buffer[,字节起始位置[,长度]]);
		》案例
			var buffer=new ArrayBuffer(24);
			var dv=new DataView(buffer);
		》DataView实例有以下属性，含义与TypedArray实例的同名方法相同
			》DataView.prototype.buffer:返回对应的ArrayBuffer对象
			》DataView.prototype.byteLength:返回占据的内存字节长度
			》DataView.prototype.byteOffset：返回当前视图从对应的ArrayBuffer对象的那个字节开始
		》DataView实例提供8个方法读取内存
			》getInt8--读取1个字节，返回一个8位整数
			》getUint8--读取1个字节，返回一个无符号的8位整数
			》getInt16--读取2个字节，返回一个16位整数
			》getUint16--读取2个字节，返回一个无符号的16位整数
			》getInt32--读取4个字节，返回一个32位整数
			》getUint32--读取4个字节，返回一个无符号的32位整数
			》getFloat32--读取4个字节，返回一个32位浮点数
			》getFloat64--读取8个字节，返回一个64位浮点数
			这一系列get方法的参数都是一个字节序号(不能是负数，否则会报错)，表示从那个字节开始读取
				var buf=new ArrayBuffer(24);
				var dv=new DataView(buf);
				//从第1个字节读取一个8位无符号整数
				var v1=dv.getUint8(0);
				//从第2个字节读取一个16位无符号整数
				var v2=dv.getUint16(1);
				//从第4个字节读取一个16位无符号整数
				var v3=dv.getUint16(3);
			如果一次读取两个或两个以上字节，就必须明确数据的存储方式，到底是小端字节序还是大端字节序。默认情况下，
			DataView的get方法使用的是大端字节序解读数据，如果需要使用小端字节序解读，必须在get方法的第二个参数指定true
				//小端字节序
				var v1=dv.getUint16(1,true);
				//大端字节序
				var v2=dv.getUint16(3,false);
				//大端字节序
				var v3=dv.getUint16(3);
		》DataView视图提供8个方法写入内存
			》setInt8:写入1个字节的8位整数
			》setUint8：写入1个字节的8位无符号整数
			》setInt16：写入2个字节的16位整数
			》setUint16：写入2个字节的16位无符号整数
			》setInt32：写入4个字节的32位整数
			》setUint32：写入4个字节的32位无符号整数
			》setFloat32：写入4个字节的32位浮点数
			》setFloat64：写入8个字节的64位浮点数
			这一系列set方法，接受两个参数，第一个参数是字节序号，表示从那个字节开始写入，第二个参数为写入的数据。对于那些
			写入两个或两个以上字节的方法，需要指定第三个参数，false或undefined表示使用大端字节序写入，true表示使用小端字节序写入。
				//在第一个字节，以大端字节序写入值为25的32位整数
				dv.setInt32(0,25,false);
				//在第5个字节，以大端字节序写入值为25的32位整数
				dv.setInt32(4,25);
				//在第9个字节，以小端字节序写入值为2.5的32位浮点数
				dv.setFloat32(8,2.5,true);
			》如果不确定正在使用的计算机的字节序，可以采用下面的判断方式
				var littleEndian=(function(){//返回true--小端字节序，返回false--大端字节序
					var buffer=new ArrayBuffer(2);
					new DataView(buffer).setInt16(0,256,true);
					return new Int16Array(buffer)[0]===256;
				})();
	》二进制数组的应用--大量的Web API用到了ArrayBuffer对象和它的视图对象
		》AJax
			传统上，服务器通过ajax操作只能返回文本数据，即responceType属性默认为text，XMLHttpRequest第二版XHR2允许服务器返回
			二进制数据，这是分成两种情况。如果明确知道返回的二进制数据类型，可以把返回的类型responceType设为arraybuffer；如果不知道
			就设为blob。
			var xhr=new XMLHttpRequest();
			xhr.open('GET',url);
			xhr.responseType='arraybuffer';
			xhr.onload=function(){
				let arrayBuffer=xhr.response;
				...
			}
			xhr.send();
			如果知道传回来的是32位整数，可以像下面这样处理
			xhr.onreadystatechange=function(){
				if(xhr.readyState===4){
					var arrayResponse=xhr.response;
					var dataView=new DataView(arrayResponse);
					var ints=new Uint32Array(dataView.byteLength/4);
					console.log(ints.length);
				}
			}
		》Canvas
			网页canvas元素输出的二进制像素数据，就是TypedArray数组
			var canvas=document.getElementById('myCanvas');
			var ctx=canvas.getContext('2d');
			var imageData=ctx.getImageData(0,0,canvas.width,canvas.height);
			var uint8ClampedArray=imageData.data;
			需要注意的是，上面代码的uint8ClampedArray虽然是一个TypedArray，但是它的视图类型是一种针对Canvas元素的专有
			类型Uint8ClamedArray。这个视图类型的特点，就是专门针对颜色，把每个字节解读为无符号的8位整数，即只能取值0~255
			而且发生运算时自动过滤高位溢出。
			举例来说，如果把像素的颜色值设为Uint8Array类型，那么乘以一个gamma值时就必须这样计算
				u8[i]=Math.min(255,Math.max(0,u8[i]*gamma));
			Uint8ClampedArray类型确保将小于0的值设为0，将大于255的值设为255.注意Ie10不支持该类型
		》WebSocket--可以通过ArrayBuffer，发送或接收二进制数据
			var socket=new WebSocket('ws://127.0.0.1:8081');
			socket.binaryType='arraybuffer';
			//发送数据
			socket.addEventListener('open',function(e){
				//发送数据
				var typedArray=new Uint8Array(4);
				socket.send(typedArray.buffer);
			});
			//接收数据
			socket.addEventListener('message',function(e){
				var arrayBuffer=e.data;
			});
		》Fetch APi --取回的数据就是ArrayBuffer对象
			fetch(url).then(function(request){
				return request.arrayBuffer();
			}).then(function(arrayBuffer){
				//...
			});
		》File API
			如果知道一个文件的二进制数据类型，也可以将这个文件读取为ArrayBuffer对象
			var fileInput=document.getElementById('fileInput');
			var file=fileInput.files[0];
			var reader=new FileReader();
			reader.readAsArrayBuffer(file);
			reader.onload=function(){
				var arrayBuffer=reader.result;
			}
			》下面以处理bmp文件为例，假定file变量是一个指向bmp文件的文件对象
				》首先读取文件
					var reader=new FileReader();
					reader.addEventListener('load',processimage,false);
					reader.readAsArrayBuffer(file);
				》然后定义处理图像的回调函数：先在二进制数据之上建立一个DataView视图，在建立一个bitmap对象
				  用于存放处理后的数据，最后将图像展示在Canvas元素之中
					function processimage(e){
						var buffer=e.target.result;
						var datav=new DataView(buffer);
						var bitmap={}
						//具体的处理步奏
							//具体处理图像数据时，先处理bmp的文件头
							bitmap.fileheader = {};
							bitmap.fileheader.bfType = datav.getUint16(0, true);
							bitmap.fileheader.bfSize = datav.getUint32(2, true);
							bitmap.fileheader.bfReserved1 = datav.getUint16(6, true);
							bitmap.fileheader.bfReserved2 = datav.getUint16(8, true);
							bitmap.fileheader.bfOffBits = datav.getUint32(10, true);
							//接着处理图像元信息部分
							bitmap.infoheader = {};
							bitmap.infoheader.biSize = datav.getUint32(14, true);
							bitmap.infoheader.biWidth = datav.getUint32(18, true);
							bitmap.infoheader.biHeight = datav.getUint32(22, true);
							bitmap.infoheader.biPlanes = datav.getUint16(26, true);
							bitmap.infoheader.biBitCount = datav.getUint16(28, true);
							bitmap.infoheader.biCompression = datav.getUint32(30, true);
							bitmap.infoheader.biSizeImage = datav.getUint32(34, true);
							bitmap.infoheader.biXPelsPerMeter = datav.getUint32(38, true);
							bitmap.infoheader.biYPelsPerMeter = datav.getUint32(42, true);
							bitmap.infoheader.biClrUsed = datav.getUint32(46, true);
							bitmap.infoheader.biClrImportant = datav.getUint32(50, true);
							//最后处理图像本身的像素信息
							var start = bitmap.fileheader.bfOffBits;
							bitmap.pixels = new Uint8Array(buffer, start);
							//至此，图像文件的数据全部处理完成。下一步可以根据需要进行图像变形，或转换格式或展示在canvas网页元素中
					}
	》SharedArrayBuffer
		js是单线程的，web worker引入了多进程，每个进程的数据都是隔离的，通过postMessage()通信，即通信的数据是复制的。
		如果数据量比较大，这种通信的效率显然比较低。
			var w=new Worker('myworker.js');
			上面代码中，主进程新建了一个worker进程。该进程与主进程之间会有一个通信渠道，主进程通过w.postMessage向worker进程发消息，同时通过message事件
			监听worker进程的回应。
				//主进程发出消息
				w.postMessage('hi');
				//主进程监听worker进程的回应
				w.onmessage=function(ev){
					//打印worker进程的响应
					console.log(ev.data);
				}
				》worker进程也是通过监听message事件，来获取主进程发来的消息并作出反应
					onmessage=function(ev){
						console.log(ev.data);
						postMessage('ho');
					}
				主进程与worker进程之间可以传送各种数据，不仅仅是字符串还可以是传送二进制数据。很容易想到，如果有大量数据要传送
				留出一块内存区域，主进程与worker进程共享，两方都可以读写，那么就会大大提高效率
		》ES2017引入ShareArrayBuffer，允许多个worker进程与主进程共享内存数据。SharedArrayBuffer的API与ArrayBuffer一模一样，唯一的区别就后者
		  无法共享
			//新建1kb共享内存
			var shareBuffer=new SharedArrayBuffer(1024);
			//主窗口发送数据
			w.postMessage(shareBuffer);
			//本地写入数据
			const sharedArray=new Int32Array(shareBuffer);
			》worker进程从事件的data属性上去取到数据
				var shareBuffer;
				onmessage=function(ev){
					sharedBuffer=ev.data;//1kb的共享内存，就是主窗口共享出来的那块内存
				}
				//共享内存也可以在worker进程创建，发给主进程
			》SharedArrayBuffer与ArrayBuffer一样本身是无法读写的，必须在上面建立视图，然后通过视图读写
				//分配10万个32位整数占据的内存空间
				var sha=new SharedArrayBuffer(Int32Array.BYTES_PER_ELEMENT*100000);
				//建立32位整数视图
				var ia=new Int32Array(sha);
				//新建一个质数生成器
				var primes=new PrimeGenerator();
				//将10万个质数写入这段内存
				for(let i=0;i<ia.length;i++){
					ia[i]=primes.next();
				}
				//向worker进程发送这段共享内存
				w.postMessage(ia);
				》worker进程收到数据后的处理
					var ia;
					onmessage=function(ev){
						ia=ev.data;
						console.log(ia.length);//100000
						console.log(ia[37]);//163
					}
				》多个进程共享内存，最大的问题就是如何防止两个进程同时修改某个地址，或者说，当一个进程修改共享内存以后
				  必须有一个机制让其他进程同步。SharedArrayBuffer API提供Atomics对象，保证所有共享内存的操作都是"原子性"的
				  并且可以在所有进程内同步
					//主进程
					var sb=new SharedArrayBuffer(Int32Array.BYTES_PER_ELEMENT*100000);
					var ia=new Int32Array(sb);
					for(let i=0;i<ia.length;i++){
						ia[i]=primes.next();//将质数放入ia
					}
					//worker进程
					ia[112]++;//错误
					Atomics.add(ia,112,1);//正确
					上面代码中，worker进程直接改写共享内存是不正确的。有两个原因，
					一是可能发生两个进程同时改写该地址
					二是改写以后无法同步到其他worker进程。
					所以，必须使用Atomics.add()方法进行改写
					》案例
						//进程1
						console.log(ia[37]);//163
						Atomics.store(ia,37,123456);//将123456放入ia[37]
						Atomics.wake(ia,37,1);//监视ia[37]的一个进程唤醒
						//进程2
						Atomics.wait(ia,37,163);//只要ia[37]等于163就处于"等待"状态
						console.log(ia[37]);//123456
					》Atomics对象的方法
						》Atomics.load(array,index)--返回array[index]的值
						》Atomics.store(array,index,value)--设置array[index]的值，返回这个值
						》Atomics.compareExchange(array,index,oldVal,newVal)--如果array[index]等于oldVal就写入newVal，返回oldVal
						》Atomics.exchange(array,index,value)--设置array[index]的值，返回旧的值
						》Atomics.add(array,index,value)--将value加到array[index]，返回array[index]旧的值
						》Atomics.sub(array,index,value)--将value从array[index]减去，返回array[index]旧的值
						》Atomics.and(array,index,value)--将value与array[index]进行位运算and，放入array[index]，并返回旧的值
						》Atomics.or(array,index,value)--将value与array[index]进行位运算or，放入array[index]，并返回旧的值
						》Atomics.xor(array,index,value)--将value与array[index]进行位运算xor，放入array[index],并返回旧的值
						》Atomics.wait(array,index,value,timeout)--如果array[index]等于value，进程就进入休眠状态，必须通过Atomics.wake唤醒。
						  timeout指定多少毫秒以后，进入休眠。返回值是三个字符串(ok、not-equal、timed-out)中的一个
						》Atomics.wake(array,index,count)--唤醒指定数目(count)在某个位置休眠的进程
						》Atomics.isLockFree(size)--返回一个布尔值，表示Atomics对象是否可以处理某个size的内存锁定。如果返回false，应用程序就需要
						  自己来实现锁定
34.SIMD
	》概述
		SIMD是'Single Instruction/Multiple Data'的缩写，意为'单指令，多数据'。它是js操作CPU对应指令的接口，你可以看作这是一种
		不同的运算执行模式。与它相对的是SISD'Single Instruction/Single Data' 即 '单指令，单数据'。
		SIMD的含义是使用一个指令，完成多个数据的运算;
		SISD的含义是使用一个指令，完成单个数据的运算，这是js的默认运算模式。
		显而易见，SIMD的执行效率要高于SISD，所以被广泛用于3D图形运算，物理模拟等运算两量超大的项目之中。
		》案例
			var a=[1,2,3,4]
			var b=[5,6,7,8]
			var c=[]
			c[0]=a[0]+b[0];
			...
			//c[6,8,10,12]
			上面代码中，数组a和b的对应成员相加，结果放入数组c。它的运算模式是依次处理每个数组成员，一共有四个数组成员所以需要
			运算4次。--SISD
			》如果采用SIMD只要运算一次就够了
				var a=SIMD.Float32x4(1,2,3,4);
				var b=SIMD.Float32x4(5,6,7,8);
				var c=SIMD.Float32x4.add(a,b);//Float32x4[6,8,10,12]
				上面代码之中，数组a和b的四个成员的各自相加，只用一条指令就完成了。因此，速度比上一种写法提高了4倍。
				》一次SIMD运算，可以处理多个数据，这些数据被称为"通道"(lane)。上面代码中，一次运算了四个数据，因此
				  就是四个通道。
				》SIMD通常用于矢量运算
					v+w=<v1,...,vn>+<w1,...,wn>=<v1+w1,...,vn+wn>
					上面代码中v和w是两个多元矢量。它们的加运算，在SIMD下是一个指令，而不是n个指令完成的，这就大大提高了效率。
					这对于3D动画、图像处理、信号处理、数值处理、加密等运算是非常重要的。如：Canvas的getImageData()会将图像文件
					读成一个二进制数组，SIMD就很适合对于这种数组的处理。
				》总的来说，SIMD是数据并行处理的一种手段，可以加速一下运算密集型操作的速度。将来与WebAssembly结合以后，可以让js达到
				  二进制代码的运行速度。
	》数据类型
		SIMD提供12种数据类型，总长度都是128个二进制位。
			》Float32x4：四个32位浮点数
			》Float64x2：两个64位浮点数
			》Int32x4：四个32位整数
			》Int16x8：八个16位整数
			》Int8x16：十六个8位整数
			》Uint32x4：四个无符号的32位整数
			》Uint16x8：八个无符号的16位整数
			》Uint8x16：十六个无符号的8位整数
			》Bool32x4：四个32位布尔值
			》Bool16x8：八个16位布尔值
			》Bool8x16：十六个8位布尔值
			》Bool64x2：两个64位布尔值
			每种数据类型被x符号分隔成两部分，后面的部分表示通道数，前面的部分表示每个通道的宽度和类型。
			如Float32x4表示这个值有4个通道，每个通道是一个32位浮点数
			》每个通道之中，可以放置四种数据
				》浮点数 float 如1.0
				》带符号的整数 Int 如-1
				》无符号的整数 Uint 如1
				》布尔值 Bool 包含true和false两种值
			》每种SIMD的数据类型都是一个函数方法，可以传入参数，生成对应的值
				var a=SIMD.Float32x4(1.0,2.0,3.0,4.0);
				上面代码中，变量a就是一个128位、包含四个32位浮点数(即四个通道)的值
				》注意：这些数据类型方法都不是构造函数，前面不能加new，否则会报错。
					var v=new SIMD.Float32x4(0,1,2,3);//报错
	》静态方法：数学运算
		每种数据类型都有一系列运算符，支持基本的数据运算
		》SIMD.%type%.abs(),SIMD.%type%.neg()
			》abs方法接受一个SIMD值作为参数，将它的每个通道都转成绝对值，作为一个新的SIMD值返回
				var a=SIMD.Float32x4(-1,-2,0,NaN);
				SIMD.Float32x4.abs(a);//Float32x4[1,2,0,NaN]
			》neg方法接受一个SIMD值作为参数，将它的每个通道都转成负值，作为一个新的SIMD的值返回
				var a=SIMD.Float32x4(-1,3,0,4);
				SIMD.Float32x4.neg(a);//Float32x4[1,-3,-0,-4]

				var b = SIMD.Float64x2(NaN, Infinity);
				SIMD.Float64x2.neg(b);// Float64x2[NaN, -Infinity]
		》SIMD.%type%.add(),SIMD.%type%.addSaturate()
			》add方法接受两个SIMD值作为参数，将它们的每个通道相加，作为一个新的SIMD值返回
				var a=SIMD.Float32x4(1,2,3,4);
				var b=SIMD.Float32x4(5,6,7,8);
				var c=SIMD.Float32x4.add(a,b);//[6,8,10,12]
			》addSaturate方法根add方法的作用相同，都是两个通道相加，但是溢出的处理不一致。对于add方法，如果两个
			  值相加发生溢出，溢出的二进制位会被丢弃；addSaturate方法则是返回该数据类型的最大值
				var a = SIMD.Uint16x8(65533, 65534, 65535, 65535, 1, 1, 1, 1);
				var b = SIMD.Uint16x8(1, 1, 1, 5000, 1, 1, 1, 1);
				SIMD.Uint16x8.addSaturate(a, b);// Uint16x8[65534, 65535, 65535, 65535, 2, 2, 2, 2]

				var c = SIMD.Int16x8(32765, 32766, 32767, 32767, 1, 1, 1, 1);
				var d = SIMD.Int16x8(1, 1, 1, 5000, 1, 1, 1, 1);
				SIMD.Int16x8.addSaturate(c, d);// Int16x8[32766, 32767, 32767, 32767, 2, 2, 2, 2]
				上面代码中，Uint16的最大值65535，Int16的最大值是32767.一旦发生溢出就返回这两个值。
				》注意：Uint32x4和Int32x4这两种数据类型没有addSaturate方法
		》SIMD.%type%.sub(),SIMD.%type%.subSaturate()
			》sub方法接受两个SIMD值作为参数，将它们的每个通道相减，作为一个新的SIMD值返回
				var a=SIMD.Float32x4(-1,-2,3,4);
				var b=SIMD.Float32x4(3,3,3,3);
				SIMD.Float32x4.sub(a,b);//[-4,-5,0,1]
			》subSaturate方法根sub方法的作用相同，都是两个通道相减，但是溢出的处理不一致。对于
			  sub方法，如果两个值相减发生溢出，溢出的二进制位会被丢弃，subSaturate方法则是返回该
			  数据类型的最小值
				var a = SIMD.Uint16x8(5, 1, 1, 1, 1, 1, 1, 1);
				var b = SIMD.Uint16x8(10, 1, 1, 1, 1, 1, 1, 1);
				SIMD.Uint16x8.subSaturate(a, b)// Uint16x8[0, 0, 0, 0, 0, 0, 0, 0]

				var c = SIMD.Int16x8(-100, 0, 0, 0, 0, 0, 0, 0);
				var d = SIMD.Int16x8(32767, 0, 0, 0, 0, 0, 0, 0);
				SIMD.Int16x8.subSaturate(c, d)// Int16x8[-32768, 0, 0, 0, 0, 0, 0, 0, 0]
				上面代码中，Uint16的最小值是0，subSaturate最小值是-32678.一旦运算发生溢出，就返回最小值
		》SIMD.%type%.mul(),SIMD.%type%.div(),SIMD.%type%.sqrt()
			》mul方法接受两个SIMD值作为参数，将他们的每个通道相乘，作为一个新的SIMD值返回
				var a=SIMD.Float32x4(-1,-2,3,4);
				var b=SIMD.Float32x4(3,3,3,3);
				SIMD.Float32x4.mul(a,b);// Float32x4[-3, -6, 9, 12]
			》div方法接受两个SIMD值作为参数，将它们的每个通道相除，作为一个新的SIMD值返回
				var a=SIMD.Float32x4(2,2,2,2);
				var b=SIMD.Float32x4(4,4,4,4);
				SIMD.Float32x4.div(a,b);//[.5,.5,.5,.5]
			》sqrt方法接受一个SIMD值作为参数，求出每个通道的平方根，作为一个新的SIMD值返回
				var b=SIMD.Float64x2(4,9);
				SIMD.Float64x2.sqrt(b);//[2,3]
		》SIMD.%FloatType%.reciprocalApproximation(),SIMD.%FloatType%.reciprocalSqrtApproximation()
			》reciprocalApproximation方法接受一个SIMD值作为参数，求出每个通道的倒数(1/x),作为一个新的SIMD值返回
				var a = SIMD.Float32x4(1, 2, 3, 4);
				SIMD.Float32x4.reciprocalApproximation(a);// Float32x4[1, 0.5, 0.3333333432674408, 0.25]
			》reciprocalSqrtApproximation方法接受一个SIMD值作为参数，求出每个通道的平方根的倒数(1/(x^.5)),作为一个新的SIMD值返回
				var a = SIMD.Float32x4(1, 2, 3, 4);
				SIMD.Float32x4.reciprocalSqrtApproximation(a)// Float32x4[1, 0.7071067690849304, 0.5773502588272095, 0.5]
			》注意：只有浮点数的数据类型才有这两个方法
		》SIMD.%IntegerType%,shiftLeftByScalar()
			shiftLeftByScalar方法接受一个SIMD值作为参数，然后将每个通道的值左移指定位数，作为一个新的SIMD值返回
				var a = SIMD.Int32x4(1, 2, 4, 8);
				SIMD.Int32x4.shiftLeftByScalar(a, 1);// Int32x4[2, 4, 8, 16]
			如果左移后，新的值超出了当前数据类型的位数，溢出部分会被丢弃
				var ix4 = SIMD.Int32x4(1, 2, 3, 4);
				var jx4 = SIMD.Int32x4.shiftLeftByScalar(ix4, 32);// Int32x4[0, 0, 0, 0]
			注意：只有整数的数据类型才有这个方法
		》SIMD.%IntegerType%.shiftRightByScalar()
			shiftRightByScalar方法接受一个SIMD值作为参数，然后将每个通道的值右移指定的位数，返回一个新的SIMD值
				var a = SIMD.Int32x4(1, 2, 4, -8);
				SIMD.Int32x4.shiftRightByScalar(a, 1);// Int32x4[0, 1, 2, -4]
			如果原来通道的值是带符号的值，则符号位保持不变，不受右移影响。如果是不带符号位的值，则右移后头部会补0
				var a = SIMD.Uint32x4(1, 2, 4, -8);
				SIMD.Uint32x4.shiftRightByScalar(a, 1);// Uint32x4[0, 1, 2, 2147483644]
				上面代码中，-8右移一位变成了2147483644，是因为对于32位无符号整数来说，
				-8的二进制形式是11111111111111111111111111111000，
				右移一位就变成了01111111111111111111111111111100，相当于2147483644。
			注意：只有整数的数据类型才有这个方法
	》静态方法：通道处理
		》SIMD.%type%.check()
			check方法用于检查一个值是否为**当前类型**的SIMD值。如果是，就返回这个值，否则报错
				var a=SIMD.Float32x4(1, 2, 3, 9);
				SIMD.Float32x4.check(a);//[1,2,3,9]
				SIMD.Float32x4.check([1,2,3,4]);//报错
				SIMD.Int32x4.check(a) // 报错
		》SIMD.%type%.extractLane(),SIMD.%type%.replaceLane()
			extractLane方法用于返回给定通道的值，它接受两个参数，分别是SIMD值和通道编号
				var t=SIMD.Float32x4(1,2,3,4);
				SIMD.Float32x4.extractLane(t,2);//3
			replaceLane方法用于替换指定通道的值，并返回一个新的SIMD值。它接受三个参数，分别是原来的SIMD值、通道编号和新的通道值
				var t=SIMD.Float32x4(1,2,3,4);
				SIMD.Float32x4.replaceLane(t,2,42);
				//[1,2,42,4]
		》SIMD.%type%.load()
			load方法用于从二进制数组读入数据，生成一个新的SIMD值
				var a = new Int32Array([1,2,3,4,5,6,7,8]);
				SIMD.Int32x4.load(a, 0);// Int32x4[1, 2, 3, 4]

				var b = new Int32Array([1,2,3,4,5,6,7,8]);
				SIMD.Int32x4.load(a, 2);// Int32x4[3, 4, 5, 6]
				该方法接受两个参数：一个二进制数组和开始读取的位置(从0开始)，如果位置不合法(如-1或超出二进制数组的大小)，就会抛出错误
				》这个方法还有三个变种load1()、load2()、load3()，表示从指定位置开始，只加载一个通道、二个通道、三个通道的值
					// 格式
					SIMD.Int32x4.load(tarray, index)
					SIMD.Int32x4.load1(tarray, index)
					SIMD.Int32x4.load2(tarray, index)
					SIMD.Int32x4.load3(tarray, index)

					// 实例
					var a = new Int32Array([1,2,3,4,5,6,7,8]);
					SIMD.Int32x4.load1(a, 0);// Int32x4[1, 0, 0, 0]
					SIMD.Int32x4.load2(a, 0);// Int32x4[1, 2, 0, 0]
					SIMD.Int32x4.load3(a, 0);// Int32x4[1, 2, 3,0]
		》SIMD.%type%.store()
			store方法用于将一个SIMD值，写入一个二进制数组。它接受三个参数，分别是二进制数组、开始写入的数组位置、SIMD值。它返回写入
			值以后的二进制数组
				var t2 = new Int32Array(8);
				var v2 = SIMD.Int32x4(1, 2, 3, 4);
				SIMD.Int32x4.store(t2, 2, v2)// Int32Array[0, 0, 1, 2, 3, 4, 0, 0]
				》这个方法还有三个变种store1()、store2()、store3(),表示只写入一个通道、二个通道和三个通道的值
					var tarray = new Int32Array(8);
					var value = SIMD.Int32x4(1, 2, 3, 4);
					SIMD.Int32x4.store1(tarray, 0, value);// Int32Array[1, 0, 0, 0, 0, 0, 0, 0]
		》SIMD.%type%.splat()
			splat 方法返回一个新的SIMD值，该值的所有通道都会设成同一个预先给定的值。
				SIMD.Float32x4.splat(3);// Float32x4[3, 3, 3, 3]
				如果省略参数，所有整数型的SIMD值都会设定0，浮点型的SIMD值都会设成NaN
		》SIMD.%type%.swizzle()
			swizzle方法返回一个新的SIMD值，重新排列原有的SIMD值的通道顺序
				var t = SIMD.Float32x4(1, 2, 3, 4);
				SIMD.Float32x4.swizzle(t, 1, 2, 0, 3);// Float32x4[2,3,1,4]
				上面代码中，swizzle方法的第一个参数是原有的SIMD值，后面的参数对应将要返回的SIMD值的四个通道(通道值可以一样)。它的意思是新的
				SIMD的四个通道，依次是原来的SIMD的1号通道、2号通道、0号通道、3号通道。由于SIMD值最多可以有16个通道，所以swizzle
				方法除了第一个参数以外，最多还可以接受16个参数。
		》SIMD.%type%.shuffle()
			shuffle方法从两个SIMD值之中取出指定通道，返回一个新的SIMD值
				var a = SIMD.Float32x4(1, 2, 3, 4);
				var b = SIMD.Float32x4(5, 6, 7, 8);

				SIMD.Float32x4.shuffle(a, b, 1, 5, 7, 2);// Float32x4[2, 6, 8, 3]
				上面代码中，a和b一共有8个通道，依次编号为0到7。shuffle根据编号取出相应的通道，返回一个新的SIMD值
	》静态方法：比较运算
		》SIMD.%type%.equal(),SIMD.%type%.notEqual()
			equal方法用来比较两个SIMD值a和b的每一个通道，根据两者是否精确相等(a===b),得到一个布尔值。最后，所有通道的比较结果
			组成一个新的SIMD值，作为掩码返回。notEqual方法则是比较两个通道是否不相等(a !== b);
				var a = SIMD.Float32x4(1, 2, 3, 9);
				var b = SIMD.Float32x4(1, 4, 7, 9);

				SIMD.Float32x4.equal(a,b)// Bool32x4[true, false, false, true]

				SIMD.Float32x4.notEqual(a,b);// Bool32x4[false, true, true, false]
		》SIMD.%type%.greaterThan(),SIMD.%type%.greaterThanOrEqual()
			greaterThan方法用来比较两个SIMD值a和b的每一个通道，如果在该通道中，a较大就得到true，否则得到false。最后，所有通道的比较结果
			组成一个新的SIMD值，作为掩码返回。greaterThanOrEqual则是比较a是否大于等于b
				var a = SIMD.Float32x4(1, 6, 3, 11);
				var b = SIMD.Float32x4(1, 4, 7, 9);

				SIMD.Float32x4.greaterThan(a, b)// Bool32x4[false, true, false, true]

				SIMD.Float32x4.greaterThanOrEqual(a, b)// Bool32x4[true, true, false, true]
		》SIMD.%type%.lessThan(),SIMD.%type%.lessThanOrEqual()
			lessThan方法用来比较两个SIMD值a和b的每一个通道，如果在该通道中，a较小就得到true，否则得到false。最后，所有通道的比较结果，
			会组成一个新的SIMD值，作为掩码返回。lessThanOrEqual方法则是比较a是否小于等于b。
				var a = SIMD.Float32x4(1, 2, 3, 11);
				var b = SIMD.Float32x4(1, 4, 7, 9);

				SIMD.Float32x4.lessThan(a, b)// Bool32x4[false, true, true, false]

				SIMD.Float32x4.lessThanOrEqual(a, b)// Bool32x4[true, true, true, false]
		》SIMD.%type%.select()
			select方法通过掩码生成一个新的SIMD值。它接受三个参数，分别是掩码和两个SIMD值
				var a = SIMD.Float32x4(1, 2, 3, 4);
				var b = SIMD.Float32x4(5, 6, 7, 8);

				var mask = SIMD.Bool32x4(true, false, false, true);

				SIMD.Float32x4.select(mask, a, b);// Float32x4[1, 6, 7, 4]
				上面代码中，select方法接受掩码和两个SIMD值作为参数。当某个通道对应的掩码为true时，会选择第一个SIMD值的对应通道
				否则会选择第二个SIMD值的对应通道。
			》这个方法通常与比较运算符结合使用
				var a = SIMD.Float32x4(0, 12, 3, 4);
				var b = SIMD.Float32x4(0, 6, 7, 50);

				var mask = SIMD.Float32x4.lessThan(a,b);// Bool32x4[false, false, true, true]
				//选择出每个通道的较小值组成的新的SIMD值
				var result = SIMD.Float32x4.select(mask, a, b);// Float32x4[0, 6, 3, 4]
		》SIMD.%BooleanType%.allTrue(),SIMD.%BooleanType%.anyTrue()
			allTrue方法接受一个SIMD值作为参数，然后返回一个布尔值，表示该SIMD值的所有通道是否都为true
				var a = SIMD.Bool32x4(true, true, true, true);
				var b = SIMD.Bool32x4(true, false, true, true);

				SIMD.Bool32x4.allTrue(a); // true
				SIMD.Bool32x4.allTrue(b); // false
			anyTrue方法则是只要有一个通道为true就返回true，否则返回false
				var a = SIMD.Bool32x4(false, false, false, false);
				var b = SIMD.Bool32x4(false, false, true, false);

				SIMD.Bool32x4.anyTrue(a); // false
				SIMD.Bool32x4.anyTrue(b); // true
			注意：只有四种布尔值数据类型Bool32x4、Bool16x8、Bool8x16、Bool64x2，才有这两个方法
			》这两个方法通常与比较运算符结合使用
				var ax4    = SIMD.Float32x4(1.0, 2.0, 3.0, 4.0);
				var bx4    = SIMD.Float32x4(0.0, 6.0, 7.0, 8.0);
				var ix4    = SIMD.Float32x4.lessThan(ax4, bx4);
				var b1     = SIMD.Int32x4.allTrue(ix4); // false
				var b2     = SIMD.Int32x4.anyTrue(ix4); // true
		》SIMD.%type%.min(),SIMD.%type%.minNum()
			min方法接受两个SIMD值作为参数，将两个的对应通道的较小值，组成一个新的SIMD值返回
				var a = SIMD.Float32x4(-1, -2, 3, 5.2);
				var b = SIMD.Float32x4(0, -4, 6, 5.5);
				SIMD.Float32x4.min(a, b);
				// Float32x4[-1, -4, 3, 5.2]
				》如果有一个通道的值是NaN，则会优先返回NaN
					var c = SIMD.Float64x2(NaN, Infinity)
					var d = SIMD.Float64x2(1337, 42);
					SIMD.Float64x2.min(c, d);// Float64x2[NaN, 42]
				》minNum方法与min的作用一模一样，唯一的区别是如果有一个通道是NaN，则会优先返回另一个通道的值
					var ax4 = SIMD.Float32x4(1.0, 2.0, NaN, NaN);
					var bx4 = SIMD.Float32x4(2.0, 1.0, 3.0, NaN);
					var cx4 = SIMD.Float32x4.min(ax4, bx4);// Float32x4[1.0, 1.0, NaN, NaN]
					var dx4 = SIMD.Float32x4.minNum(ax4, bx4);// Float32x4[1.0, 1.0, 3.0, NaN]
		》SIMD.%type%.max(),SIMD.%type%.maxNum()
			max方法接受两个SIMD值作为参数，将两者的对应通道的较大值，组成一个新的SIMD值返回
				var a = SIMD.Float32x4(-1, -2, 3, 5.2);
				var b = SIMD.Float32x4(0, -4, 6, 5.5);
				SIMD.Float32x4.max(a, b);// Float32x4[0, -2, 6, 5.5]
			》如果有一个通道的值是NaN，则会优先返回NaN
				var c = SIMD.Float64x2(NaN, Infinity)
				var d = SIMD.Float64x2(1337, 42);
				SIMD.Float64x2.max(c, d)// Float64x2[NaN, Infinity]
			》maxNum方法与max的作用一模一样，唯一的区别是如果有一个通道的值是NaN，则会优先返回另一个通道的值
				var c = SIMD.Float64x2(NaN, Infinity)
				var d = SIMD.Float64x2(1337, 42);
				SIMD.Float64x2.maxNum(c, d)// Float64x2[1337, Infinity]
	》静态方法：位运算
		》SIMD.%type%.and,SIMD.%type%.or(),SIMD.%type%.xor(),SIMD.%type%.not()
			》and方法接受两个SIMD值作为参数，返回两者对应通道进行二进制AND运算(&)后得到的新的SIMD值
				&--两个相“与”的逻辑变量中，只要有一个为0，“与”运算的结果就为0。仅当两个变量都为1时，“与”运算的结果才为1。
				var a = SIMD.Int32x4(1, 2, 4, 8);
				var b = SIMD.Int32x4(5, 5, 5, 5);
				SIMD.Int32x4.and(a, b)// Int32x4[1, 0, 4, 0]
				上面代码中，以通道0为例，1的二进制形式是0001,5的二进制形式是0101，所以进行and运算以后得到0001
			》or方法接受两个SIMD值作为参数，返回两者对应的通道进行二进制or运算(|)后得到新的SIMD值
				|--两个相“或”的逻辑变量中，只要有一个为1，“或”运算的结果就为1。仅当两个变量都为0时，或运算的结果才为0。
				var a = SIMD.Int32x4(1, 2, 4, 8);
				var b = SIMD.Int32x4(5, 5, 5, 5);
				SIMD.Int32x4.or(a, b)// Int32x4[5, 7, 5, 13]
			》xor方法接受两个SIMD值作为参数，返回两者对应的通道进行二进制"异或"运算(^)后得到的新的SIMD值
				^--两个相“异或”的逻辑运算变量取值相同时，“异或”的结果为0。取值相异时，“异或”的结果为1
				var a = SIMD.Int32x4(1, 2, 4, 8);
				var b = SIMD.Int32x4(5, 5, 5, 5);
				SIMD.Int32x4.xor(a, b)// Int32x4[4, 7, 1, 13]
			》not方法接受一个SIMD值作为参数，返回每一个通道进行二进制"否"运算(~)后得到的新的SIMD值
				var a = SIMD.Int32x4(1, 2, 4, 8);
				SIMD.Int32x4.not(a)// Int32x4[-2, -3, -5, -9]
				上面代码中1的否运算之所以得到-2，是因为在计算机内部负数采用'2的补码'这种形式表示。也就是说整数n
				的负数形式-n是对每个二进制取反以后在加上1.因此直接取反就相当于负数形式在减去1.如1的负数形式-1在减去
				1就得到-2。
	》静态方法：数据类型转换
		SIMD提供以下方法用来将一种数据类型转为另一种数据类型
			》SIMD.%type%.fromFloat32x4()
			》SIMD.%type%.fromFloat32x4Bits()
			》SIMD.%type%.fromFloat64x2Bits()
			》SIMD.%type%.fromInt32x4()
			》SIMD.%type%.fromInt32x4Bits()
			》SIMD.%type%.fromInt16x8Bits()
			》SIMD.%type%.fromInt8x16Bits()
			》SIMD.%type%.fromUint32x4()
			》SIMD.%type%.fromUint32x4Bits()
			》SIMD.%type%.fromUint16x8Bits()
			》SIMD.%type%.fromUint8x16Bits()
			带有Bits后缀的方法会原封不动的将二进制位拷贝到新的数据类型，不带后缀的方法则会进行数据类型转换
				var t = SIMD.Float32x4(1.0, 2.0, 3.0, 4.0);
				//将浮点数转为整数
				SIMD.Int32x4.fromFloat32x4(t);// Int32x4[1, 2, 3, 4]
				//将二进制位原封不动地拷贝进入新的数据类型，然后解读
				SIMD.Int32x4.fromFloat32x4Bits(t);// Int32x4[1065353216, 1073741824, 1077936128, 1082130432]
			》Bits后缀的方法，还可以用于通道数目不对等的拷贝
				var t = SIMD.Float32x4(1.0, 2.0, 3.0, 4.0);
				SIMD.Int16x8.fromFloat32x4Bits(t);// Int16x8[0, 16256, 0, 16384, 0, 16448, 0, 16512]
			》注意：如果数据转换时，原通道的数据大小，超过了目标通道的最大宽度，就会报错
	》实例方法
		SIMD.%type%.prototype.toString()--返回一个SIMD值的字符串形式
			var a = SIMD.Float32x4(11, 22, 33, 44);
			a.toString() // "SIMD.Float32x4(11, 22, 33, 44)"
	》实例：求平均值
		正常模式下，计算n个值的平均值，需要运算n次
			function average(list){
				var n=list.length;
				var sum=0.0;
				for(let i=0;i<n;i++){
					sum+=list[i];
				}
				return sum/n;
			}
		使用SIMD可以将计算次数减少到n次的四分之一
			function average(list) {
			  var n = list.length;
			  var sum = SIMD.Float32x4.splat(0.0);
			  for (var i = 0; i < n; i += 4) {
			    sum = SIMD.Float32x4.add(
			      sum,
			      SIMD.Float32x4.load(list, i)
			    );
			  }
			  var total = SIMD.Float32x4.extractLane(sum, 0) +
				      SIMD.Float32x4.extractLane(sum, 1) +
				      SIMD.Float32x4.extractLane(sum, 2) +
				      SIMD.Float32x4.extractLane(sum, 3);
			  return total / n;
			}
