/*******************文档分析******************/
1.http://cn.redux.js.org/
    Redux是js状态容器，提供可预测化的状态管理。可以让你构建一致化的应用，运行于不同的环境(客户端、服务器、原生应用)，
    并且易于测试。不仅于此，它还提供比较好的开发体验。

    Redux除了和React一起用外，还支持其他界面库。它体小精悍只有2kb，包括依赖。
2.安装
    稳定版本：
        npm install --save redux
    直接下载
        https://unpkg.com/redux@3.7.2/
        通过<script>引入UMD文件，可以通过window.Redux全局变量来访问Redux。
        Redux源文件由ES2015编写，但是会预编译到CommonJs和UMD规范的ES5，所以它支持**任何现代浏览器**。不必
        非得使用Babel或模块打包器来使用Redux。
    附加包：
        npm install --save react-redux//React绑定库
        npm install --save-dev redux-devtools//开发者工具
        注意：和Redux不同，很多Redux生态下的包并不提供UMD文件，所以为了提升开发体验，建议使用
        webpack和browserify类似的commonJs模块打包器。
    》要点介绍
        应用中所有的state都以一个对象树的形式储存在一个单一的store中。唯一改变state的办法是触发action(一个描述发生什么的对象)。
        为了描述action如何改变state树，需要编写reducers。

        import {createStore} from 'redux'

        /**
        * 这是一个reducer，形式(state,action) => state的纯函数，用于描述action如何改变state树
        *
        *state的形式取决于你，可以是基本类型、数组、对象、甚至是Immutable.js生成的数据结构。
        *   唯一的要点是：当state变化时需要返回全新的对象，而不是修改传入的参数
        */
        function counter(state=0,action){
            switch(action.type){
                case "INCREMENT":
                    return state + 1;
                case "DECREMENT":
                    return state - 1;
                default :
                    return state;
            }
        }

        /**
        *创建Redux store来存放应用的状态
        */
        let store = createStore(counter);

        //可以手动订阅更新也可以事件绑定到视图层
        store.subscribe( ()=>{
            console.log(store.getState());
        });

        //改变内部state的唯一方式是：dispatch一个action
        //action可以被序列化，用日记记录和储存下来，后期还可以以回放的方式执行
        store.dispatch({type:"INCREMENT"});
        //你应该把要做的修改变成一个普通的对象，这个对象被叫做action，而不是直接修改state。然后编写
        专门的函数来决定每个action如何改变应用的state，这个函数被叫做reducer。

        和Flux相比：Redux 没有 Dispatcher 且不支持多个 store。相反，只有一个单一的 store 和一个根级的 reduce 函数（reducer）。
        随着应用不断变大，你应该把根级的 reducer 拆成多个小的 reducers，分别独立地操作 state 树的不同部分，
        而不是添加新的 stores。这就像一个 React 应用只有一个根级的组件，这个根组件又由很多小组件构成。
3.介绍
    》动机
        随着js单页应用开发日趋复杂，js需要管理比任何时候都要多的state(状态)。这些state可能包括服务器响应、
        缓存数据，本地生成尚未持久化到服务器的数据，也包括UI状态，如激活的路由，被选中的标签，是否显示加载
        动效或分页器等等。
        通过限制更新发生的时间和方式，Redux 试图让 state 的变化变得可预测。
    》核心概念
        》当使用普通对象来描述应用的state，如：todo应用的state
            {
                todos:[
                    {
                        text:"Eat food",
                        completed:true
                    },
                    {
                        text:"Exercise",
                        completed:false
                    }
                ],
                visibilityFilter:"SHOW_COMPLETED"
            }
            //这个对象就像Model，区别是他并没有setter(修改器方法)，因此其它的代码不能随意修改它，
            //造成难以复现的bug。
        》想更新state中的数据，需要发起一个action，Action就是一个普通的js对象，用于描述发生了什么。
            如：
            { type: 'ADD_TODO', text: 'Go to swimming pool' }
            { type: 'TOGGLE_TODO', index: 1 }
            { type: 'SET_VISIBILITY_FILTER', filter: 'SHOW_ALL' }
            //强制使用action来描述所有变化带来的好处是可以清晰的知道应用中发生了什么。
            //如果一些东西改变了，就可以知道为什么变。action就像是描述发生了什么的面包屑。
        》最终为了把action和state串起来，开发一些函数这就是reducer。reducer只是一个接收
          state和action，并返回新的state的函数。对于大的应用来说，可能很难开发这样的函数，
          所以我们编写很多小的函数来分别管理state的一部分。
             如：
                function visibilityFilter(state="SHOW_ALL",action){
                    if(action.type === 'SET_VISIBILITY_FILTER'){
                        return action.filter;
                    }else{
                        return state;
                    }
                }
                function todos(state = [],action){
                    switch(action.type){
                        case "ADD_TODO":
                            return state.concat([{text:action.text,completed:false}]);
                        case "TOGGLE_TODO":
                            return state.map((todo.index) => {
                                action.index === index ?
                                {text:todo.text,completed:!todo.completed}:
                                todo
                            });
                        default:
                            return state;
                    }
                }

                //在开发一个reducer调用上面两个reducer，进而来管理整个应用的state
                function todoApp(state={},action){
                    return {
                        todos:todos(state.todos,action),
                        visibilityFilter:visibilityFilter(state.visibilityFilter,action)
                    }
                }
        上面的思路就是Redux的思想，而Redux的API主要是用于来简化上面的操作。

    》三大原则
        》单一数据源
            整个应用的 state 被储存在一棵对象tree中，并且这个对象树只存在 唯一一个store中。

            这让同构应用开发变得非常容易。来自服务器的state可以在无需编写更多代码的情况下，被序列化并注入到
            客户端中。由于是单一的state tree，调试也变得非常容易。在开发中，你可以把应用的state保存在本地，从
            而加快开发速度，此外受益于单一的state树，以前难以实现的"撤销或重做"这类功能也变得轻而易举。

            console.log(store.getState());
            //输出
            {
              visibilityFilter: 'SHOW_ALL',
              todos: [
                {
                  text: 'Consider using Redux',
                  completed: true,
                },
                {
                  text: 'Keep all state in a single tree',
                  completed: false
                }
              ]
            }

        》State是只读的
            唯一改变state的方法就是触发action，action是一个用于描述已发生事件的普通对象。

            这样确保了视图和网络请求都不能直接修改state，相反他们只能表达想要修改的意图。
            因为所有的修改都被集中化处理，且严格按照一个接着一个的顺序执行，因此不用担心
            race condition的出现。Action就是普通对象而已，因此他们可以被日志打印、序列化、
            储存、后期调试或测试时回放出来。

            store.dispatch({
              type: 'COMPLETE_TODO',
              index: 1
            })

            store.dispatch({
              type: 'SET_VISIBILITY_FILTER',
              filter: 'SHOW_COMPLETED'
            })

        》使用纯函数来执行修改
            为了描述action如何改变state树，你需要编写reducers。

            Reducer只是一些纯函数，它接收先前的state和action，并返回新的state。
            刚开始你可以只有一个reducer，随着应用变大，你可以把它拆成多个小的reducers。分别独立的操作
            state树的不同部分，因为reducer只是函数，你可以控制他们被调用的顺序，传入附加数据，甚至编写可
            复用的reducer来处理一些通用任务，如分页器。

            function visibilityFilter(state = 'SHOW_ALL',action){
                switch(action.type){
                    case 'SET_VISIBILITY_FILTER':
                        return action.filter;
                    default:
                        return state;
                }
            }

            function todos(state=[],action){
                switch(action.type){
                    case 'ADD_TODO':
                        return [
                            ...state,
                            {
                                text:action.text,
                                completed:false
                            }
                        ];
                    case "COMPLETE_TODO":
                        return state.map((todo,index) => {
                            if(index === action.index){
                                return Object.assign({},todo,{
                                    completed:true
                                });
                            }

                            return todo;
                        });
                    default:
                        return state;
                }
            }

            import {combineReducers,createStore} from 'redux'
            let reducer = combineReducers ({ visibilityFilter, todos });//合并所有的reducer
            let store = createStore(reducer);//创建store

    》先前技术
        Redux是一个混合产物。它和一些设计模式以及技术相似，但也有不同之处。

    》生态系统

    》示例





















