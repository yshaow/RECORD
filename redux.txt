/*******************文档分析******************/
1.http://cn.redux.js.org/
    Redux是js状态容器，提供可预测化的状态管理。可以让你构建一致化的应用，运行于不同的环境(客户端、服务器、原生应用)，
    并且易于测试。不仅于此，它还提供比较好的开发体验。

    Redux除了和React一起用外，还支持其他界面库。它体小精悍只有2kb，包括依赖。
2.安装
    稳定版本：
        npm install --save redux
    直接下载
        https://unpkg.com/redux@3.7.2/
        通过<script>引入UMD文件，可以通过window.Redux全局变量来访问Redux。
        Redux源文件由ES2015编写，但是会预编译到CommonJs和UMD规范的ES5，所以它支持**任何现代浏览器**。不必
        非得使用Babel或模块打包器来使用Redux。
    附加包：
        npm install --save react-redux//React绑定库
        npm install --save-dev redux-devtools//开发者工具
        注意：和Redux不同，很多Redux生态下的包并不提供UMD文件，所以为了提升开发体验，建议使用
        webpack和browserify类似的commonJs模块打包器。
    》要点介绍
        应用中所有的state都以一个对象树的形式储存在一个单一的store中。唯一改变state的办法是触发action(一个描述发生什么的对象)。
        为了描述action如何改变state树，需要编写reducers。

        import {createStore} from 'redux'

        /**
        * 这是一个reducer，形式(state,action) => state的纯函数，用于描述action如何改变state树
        *
        *state的形式取决于你，可以是基本类型、数组、对象、甚至是Immutable.js生成的数据结构。
        *   唯一的要点是：当state变化时需要返回全新的对象，而不是修改传入的参数
        */
        function counter(state=0,action){
            switch(action.type){
                case "INCREMENT":
                    return state + 1;
                case "DECREMENT":
                    return state - 1;
                default :
                    return state;
            }
        }

        /**
        *创建Redux store来存放应用的状态
        */
        let store = createStore(counter);

        //可以手动订阅更新也可以事件绑定到视图层
        store.subscribe( ()=>{
            console.log(store.getState());
        });

        //改变内部state的唯一方式是：dispatch一个action
        //action可以被序列化，用日记记录和储存下来，后期还可以以回放的方式执行
        store.dispatch({type:"INCREMENT"});
        //你应该把要做的修改变成一个普通的对象，这个对象被叫做action，而不是直接修改state。然后编写
        专门的函数来决定每个action如何改变应用的state，这个函数被叫做reducer。

        和Flux相比：Redux 没有 Dispatcher 且不支持多个 store。相反，只有一个单一的 store 和一个根级的 reduce 函数（reducer）。
        随着应用不断变大，你应该把根级的 reducer 拆成多个小的 reducers，分别独立地操作 state 树的不同部分，
        而不是添加新的 stores。这就像一个 React 应用只有一个根级的组件，这个根组件又由很多小组件构成。
3.介绍
    》动机
        随着js单页应用开发日趋复杂，js需要管理比任何时候都要多的state(状态)。这些state可能包括服务器响应、
        缓存数据，本地生成尚未持久化到服务器的数据，也包括UI状态，如激活的路由，被选中的标签，是否显示加载
        动效或分页器等等。
        通过限制更新发生的时间和方式，Redux 试图让 state 的变化变得可预测。
    》核心概念
        》当使用普通对象来描述应用的state，如：todo应用的state
            {
                todos:[
                    {
                        text:"Eat food",
                        completed:true
                    },
                    {
                        text:"Exercise",
                        completed:false
                    }
                ],
                visibilityFilter:"SHOW_COMPLETED"
            }
            //这个对象就像Model，区别是他并没有setter(修改器方法)，因此其它的代码不能随意修改它，
            //造成难以复现的bug。
        》想更新state中的数据，需要发起一个action，Action就是一个普通的js对象，用于描述发生了什么。
            如：
            { type: 'ADD_TODO', text: 'Go to swimming pool' }
            { type: 'TOGGLE_TODO', index: 1 }
            { type: 'SET_VISIBILITY_FILTER', filter: 'SHOW_ALL' }
            //强制使用action来描述所有变化带来的好处是可以清晰的知道应用中发生了什么。
            //如果一些东西改变了，就可以知道为什么变。action就像是描述发生了什么的面包屑。
        》最终为了把action和state串起来，开发一些函数这就是reducer。reducer只是一个接收
          state和action，并返回新的state的函数。对于大的应用来说，可能很难开发这样的函数，
          所以我们编写很多小的函数来分别管理state的一部分。
             如：
                function visibilityFilter(state="SHOW_ALL",action){
                    if(action.type === 'SET_VISIBILITY_FILTER'){
                        return action.filter;
                    }else{
                        return state;
                    }
                }
                function todos(state = [],action){
                    switch(action.type){
                        case "ADD_TODO":
                            return state.concat([{text:action.text,completed:false}]);
                        case "TOGGLE_TODO":
                            return state.map((todo.index) => {
                                action.index === index ?
                                {text:todo.text,completed:!todo.completed}:
                                todo
                            });
                        default:
                            return state;
                    }
                }

                //在开发一个reducer调用上面两个reducer，进而来管理整个应用的state
                function todoApp(state={},action){
                    return {
                        todos:todos(state.todos,action),
                        visibilityFilter:visibilityFilter(state.visibilityFilter,action)
                    }
                }
        上面的思路就是Redux的思想，而Redux的API主要是用于来简化上面的操作。

    》三大原则
        》单一数据源
            整个应用的 state 被储存在一棵对象tree中，并且这个对象树只存在 唯一一个store中。

            这让同构应用开发变得非常容易。来自服务器的state可以在无需编写更多代码的情况下，被序列化并注入到
            客户端中。由于是单一的state tree，调试也变得非常容易。在开发中，你可以把应用的state保存在本地，从
            而加快开发速度，此外受益于单一的state树，以前难以实现的"撤销或重做"这类功能也变得轻而易举。

            console.log(store.getState());
            //输出
            {
              visibilityFilter: 'SHOW_ALL',
              todos: [
                {
                  text: 'Consider using Redux',
                  completed: true,
                },
                {
                  text: 'Keep all state in a single tree',
                  completed: false
                }
              ]
            }

        》State是只读的
            唯一改变state的方法就是触发action，action是一个用于描述已发生事件的普通对象。

            这样确保了视图和网络请求都不能直接修改state，相反他们只能表达想要修改的意图。
            因为所有的修改都被集中化处理，且严格按照一个接着一个的顺序执行，因此不用担心
            race condition的出现。Action就是普通对象而已，因此他们可以被日志打印、序列化、
            储存、后期调试或测试时回放出来。

            store.dispatch({
              type: 'COMPLETE_TODO',
              index: 1
            })

            store.dispatch({
              type: 'SET_VISIBILITY_FILTER',
              filter: 'SHOW_COMPLETED'
            })

        》使用纯函数来执行修改
            为了描述action如何改变state树，你需要编写reducers。

            Reducer只是一些纯函数，它接收先前的state和action，并返回新的state。
            刚开始你可以只有一个reducer，随着应用变大，你可以把它拆成多个小的reducers。分别独立的操作
            state树的不同部分，因为reducer只是函数，你可以控制他们被调用的顺序，传入附加数据，甚至编写可
            复用的reducer来处理一些通用任务，如分页器。

            function visibilityFilter(state = 'SHOW_ALL',action){
                switch(action.type){
                    case 'SET_VISIBILITY_FILTER':
                        return action.filter;
                    default:
                        return state;
                }
            }

            function todos(state=[],action){
                switch(action.type){
                    case 'ADD_TODO':
                        return [
                            ...state,
                            {
                                text:action.text,
                                completed:false
                            }
                        ];
                    case "COMPLETE_TODO":
                        return state.map((todo,index) => {
                            if(index === action.index){
                                return Object.assign({},todo,{
                                    completed:true
                                });
                            }

                            return todo;
                        });
                    default:
                        return state;
                }
            }

            import {combineReducers,createStore} from 'redux'
            let reducer = combineReducers ({ visibilityFilter, todos });//合并所有的reducer
            let store = createStore(reducer);//创建store

    》先前技术
        Redux是一个混合产物。它和一些设计模式以及技术相似，但也有不同之处。

        》Flux
            》和Flux一样，Redux规定将模型的更新逻辑全部集中于一个特定的层。Flux的store，Redux的reducer。Flux和Redux
              都不允许程序直接修改数据，而是用一个叫action的普通对象来对更改进行描述
            》不同于Flux，Redux并没有dispatcher的概念。原因是它依赖于纯函数来替代事件处理器。纯函数构建简单，也不需额外的
              实体来管理它们。
              Flux常常被表示为(state,action) => state 从这个意义上来说，Redux无疑是Flux的实现，且得益于纯函数更简单。
            》和Flux的另一个重要区别是Redux设想你永远不会变动你的数据。可以很好的使用普通对象和数组来管理state，而不是在多个
              reducer里面变动数据，正确且简单的方式是在reducer中返回一个新对象来更新state，同时配合object运算符或一些库如：Immutable。
        》Elm
            Elm是一种函数式编程语言，它执行一种"model view update"的架构，更新遵循(state,action) => state的规则。Elm的"updater"与Redux
            的"reducer"服务于相同的目的。

            不同于Redux，Elm是一门语言，它在执行纯度，静态类型，不可变动性，action和模式匹配等方面更具有优势。
        》Immutable
            Immutable是一个可实现持久数据结构的js库，它性能很好，且命名符号js API的语言习惯。
            Immutable以及类似的库都可以与Redux对接良好。

            Redux并不在意你如何存储state，state可以是普通对象，不可变对象，或其他类型。
        》Baobab
            Baobab是另一个流行的库，它实现了数据不可变特性的API，用于更新纯js对象。可以在Redux中使用它，但是两者一起使用并没有什么优势。

            Baobab所提供的大部分功能都与使用cursors更新数据相关，而Redux更新数据的唯一方法是分发一个action，可见两者用不同方法解决的是
            同样的问题相互并无增益。

            不同于 Immutable ，Baobab 在引擎下还不能现实任何特别有效的数据结构，同时使用 Baobab 和 Redux 并无裨益。这种情形下，使用
            普通对象会更简便。
        》Rx
            Reactive Extensions是管理复杂异步应用非常优秀的方案。以外，还有致力于构建将人机交互作模拟为相互依赖的可观测变量的库。

            Rx和Redux可以配合的很好，将Redux store视作可观察变量非常简便，如：
                function toObservable(store){
                    return {
                        subscribe({onNext}){
                            let dispose = store.subscribe( () => onNext(store.getState) );

                            onNext(store.getState());
                            return {dispose}
                        }
                    }
                }

    》生态系统
        Redux 是一个体小精悍的库，但它相关的内容和 API 都是精挑细选的，足以衍生出丰富的工具集和可扩展的生态系统。
        http://cn.redux.js.org/docs/introduction/Ecosystem.html
4.基础
    》Action
        Action是把数据(服务器响应、用户输入、或其他非view的数据)从应用传到store的有效载荷。它是store数据的唯一来源。
        一般来说你会通过store.dispatch()将action传到store。

        Action本质上是js普通对象，我们约定，***action内必须使用一个字符串类型的type字段来表示将要执行的动作****。多数情况下
        type会被定义成字符串常量，当应用规模越来越大时，建议使用单独的模块或文件来存放action。
            import {ADD_TODO,REMOVE_TODO} from './actionTypes'
        除了type字段外，action对象的结构完全由你自己决定。

        我们应该尽量减少在action中传递的数据，如传递index就比把整个任务对象传过去要好。
            {
                type:TOGGLE_TODO,
                index:5
            }
        》Action创建函数
            Action创建函数就是生成action的方法。
            在Redux中的action创建函数只是简单的返回一个action：
                function addTodo(text){
                    return {
                        type:ADD_TODO,
                        text
                    }
                }
            在传统的Flux实现中，当调用action创建函数时，一般会触发一个dispatch：
                function addTodoWithDispatch(text){
                    const action = {
                        type:ADD_TODO,
                        text
                    }

                    dispatch(action);
                }
            不同的是Redux只需把action创建函数的结果传给dispatch()方法即可发起一次dispatch过程。
                dispatch(addTodo(text));
            或者创建一个被绑定的action的创建函数来自动dispatch。
                const boundAddTodo = text => dispatch(addTodo(text));
                //然后直接调用它们
                boundAddTodo(text);

            store里能直接通过store.dispatch()调用dispatch()方法，但是多数情况下你会使用react-redux提供的connect()帮助器来调用。
            bindActionCreators()可以自动把多个action创建函数绑定dispatch()方法上。

            Action创建函数也可以是异步非纯函数。

            //actions.js 源码示例

            //action类型
            export const ADD_TODO = 'ADD_TODO'
            export const TOGGLE_TODO = 'TOGGLE_TODO'
            export const SET_VISIBILITY_FILTER = 'SET_VISIBILITY_FILTER'

            //其它常量
            export const VisibilityFilters = {
                SHOW_ALL : "SHOW_ALL",
                SHOW_COMPLETED:"SHOW_COMPLETED",
                SHOW_ACTIVE:"SHOW_ACTIVE"
            }

            //action创建函数
            export function addTodo(text){
                return {type:ADD_TODO ,text}
            }
            export function toggleTodo(index){
                return {type:TOGGLE_TODO,index}
            }
            export function setVisibilityFilter(filter){
                return {type:SET_VISIBILITY_FILTER,filter}
            }
    》Reducer
        Action只是描述来有事情发生了这一事实，并没有指明应用如何更新state。而这正是reducer要做的事情。
        》设计state结构
            在Redux应用中，所有的state都被保存在一个单一对象中。
            以todo应用为例，需要保存两种不同的数据：
                》当前选中的任务过滤条件
                》完整的任务列表
            通常这个State树还需要存放其他一些数据，以及一些UI相关的state。这样做没问题但尽量把这些数据与UI相关的state分开。
                {
                    visibilityFilter:"SHOW_ALL",
                    todos:[
                            {
                              text: 'Consider using Redux',
                              completed: true,
                            },
                            {
                              text: 'Keep all state in a single tree',
                              completed: false
                            }
                    ]
                }
            注意：在开发复杂的应用时，不可避免会有一些数据相互引用。建议尽可能把state范式化，不存在嵌套。把所有数据放到一个对象
            里面，每个数据以ID为主键，不同实例或列表间通过ID相互引用数据。
    》Action处理 -- reducer
        reducer是一个纯函数，接收旧的state和action，返回新的state。
            (previous,action) => newState;
        之所以将这样的函数称为reducer，是因为这种函数与被传入Array.prototype.reduce(reducer,?initialValue)里面的回调函数属于相同
        类型。

        保持reducer纯净是非常重要的，**永远不要再reducer里面做下面这些操作：**
            》修改传入参数
            》执行有副作用的操作，如API请求和路由跳转
            》调用非纯函数，如Date.now()或Math.random()
        只要传入参数相同，返回计算得到的下一个state就一定相同，没有特殊情况、没有副作用、没有API请求。没有变量修改，单纯执行计算。

        将以指定state的初始状态作为开始，Redux首次执行时，state为undefined，此时我们可以借机设置并返回应用的初始state
            import {VisibilityFilters} from './actions'

            const initialState = {
                visibilityFilter:VisibilityFilters.SHOW_ALL,
                todos:[]
            }

            function todoApp(state,action){
                //reducer首次执行
                if(typeof state === 'undefined') return initialState;

                //返回传入的state
                return state;
            }
            //使用ES6的默认值语法 简化代码
            function todoApp(state = initialState,action){

                //返回传入state
                return state;
            }
            //处理SET_VISIBILITY_FILTER,即改变state中的visibilityFilter
            function todoApp(state = initialState,action){
                switch(action.type){
                    case SET_VISIBILITY_FILTER:
                        return Object.assign({},state,{
                            visibilityFilter:action.filter//修改visibilityFilter
                        });
                    default:
                        return state;
                }
            }
            注意：
                》不要修改state。使用Object.assign()新建了一个副本。不能这样使用Object.assign(state,{
                        visibilityFilter:action.filter}),因为他会改变第一个参数的值，你必须把第一个参数设置为空对象。
                   你也可以开启对ES7提案对象展开运算符从而使用{...state,...newState}达到相同的目的。
                》在default情况下返回旧的state，遇到未知的action时一定要返回旧的state。
                    Object.assign()是ES6特性，但多数浏览器并不支持，要么使用polyfill，Babel插件或者使用其他库如：_.assign()提供帮助方法。

                    switch 语句并不是严格意义上的样板代码。Flux 中真实的样板代码是概念性的：更新必须要发送、Store 必须要注册到 Dispatcher、Store
                    必须是对象（开发同构应用时变得非常复杂）。为了解决这些问题，Redux 放弃了 event emitters（事件发送器），转而使用纯 reducer。

                    很多人存在一个误区：根据文档中是否使用 switch 来决定是否使用它。如果你不喜欢 switch，完全可以自定义一个 createReducer 函数
                    来接收一个事件处理函数列表，参照"减少样板代码"。
        》处理多个action
            function todoApp(state=initialState,action){
                switch(action.type){
                    case SET_VISIBILITY_FILTER:
                        return Object.assign({},state,{
                            visibilityFilter:action.filter
                        });
                    case ADD_TODO:
                        return Object.assign({},state,{
                            todos:[
                                ...state.todos,
                                {
                                    text:action.text,
                                    completed:false
                                }
                            ]
                        });
                    case TOGGLE_TODO:
                        return Object.assign({},state,{
                            todos:state.todos.map((todo,index) => {
                                if(index === action.index){
                                    return Object.assign({},todo,{
                                        completed: !todo.completed
                                    })
                                }
                                return todo;
                            })
                        });
                    default:
                        return state;
                }
            }
        》拆分Reducer
            function todos(state = [],action){
                switch(action.type){
                    case ADD_TODO:
                        return [
                            ...state,
                            {
                                text:action.text,
                                completed:false
                            }
                        ];
                    case TOGGLE_TODO:
                        return state.map((todo,index) =>{
                            if(index === action.index){
                                return Object.assign({},todo,{
                                    completed:!todo.completed
                                });
                            }

                            return todo;
                        });
                    default:
                        return state;
                }
            }

            function todoApp(state = initialState,action){
                switch(action.type){
                    case SET_VISIBILITY_FILTER:
                        return Object.assign({},state,{
                            visibilityFilter:action.filter
                        });
                    case ADD_TODO:
                    case TOGGLE_TODO:
                        return Object.assign({},state,{
                            todos:todos(state.todos,action)
                        });
                    default:
                        return state;
                }
            }
            //上面就是所谓的reducer合成，它是开发Redux应用最基础的模式

            //抽出一个reducer管理visibilityFilter
            function visibilityFilter(state = SHOW_ALL,action){
                switch(action.type){
                    case SET_VISIBILITY_FILTER:
                        return action.filter
                    default:
                        return state;
                }
            }

            //开发一个函数来作为主reducer，它调用多个子reducer分别处理state中的一部分数据，然后再把这些数据合成一个大的单一对象。
            //主reducer并不需要设置初始化时完整的state，初始时，如果传入undefined，子reducer将负责返回它们的默认值
            function todoApp(state = {},action){
                return {
                    visibilityFilter:visibilityFilter(state.visibilityFilter,action),
                    todos:todos(state.todos,action);
                }
            }
            //注意：每个reducer只负责管理全局state中它负责的一部分。每个reducer的state参数都不相同，分别对应它管理的那部分state数据。

            //Redux提供了combineReducers()工具类来做上面todoApp的事情,这样能消灭一些样本代码。
            import {combineReducers} from 'redux'
            export default const todoApp = combineReducers({
                visibilityFilter,
                todos
            });
            //这个和上面自定义的todoApp是等价的

            //你也可以给它们设置不同的key或调用不同的函数
            const reducer = combineReducers({
              a: doSomethingWithA,
              b: processB,
              c: c
            })
            等价于
            function reducer(state = {}, action) {
              return {
                a: doSomethingWithA(state.a, action),
                b: processB(state.b, action),
                c: c(state.c, action)
              }
            }
            combineReducers()所做的只是生成一个函数，这个函数来调用你的一系列reducer，每个reducer根据他的key来筛选出state中的一部分数据
            并处理，然后这个生成的函数再将所有的reducer的结果合并成一个大的对象。正如其他reducers，如果combineReducers中包含的所有reducers
            都没有更改state，那么也就不会创建一个新的对象。

            注意：
                combineReducers接收一个对象，可以把所有顶级的reducer放到一个独立的文件中，通过export暴露出每个reducer函数，然后使用
                import * as reducers得到一个以它们名字作为key的object：
                    import {combineReducers} from 'redux'
                    import * as reducers from './reducers'
                    const todoApp = combineReducers(reducers);
        》todo案例
            reducers.js
                import { combineReducers } from 'redux'
                import { ADD_TODO, TOGGLE_TODO, SET_VISIBILITY_FILTER, VisibilityFilters } from './actions'
                const { SHOW_ALL } = VisibilityFilters

                function visibilityFilter(state = SHOW_ALL, action) {
                  switch (action.type) {
                    case SET_VISIBILITY_FILTER:
                      return action.filter
                    default:
                      return state
                  }
                }

                function todos(state = [], action) {
                  switch (action.type) {
                    case ADD_TODO:
                      return [
                        ...state,
                        {
                          text: action.text,
                          completed: false
                        }
                      ]
                    case TOGGLE_TODO:
                      return state.map((todo, index) => {
                        if (index === action.index) {
                          return Object.assign({}, todo, {
                            completed: !todo.completed
                          })
                        }
                        return todo
                      })
                    default:
                      return state
                  }
                }

                const todoApp = combineReducers({
                  visibilityFilter,
                  todos
                })

                export default todoApp
    》Store
        action用来描述发生了什么
        reducers根据action更新state

        Store就是把它们联系到一起的对象，Store的职责：
            》维持应用的state
            》提供getState()方法获取state
            》提供dispatch(action)方法更新state
            》通过subscribe(listener)注册监听器
            》通过subscribe(listener)返回的函数注销监听器

        注意：Redux应用只有一个单一的store。当需要拆分数据处理逻辑时，你应该使用reducer组合而不是创建多个store。

        根据已有的reducer来创建store是非常容易的。
        import {createStore} from 'redux'
        import todoApp from './reducers'

        let store = createStore(todoApp);

        createStore()的第二个参数是可选的，用于设置state初始状态。这对开发同构应用时非常有用，服务器端redux应用的state
        结构可以与客户端保持一致，那么客户端可以将从网络接收到的服务端state直接用于本地数据初始化。
            let store = createStore(todoApp,window.STATE_FROM_SERVER);

        》发起Actions
            //获取状态
            store.getState()

            //每次state更新时，打印日志 unsubscribe--注销监听器
            let unsubscribe = store.subscribe(() =>{
                console.log(store.getState());
            });

            //发起action
            store.dispatch(action);

            //停止监听state更新
            unsubscribe();
        》todo案例 源码
            index.js
                import {createStore} from 'redux'
                import todoApp from './reducers'

                let store = createStore(todoApp);
    》数据流
        严格的单向数据流是Redux架构的设计核心。
        这意味着应用中所有的数据都遵循相同的生命周期，这样可以让应用变得更加可预测且容易理解。同时也鼓励做数据范式化
        这样可以避免使用多个且独立的无法相互引用的重复数据。

        Redux应用中数据的生命周期遵循下面几个步骤：
            》调用store.dispatch(action);
                可以在任何地方调用store.dispatch(action)，包括组件中，XHR回调中，甚至定时器中。
            》Redux store调用传入的reducer函数
                Store会把两个参数传入根reducer：当前的state树和action。
            》根reducer应该把多个子reducer输出合并成一个单一的state树
                根reducer的结构完全由你决定。Redux原生提供combineReducers()辅助函数，来把根reducer拆分成多个函数，用于分别处理
                state树的一个分支。
                    如：
                        function todos(state = [], action) {
                           // 省略处理逻辑...
                           return nextState;
                         }

                         function visibleTodoFilter(state = 'SHOW_ALL', action) {
                           // 省略处理逻辑...
                           return nextState;
                         }

                         let todoApp = combineReducers({
                           todos,
                           visibleTodoFilter
                         })
                当触发action后，combineReducers返回的todoApp会负责调用两个reducer。
                        let nextTodos = todos(state.todos, action);
                        let nextVisibleTodoFilter = visibleTodoFilter(state.visibleTodoFilter, action);
                然后把这两个结果集合成一个state树
                         return {
                           todos: nextTodos,
                           visibleTodoFilter: nextVisibleTodoFilter
                         };
                //虽然combineReducers()是一个很方便的辅助工具，你可以选择不用；你也可以自行实现自己的根reducer。
            》Redux store保存了根reducer返回的完整state树
                这个新的树就是应用的下一个state，所有的订阅store.subscribe(listener)的监听器都将被调用；监听器里可以
                调用store.getState()获得当前state。

                然后使用新的state更新UI。如果使用了React Redux这类的绑定库，这时就应该调用component.setState(newState)来更新。
    》搭配React
        注意：Redux和React之间没有关系。Redux支持React、Angular、Ember、Jquery甚至纯js。

        尽管如此，Redux还是和React和Deku这类框架搭配起来用最好，因为这类框架允许你以state函数的形式来描述界面，Redux通过action
        的形式来发起state变化。

        》安装React Redux
            Redux默认并不包含React绑定库，需要单独安装
            npm install --save react-redux
        》容器组件 Smart/Container Components和展示组件Dumb/Presentational Components
            Redux的React绑定库是基于 容器组件和展示组件相分离 的开发思想。
                            展示组件                容器组件
            作用          描述如何展示(骨架、样式)  描述如何运行(数据获取、状态更新)
            直接使用Redux 否                        是
            数据来源      props                     监听Redux state
            数据修改      从props调用回调函数       向Redux派发actions
            调用方式      手动                      通常由React Redux生成

            大部分的组件都应该是展示型的，但是一般需要少数的几个容器组件把它们和Redux store连接起来
            技术上将你可以直接使用store.subscribe()来编写容器组件。但不建议这么做因为就无法使用React Redux带来的性能优化。
            也因此不要手动写容器组件，都是使用React Redux的connect()方法来生成的。
        》设计组件层次结构
            》展示组件
                TodoList 用于显示todos列表
                    todos:Array以{text,completed}形式显示todo项数组
                    onTodoClick(index:number)当todo项被点击时调用的回调函数
                Todo 一个todo项
                    text:string 显示的文本内容
                    completed:boolean todo项是否显示删除线
                    onClick() 当todo项被点击时调用的回调函数
                Link 带有callback回调功能的链接
                    onClick 点击链接时会触发
                Footer 一个允许用户改变可见todo过滤器的组件
                App 根组件，渲染其他的所有内容

                这些组件只定义外观并不关心数据来源和如何改变，传入什么就渲染什么。如果你把代码从Redux迁移到别的架构，这些组件可以不做
                任何改动直接使用。它们并不依赖于Redux。
            》容器组件
                还需要一些容器组件来把展示组件链接到Redux。如：展示型的TodoLIst组件需要一个类似的VisibleTodoList的容器来监听
                Redux store变化并处理如何过滤出要显示的数据。为了实现状态过滤，需要实现FilterLink的容器组件来渲染Link并在点击时
                触发对应的action：
                VisibleTodoList 根据当前显示的状态来对todo列表进行过滤，并渲染TodoList
                FilterLink 得到当前过滤器并渲染Link
                    filter: string就是当前过滤的状态
            》其他组件
                有时候很难分清到底该使用容器组件还是展示组件，如：有时表单和函数严重耦合在一起，如：
                    AddTodo 含有Add按钮的输入框
                技术上将可以把他们分成两个组件，但一开始就这么做有点造，在一些非常小的组件里混用容器和展示时可以的。
                当业务变复杂后，如何拆分就很明显了，所以现在就使用混合型的中。
        》组件编码
            》展示组件
               //components
            》容器组件
                技术上讲，容器组件就是使用store.subscribe()从Redux state树中读取部分数据，并且通过props来把这些数据
                提供给要渲染的组件。
                你可以手工来开发容器组件，但建议使用React Redux的connect()方法来生成，这个方法做了性能优化来避免很多不必要的重复
                渲染。这样你就不必为了性能而手动实现React性能优化建议中的shouldComponentUpdate方法了。

                使用connect()前，需要先定义mapStateToProps这个函数来指定如何把当前Redux store state映射到展示组件的props中。
                如VisibleTodoList需要计算传到TodoList中的todos，所以定义了根据state.visibilityFilter来过滤state.todos的方法
                并在mapStateToProps中使用。
                    const getVisibleTodos = (todos,filter) => {
                        switch(filter){
                            case 'SHOW_ALL':
                                return todos;
                            case 'SHOW_COMPLETED':
                                return todos.filter(t => t.completed);
                            case 'SHOW_ACTIVE':
                                return todos.filter(t => !t.completed);
                        }
                    }

                    const mapStateToProps = (state) => {
                        return {
                            todos:getVisibleTodos(state.todos,state.visibilityFilter)
                        }
                    }
                除了读取state，容器组件还能分发action，类似的方式，可以定义mapDispatchToProps()方法接收dispatch()方法
                并返回期望注入到展示组件的props中的回调方法。如：VisibleTodoList向TodoList组件注入一个叫onTodoClick的
                props中，还希望onTodoClick能分发TOGGLE_TODO这个action：
                    const mapDispatchToProps = (dispatch) => {
                        return {
                            onTodoClick: id => {
                                dispatch(toggleTodo(id))
                            }
                        }
                    }
                最后使用connect()创建VisibleTodoList并传入这两个函数
                    import {connect} from 'react-redux'

                    const VisibleTodoList = connect(mapStateToProps,mapDispatchToProps)(TodoList);

                    export default VisibleTodoList;
                Todo案例容器组件：containers
            》传入Store
                所有容器都可以访问Redux store，所以可以手动监听它。一种方式是把它以props的形式传入到所有容器组件中。但这太麻烦了
                因为必须要用store把展示组件包裹一层，仅仅是因为恰好咋组件树种渲染了一个容器组件
                建议的方式是使用指定的React Redux组件的<Provider>来让所有容器组件都可以访问store，而不必显示地传递它，只需要在渲染
                根组件时使用即可。
                //index.js
                import React from 'react'
                import {render} from 'react-dom'
                import {Provider} from 'react-redux'
                import {createStore} from 'redux'
                import todoApp from './reducers'
                import App from './components/App'

                let store = createStore(todoApp);
                render(
                    <Provider store={store}><App/></Provider>,document.getElementById('app');
                );
        》示例 Todo List
5.高级
    》异步Action
        》Action
            当调用异步API时，有两个非常关键的时刻：发起请求的时刻和接收响应的时刻(也可能是超时)
            这两个时刻都可能会更改应用的state；为此你需要dispatch普通的 同步action。一般情况下，每个API
            请求都需要dispatch至少三种action：
            》一种通知reducer请求开始的action
                对于这种action，reducer可能会切换一下state中的isFetching标记，以此来告诉UI来显示加载界面
            》一种通知reducer请求成功的action
                对于这个action，reducer可能会把接收到的新数据合并到state中，并重置isFetching。UI则会隐藏
                加载界面，并显示接收到的数据。
            》一种通知reducer请求失败的action
                对于这种action，reducer可能会重置isFetching，另外有些reducer会保存这些失败信息，并在UI里显示出来。
            为了区分这三种action，可能在action里面添加一个专门的status字段作为标记位
            {type:"FETCH_POSTS"}
            {type:"FETCH_POSTS",status:"error",error:"Oops"}
            {type:"FETCH_POSTS",status:"success",response:{...}}
            又或者为它们定义不同的type：
            { type: 'FETCH_POSTS_REQUEST' }
            { type: 'FETCH_POSTS_FAILURE', error: 'Oops' }
            { type: 'FETCH_POSTS_SUCCESS', response: { ... } }
        》同步Action创建函数
            /**
             * 同步action类型和action的创建函数
             * @type {string}
             */
            export const SELECT_SUBREDDIT = 'SELECT_SUBREDDIT'
            export function selectSubreddit (subreddit){
              return {
                type:SELECT_SUBREDDIT,
                subreddit
              }
            }

            export const INVALIDATE_SUBREDDIT = 'INVALIDATE_SUBREDDIT'
            export function invalidatesubreddit(subreddt){
              return {
                type:INVALIDATE_SUBREDDIT,
                subreddt
              }
            }

            /**
             * 定义异步请求的action
             * @type {string}
             */
            export const REQUEST_POSTS = 'REQUEST_POSTS'
            export function requestPosts(subreddit){
              return {
                type:REQUEST_POSTS,
                subreddit
              }
            }

            /**
             * 定义异步响应的action
             * @type {string}
             */
            export const RECEIVE_POSTS = 'RECEIVE_POSTS'
            export function receivePosts(subreddit,json){
              return {
                type:RECEIVE_POSTS,
                subreddit,
                posts:json.data.children.map(child => child.data),
                receivedAt:Date.now()
              }
            }
        》设计state结构
            如：Reddit头条
            {
              selectedsubreddit: 'frontend',
              postsBySubreddit: {
                frontend: {
                  isFetching: true,//来显示进度条
                  didInvalidate: false,//标记数据是否过期
                  items: []//列表数据本身
                },
                reactjs: {
                  isFetching: false,
                  didInvalidate: false,
                  lastUpdated: 1439478405547,//最后更新时间
                  items: [
                    {
                      id: 42,
                      title: 'Confusion about Flux and Relay'
                    },
                    {
                      id: 500,
                      title: 'Creating a Simple Application Using React JS and Flux Architecture'
                    }
                  ]
                }
              }
            }
        》处理Action
            import {combineReducers} from 'redux'
            import { SELECT_SUBREDDIT,INVALIDATE_SUBREDDIT,RECEIVE_POSTS,REQUEST_POSTS } from './actionsAsyn'

            function selectedsubreddit(state='reactjs',action){
              switch (action.type){
                case SELECT_SUBREDDIT:
                  return action.subreddit
                default:
                  return state;
              }
            }

            function posts(state = {isFetching:false,didInvalidata:false,items:[]},action){
              switch(action.type){
                case INVALIDATE_SUBREDDIT:
                  return Object.assign({},state,{
                    didInvalidata:true
                  })
                case REQUEST_POSTS:
                  return Object.assign({},state,{
                    isFetching:true,
                    didInvalidate:false
                  })
                case RECEIVE_POSTS:
                  return Object.assign({},state,{
                    isFetching:false,
                    didInvalidata:false,
                    items:action.posts,
                    lastUpdated:action.receivedAt
                })
                default:
                  return state;
              }
            }

            function postsBySubreddit(state = {},action){
              switch(action.type){
                case INVALIDATE_SUBREDDIT:
                case RECEIVE_POSTS:
                case REQUEST_POSTS:
                  return Object.assign({},state,{
                    [action.subreddit]:posts(state[action.subreddit],action)
                  })
                default:
                  return state;
              }
            }

            const rootReducer = combineReducers({
              postsBySubreddit,
              selectedsubreddit
            })

            export default rootReducer
        》异步action创建函数
            如何把之前定义的同步action创建函数和网络请求结合起来？标准的做法是使用Redux Thunk中间件。要引入redux-thunk
            这个专门的库才能使用。通过使用指定的middleware(中间件),action创建函数除了返回action对象外还可以返回函数，这时
            这个action创建函数就成为来thunk。

            当action创建函数返回函数时，这个函数会被Redux Thunk middleware执行。这个函数并不需要保存纯净，它还可以带有副作用
            包括执行异步API。这个函数还可以dispatch action 就像dispatch前面定义的同步action一样。

            //大多数浏览器还不支持fetch，建议使用isomorphic-fetch库
            import fetch from 'isomorphic-fetch'

            export const  REQUEST_POSTS = 'REQUEST_POSTS'
            function requestPosts(subreddit){
              return {
                type:REQUEST_POSTS,
                subreddit
              }
            }

            export const RECEIVE_POSTS = 'RECEIVE_POSTS'
            function receivePosts (subreddit,json){
              return {
                type:RECEIVE_POSTS,
                subreddit,
                posts:json.data.children.map(child => child.data),
                receivedAt:Date.now()
              }
            }

            /**
             * thunk action创建函数
             */
            export function fetchPosts(subreddit){
              /**
               * Thunk middleware知道如何处理函数
               * 把dispatch房费通过参数的形式传给函数 以此让它自己能dispatch action
               */
              return function(dispatch){
                //首次dispatch 更新应用的state来通知API发起请求了
                dispatch(requestPosts(subreddit));

                /**
                 * thunk middleware调用的函数可以有返回值，它会被当作dispatch方法的返回值传递
                 * 这个案例中我们返回一个等待处理的promise，这不是redux middleware所必须的，但对于我们而言很方便
                 */
                return fetch(`http://www.subreddit.com/r/${subreddit}.json`)
                  .then(response => response.json())
                  .then(json =>{
                      //可以多次dispatch
                     //这里使用请求结果更新应用的state
                      dispatch(receivePosts(subreddit,json));
                    }
                  )
              }
            }
        》如何在dispatch机制中引入Redux Thunk middleware？ 使用applyMiddleware()即可
            //index.js
            import thunkMiddleware from 'redux-thunk'
            import createLogger from 'redux-logger'
            import {createStore,applyMiddleware} from 'redux'
            import {selectSubreddit,fetchPosts} from './actions'
            import rootReducer from './reducers'

            const loggerMiddleware = createLogger();

            const store = createStore(
                rootReducer,
                applyMiddleware(
                    thunkMiddleware,//允许我们dispatch()函数
                    loggerMiddleware//一个很便捷的middleware用来打印action日志
                )
            );
            store.dispatch(selectSubreddit('reactjs'))
            //thunk的优点是它的结果可以再次被dispatch
            store.dispatch(fetchPost('reactjs')).then( ()=>
                console.log(store.getState());
            )
        注意：异步action创建函数对于做服务端渲染非常方便，你可以创建一个store，dispatch一个异步action创建函数，这个action
        创建函数又dispatch另一个异步action创建函数来为应用的一整块请求数据，同时在Promise完成和结束时才render界面。然后再render
        前，store里就已经存在了需要的state。

        Thunk middleware并不是Redux处理异步action的唯一方式：
            你可以使用 redux-promise 或者 redux-promise-middleware 来 dispatch Promise 来替代函数。
            你可以使用 redux-observable 来 dispatch Observable。
            你可以使用 redux-saga 中间件来创建更加复杂的异步 action。
            你可以使用 redux-pack 中间件 dispatch 基于 Promise 的异步 Action。
            你甚至可以写一个自定义的 middleware 来描述 API 请求，就像这个 真实场景的案例 中的做法一样。
    》异步数据流
        默认情况下，createStore()所创建的Redux store没有使用middleware，所以只支持同步数据流。
        你可以使用applyMiddleware()来增强createStore(),虽然这不是必须的，但它可以帮你用简便的方式来描述异步的action。

        像redux-thunk或redux-promise这样支持异步的middleware都包装了store的dispatch()方法，以此来让你的dispatch一些除了action
        以外的其他内容，例如：函数或者 Promise。你所使用的任何 middleware 都可以以自己的方式解析你 dispatch 的任何内容，并继续传递
        actions 给下一个 middleware。比如，支持 Promise 的 middleware 能够拦截 Promise，然后为每个 Promise 异步地 dispatch 一对
        begin/end actions。

        当middleware链中的最后一个middleware开始dispatch action时，这个action必须是一个普通对象。这是同步式的redux数据流开始的地方。
    》Middleware
        Redux middleware提供的是位于action被发起之后，到达reducer之前的扩展点。你可以利用Redux middleware来进行日志记录，创建崩溃报告
        调用异步接口或路由等等。
        》理解Middleware
            》记录日志
                Redux的一个益处就是它让state的变化过程变得可预知和透明。每当一个action发起完成后，新的state就会被计算并保存下来。
                state不能被自身修改，只能由特定的action引起变化。

                》手动记录
                    最直接的方案：在每次调用store.dispatch(action)前后手动记录被发起的action和新的state。
                    注意：如果你使用 react-redux 或者类似的绑定库，最好不要直接在你的组件中操作 store 的实例。
                          在接下来的内容中，仅仅是假设你会通过 store 显式地向下传递。
                    let action = addTodo('Use Redux');

                    console.log('dispatching',action);
                    store.dispatch(action);
                    console.log('next state',store.getState());
                》封装Dispatch
                    function dispatchAddLog(store,action){
                          console.log('dispatching', action)
                          store.dispatch(action)
                          console.log('next state', store.getState())
                    }
                》Monkeypatching Dispatch
                    直接替换store实例中的dispatch函数，Redux store只是一个包含一些方法的普通对象，因此我们可以对其dispatch进行拓展。
                    let next = store.dispatch;
                    store.dispatch = function dispatchAndLog(action){
                        console.log('dispatching',action);
                        let result = next(action);
                        console.log('next state',store.getState());
                        return result;
                    }
            》崩溃报告
                如果我们想对dispatch附加超过一个的变换呢，在生产过程中报告js的错误，全局的window.onerror并不可靠
                因为它在一些旧的浏览器中无法提供错误堆栈，而这个排除错误所需的至关重要的信息。
                然而将日志记录和崩溃报告分离是很重要的，理想情况下，希望他们是两个不同的模块，也可能在不同的包中。
                否则我们无法构建一个由这些工具组成的生态系统。
                //日志记录
                function patchStoreToAddLogging(store){
                    let next = store.dispatch
                    store.dispatch = function dispatchAndLog(action){
                        console.log('dispatching',action);
                        let result = next(action);
                        console.log('next state',store.getState());
                        return result;
                    }
                }

                function patchStoreToAddCrashReporting(store){
                    let nex = store.dispatch
                    store.dispatch = function dispatchAndReportErrors(action){
                        try{
                            return next(action)
                        }catch(err){
                            console.error('捕获一个异常！',err);
                            Raven.captureException(err,{
                                extra:{
                                    action,
                                    state:store.getState()
                                }
                            });
                            throw err;
                        }
                    }
                }
            》隐藏 Monkeypatching
                Monkeypatching本质上是一种hack。将任意的方法替换成你想的样子，
                function logger(store){
                    let next = store.dispatch;
                    return function dispatchAndLog(action){
                        console.log('dispatching', action)
                        let result = next(action)
                        console.log('next state', store.getState())
                        return result
                    }
                }
                //在Redux内部提供一个可以将实际的monkeypatching应用到store.dispatch中的辅助方法
                function applyMiddlewareByMonkeypatching(store,middlewares){
                    middlewares = middlewares.slice()
                  middlewares.reverse()

                  // 在每一个 middleware 中变换 dispatch 方法。
                  middlewares.forEach(middleware =>
                    store.dispatch = middleware(store)
                  )
                }
                //应用多个middleware
                applyMiddlewareByMonkeypatching(store, [ logger, crashReporter ])
            》移除Monkeypatching
                为什么要替换原来的dispatch？这样我们就可以在后面直接调用它。
                但另一个原因：就是每一middleware可以操作(或直接调用)前一个middleware包装过的store.dispatch:

                function logger(store){
                    //这里next必须指向前一个middleware返回的函数
                    let next = store.dispatch
                    return function dispatchAndLog(action){
                        console.log('dispatching', action)
                        let result = next(action)
                        console.log('next state', store.getState())
                        return result
                    }
                }
                如果 applyMiddlewareByMonkeypatching 方法中没有在第一个 middleware 执行时立即替换掉 store.dispatch，
                那么 store.dispatch 将会一直指向原始的 dispatch 方法。也就是说，第二个 middleware 依旧会作用在原始
                的 dispatch 方法。

                但是还有另一种方式来实现这种链式调用的效果。可以让middleware以方法参数的形式接收一个next()方法，而不是通过
                store的实例去获取。
                    function logger(store) {
                      return function wrapDispatchToAddLogging(next) {
                        return function dispatchAndLog(action) {
                          console.log('dispatching', action)
                          let result = next(action)
                          console.log('next state', store.getState())
                          return result
                        }
                      }
                    }
                //简化
                const logger = store =>next => action => {
                      console.log('dispatching', action)
                      let result = next(action)
                      console.log('next state', store.getState())
                      return result
                }
                const crashReporter = store => next => action => {
                  try {
                    return next(action)
                  } catch (err) {
                    console.error('Caught an exception!', err)
                    Raven.captureException(err, {
                      extra: {
                        action,
                        state: store.getState()
                      }
                    })
                    throw err
                  }
                }
                这正是Redux middleware的样子，Middleware接收一个next()的dispatch函数，并返回一个dispatch函数
                返回的函数会被作为下一个middleware的next()，以此类推。由于store中类似getState()的方法依旧非常有用
                ，我们将store作为顶层的参数，使得它可以在所有的middleware中被调用。
            》单纯的使用Middleware
                可以写一个applyMiddleware方法替换掉原来的applyMiddlewareByMonkeypatching。在新的方法中，我们取得
                最终完整被包装过的dispatch函数，并返回一个store的副本。
                function applyMiddleware(store,middlewares){
                      middlewares = middlewares.slice()
                      middlewares.reverse()

                      let dispatch = store.dispatch
                      middlewares.forEach(middleware =>
                        dispatch = middleware(store)(dispatch)
                      )

                      return Object.assign({}, store, { dispatch })
                }
                //这个与Redux中的applyMiddleware的实现已经很接近来，但是也有不同之处
                    》它只暴露一个store API的子集给middleware：dispatch(action)和getState()
                    》它用了一个非常巧妙的方式，以确保如果你在 middleware 中调用的是 store.dispatch(action)
                      而不是 next(action)，那么这个操作会再次遍历包含当前 middleware 在内的整个 middleware 链。
                      这对异步的 middleware 非常有用，正如我们在之前的章节中提到的。
                    》为了保证你只能应用 middleware 一次，它作用在 createStore() 上而不是 store 本身。因此它的签名
                      不是 (store, middlewares) => store， 而是 (...middlewares) => (createStore) => createStore。
                》最终的middleware实现
                    const logger = store => next => action => {
                      console.log('dispatching', action)
                      let result = next(action)
                      console.log('next state', store.getState())
                      return result
                    }

                    const crashReporter = store => next => action => {
                      try {
                        return next(action)
                      } catch (err) {
                        console.error('Caught an exception!', err)
                        Raven.captureException(err, {
                          extra: {
                            action,
                            state: store.getState()
                          }
                        })
                        throw err
                      }
                    }
                //将它们引用到Redux store中：
                import { createStore, combineReducers, applyMiddleware } from 'redux'

                let todoApp = combineReducers(reducers)
                let store = createStore(
                  todoApp,
                  // applyMiddleware() 告诉 createStore() 如何处理中间件
                  applyMiddleware(logger, crashReporter)
                )
                //现在任何被发送到store的action都会经过logger和crashReporter
                //将经过logger和crashReporter两个middleware
                store.dispatch(addTodo('Use Redux'))
            》7个示例 -- middleware
                //记录所有被发起的action以及产生的新的state
                const logger = store => next => action => {
                  console.group(action.type)
                  console.info('dispatching', action)
                  let result = next(action)
                  console.log('next state', store.getState())
                  console.groupEnd(action.type)
                  return result
                }

                //在state更新完成和listener被通知之后发送崩溃报告
                const crashReporter = store => next => action => {
                  try {
                    return next(action)
                  } catch (err) {
                    console.error('Caught an exception!', err)
                    Raven.captureException(err, {
                      extra: {
                        action,
                        state: store.getState()
                      }
                    })
                    throw err
                  }
                }

                //用{meta:{delay:N}}来让action延迟N毫秒，返回一个取消timeout的函数
                const timeoutScheduler = store => next => action => {
                  if (!action.meta || !action.meta.delay) {
                    return next(action)
                  }

                  let timeoutId = setTimeout(
                    () => next(action),
                    action.meta.delay
                  )

                  return function cancel() {
                    clearTimeout(timeoutId)
                  }
                }

                //通过{meta:{raf:true}}让action在一个rAF循环帧中被发起，然后一个从队列中移除该action的函数
                const rafScheduler = store => next => {
                  let queuedActions = []
                  let frame = null

                  function loop() {
                    frame = null
                    try {
                      if (queuedActions.length) {
                        next(queuedActions.shift())
                      }
                    } finally {
                      maybeRaf()
                    }
                  }

                  function maybeRaf() {
                    if (queuedActions.length && !frame) {
                      frame = requestAnimationFrame(loop)
                    }
                  }

                  return action => {
                    if (!action.meta || !action.meta.raf) {
                      return next(action)
                    }

                    queuedActions.push(action)
                    maybeRaf()

                    return function cancel() {
                      queuedActions = queuedActions.filter(a => a !== action)
                    }
                  }
                }

                /**
                 * 使你除了 action 之外还可以发起 promise。
                 * 如果这个 promise 被 resolved，他的结果将被作为 action 发起。
                 * 这个 promise 会被 `dispatch` 返回，因此调用者可以处理 rejection。
                 */
                const vanillaPromise = store => next => action => {
                  if (typeof action.then !== 'function') {
                    return next(action)
                  }

                  return Promise.resolve(action).then(store.dispatch)
                }

                /**
                 * 让你可以发起带有一个 { promise } 属性的特殊 action。
                 *
                 * 这个 middleware 会在开始时发起一个 action，并在这个 `promise` resolve 时发起另一个成功（或失败）的 action。
                 *
                 * 为了方便起见，`dispatch` 会返回这个 promise 让调用者可以等待。
                 */
                const readyStatePromise = store => next => action => {
                  if (!action.promise) {
                    return next(action)
                  }

                  function makeAction(ready, data) {
                    let newAction = Object.assign({}, action, { ready }, data)
                    delete newAction.promise
                    return newAction
                  }

                  next(makeAction(false))
                  return action.promise.then(
                    result => next(makeAction(true, { result })),
                    error => next(makeAction(true, { error }))
                  )
                }

                /**
                 * 让你可以发起一个函数来替代 action。
                 * 这个函数接收 `dispatch` 和 `getState` 作为参数。
                 *
                 * 对于（根据 `getState()` 的情况）提前退出，或者异步控制流（ `dispatch()` 一些其他东西）来说，这非常有用。
                 *
                 * `dispatch` 会返回被发起函数的返回值。
                 */
                const thunk = store => next => action =>
                  typeof action === 'function' ?
                    action(store.dispatch, store.getState) :
                    next(action)

                // 你可以使用以上全部的 middleware！（当然，这不意味着你必须全都使用。）
                let todoApp = combineReducers(reducers)
                let store = createStore(
                  todoApp,
                  applyMiddleware(
                    rafScheduler,
                    timeoutScheduler,
                    thunk,
                    vanillaPromise,
                    readyStatePromise,
                    logger,
                    crashReporter
                  )
                )
    》搭配React Router
        》安装React Router
            npm install --save react-router
        》配置后备URL
            在集成React Router之前，我们需要配置一下我们的开发服务器。显然我们的开发服务器无法感知配置在React Router
            中的route；如：你想访问并刷新/todos,由于是一个单页面应用，你的开发服务器需要生成并返回index.html。

            》配置Express
                如果你使用的是 Express 来返回你的 index.html 页面，可以增加以下代码到你的项目中：
                app.get('/*', (req,res) => {
                  res.sendfile(path.join(__dirname, 'index.html'))
                })
            》配置 WebpackDevServer
                如果你正在使用 WebpackDevServer 来返回你的 index.html 页面， 你可以增加如下配置到webpack.config.dev.js：
                devServer: {
                  historyApiFallback: true,
                }
        》连接React Router和Redux应用
            》首先需要从React Router中导入<Router/>和<Route/>
                import { Router, Route, browserHistory } from 'react-router';
                在React应用中，通常你会用<Router />包裹<Route/>如此当URL变化时，<Router/>将会匹配到指定的路由，然后渲染路由绑定
                的组件。<Route/>用来显示地把路由映射到应用的组件结构上，用path指定URL，用component指定路由命中URL后需要渲染的组件
                const Root = () => (
                  <Router>
                    <Route path="/" component={App} />
                  </Router>
                );
            》然后 从React Redux导入<Provider/>
                <Provider/>是React Redux提供的高阶组件，用来让你将Redux绑定到React
                import { Provider } from 'react-redux';
                用<Provider/>包裹<Router/>以便于路由处理器可以访问store
                const Root = ({ store }) => (
                  <Provider store={store}>
                    <Router>
                      <Route path="/" component={App} />
                    </Router>
                  </Provider>
                );
            》通过React Router导航
                React Router提供了<Link/>来实现导航功能
                import React from 'react';
                import { Link } from 'react-router';

                const FilterLink = ({ filter, children }) => (
                  <Link
                    to={filter === 'all' ? '' : filter}
                    activeStyle={{
                      textDecoration: 'none',
                      color: 'black'
                    }}
                  >
                    {children}
                  </Link>
                );

                export default FilterLink;
            注意：
                》Redux Router 是一个实验性质的库，它使得你的 URL 的状态和 redux store 内部状态保持一致。
                  它有和 React Router 一样的 API，但是它的社区支持比 react-router 小。
                》React Router Redux 将你的 redux 应用和 react-router 绑定在一起，并且使它们保持同步。
                  如果没有这层绑定，你将不能通过时光旅行来回放 action。除非你需要这个，不然 React-router 和 Redux 完全可以分开操作。
        》案例 Reddit
6.技巧
    》迁移到Redux
        Redux不是一个单一的框架，而是一系列的约定和一些让他们协同工作的函数。你的Redux项目的主体代码甚至不需要使用Redux的API，
        大部分时间你其实是在编写函数。
        》从Flux项目迁移
            Reducer抓住了Flux Store的本质，因此，将一个Flux项目逐步到Redux是可行的，无论你使用Flummox、Alt、transitional Flux还是
            其他Flux库。
            同样你也可以将Redux的项目通过相同的步骤迁移回上述的这些Flux框架。
            迁移步骤：
                》创建一个叫做createFluxStore(reducer)的函数，通过reducer函数适配你当前项目的Flux Store。从代码来看，这个函数很像
                  Redux中createStore的实现。它的dispatch处理器应该根据不同的action来调用不同的reducer，保存新的state并抛出更新事件。
                》通过创建createFluxStore(reducer)的方法来将每个Flux Store逐步重写为Reducer，这个过程中你的应用中其他部分代码感知不到
                  任何变化，仍可以和原来一样使用Flux Store。
                》当重写你的Store时，你会发现你应该避免一些明显违反Flux模式的使用方法，如：在Store中请求API或在Store中触发action，一旦基于
                  Reducer来构建你的Flux代码，它会变得更易于理解。
                》当你所有的Flux Store全部基于reducer来实现时，你就可以利用combineReducers(reducers)将多个reducer合并到一起，然后再应用里
                  使用这个唯一的Redux Store。
                》现在剩下的就是使用react-redux或者类似的库来处理你的UI部分
                》最后你可以使用一些Redux的特性，例如利用middleware来进一步简化异步代码
        》从Backbone项目迁移
            Backbone的Model层与Redux有着巨大的差别，因此不建议从Backbone项目迁移到Redux。
            如果可以的话最好的方法是彻底重写app的Model层。不过如果重写不可行，也可以试试使用
            backbone-redux来逐步迁移，并使用Redux的store和backbone的model层以及collection保持同步。
    》使用对象展开运算符 object spread operator
        从不直接修改state是Redux的核心理念之一，所以你会发现自己总是在使用Object.assign()创建对象拷贝，
        而拷贝中会包含新创建或更新过的属性值。
        //todoApp中Object.assign()将会返回一个新的state对象而其中的visibilityFilter属性被更新了
        function todoApp(state = initialState,action){
            switch(action.type){
                case SET_VISIBILITY_FILTER:
                    return Object.assign({},state,{
                        visibilityFilter:action.filter
                    });
                default:
                    return state;
            }
        }
        //使用对象展开运算符(将一个对象的可枚举属性拷贝到另一个对象) 来简化
        function todoApp(state = initialState,action){
            switch(action.type){
                case SET_VISIBILITY_FILTER:
                    return {...state,visibilityFilter:action.filter}
                default:
                    return state;
            }
        }
        //目前对象展开运算符提案还处于ECMAScript state3草案阶段，若你想在产品中使用它的依靠转换编译器，如
        Babel你可以使用es2015预设值，安装 babel-plugin-transform-object-rest-spread并将其单独添加到位于
        .babelrc的plugins数组中。
        {
          "presets": ["es2015"],
          "plugins": ["transform-object-rest-spread"]
        }
    》缩减样板代码
        Redux很大一部分受到Flux的启发，而最常见的关于Flux的抱怨是必须写一大推的样板代码。
        》Actions
            用来描述在app中发生了什么的普通对象，并且是描述突变数据意图的唯一途径。
            不得不dispatch的action对象并非是一个样板代码而是Redux的一个基本设计选择。
            Action:{type:"ADD_TODO",text:"Use Redux"}
            action拥有的一个不变的type是为了帮助reducer识别它们。推荐使用string而不是符号[Symbols]作为type是因为string
            是可序列化的并且使用符合会使得记录和重演变得困难。

            在Flux中传统的想法是将每个action type定义为string常量
            const ADD_TODO = 'ADD_TODO'
            //type定义常量的好处
             》帮助维护命名一致性，因为所有的 action type 汇总在同一位置。
             》有时，在开发一个新功能之前你想看到所有现存的 actions 。而你的团队里可能已经有人添加了你所需要的action，
               而你并不知道。
             》Action types 列表在 Pull Request 中能查到所有添加，删除，修改的记录。这能帮助团队中的所有人及时追踪新
               功能的范围与实现。
             》如果你在 import 一个 Action 常量的时候拼写错了，你会得到 undefined 。在 dispatch 这个 action 的时候，Redux
               会立即抛出这个错误，你也会马上发现错误。
        》Action Creators
            另一个约定俗称的做法是通过创建函数生产action对象，而不是在你的dispatch的时候内联生产它们
            如：
            //不推荐
            dispatch({
                type:"ADD_TODO",
                text:"Use Redux
            });
            //推荐
            actionCreators.js
            export function addTodo(text){
                return {
                    type:"ADD_TODO",
                    text
                }
            }
            AddTodo.js
            import {addTodo} from './actionCreators';
            dispatch(addTodo('Use Redux'));
            //Action creators总被当作样板代码，其实你并不非的把他们写出来 如果你觉得更适合你的项目你可以选用对象
            //字面量(即第一种)。然而写action creators是存在某种优势的，即可以使用redux-thunk中间件在返回函数时提前退出。
        》Action Creators生成器
            某些框架如Flummox自动从action creator函数定义生成了action type常量。这个想法是说你不需要同时定义ADD_TODO常量
            和addTodo() action creator。这样的方法在底层也生成了action type常量，但他们是隐士生成的、间接的会造成混乱，因此
            我们建议直接清晰的创建action type常量。

            写简单的action creator很容易让人厌烦，且往往最终生成多余的样板代码，你可以写一个用于生成action creator的函数：
            function makeActionCreator(type,...argNames){
                return function(...args){
                    let action = {type};
                    argNames.forEach( (arg,index) => {
                        action[argNames[index]] = args[index];
                    });
                    return action;
                }
            }

            const ADD_TODO = 'ADD_TODO'
            const EDIT_TODO = 'EDIT_TODO'
            const REMOVE_TODO = 'REMOVE_TODO'

            export const addTodo = makeActionCreator(ADD_TODO,'todo')
            export const editTodo = makeActionCreator(EDIT_TODO,'id','todo')
            export const removeTodo = makeActionCreator(REMOVE_TODO,'id');

            //一些工具库也可以帮助生成action creator 如：redux-act和redux-actions。这些库可以有效减少你的样板代码并且遵守
            //Flux Standard Action一类的标准。
        》异步Action Creators
            中间件让你在每个action对象dispatch出去之前，注入一个自定义逻辑来解释你的action对象。异步action是中间件的最常见用例。
            如果没有中间件，dispatch只能接受一个普通对象，因此我们必须在components里面进行ajax调用。
            //actionCreators.js
            export function loadPostsSuccess(userId,response){
                return {
                    type:"LOAD_POSTS_SUCCESS",
                    userId,
                    response
                }
            }

            export function loadPostFailure(userId,error){
                return {
                    type:"LOAD_POSTS",
                    userId,
                    error
                }
            }

            export function loadPostsRequest(userId){
                type:"LOAD_POSTS_REQUEST",
                userId
            }

            //UserInfo.js
            import {Component} from 'react'
            import {connect} from 'react-redux'
            import {loadPostsRequest,loadPostsSuccess,loadPostsFailure} from './actionCreators';

            class Posts extends Component{
                loadData(userId){
                    //调用React Redux connect()注入props
                    let {dispatch,posts} = this.props;

                    if(posts[userId]){
                        return;//缓存数据存在 直接返回
                    }

                    //发起请求 改变state的状态isFetching
                    dispatch(loadPostsRequest(userId));

                    //发起请求
                    fetch(`http://myapi.com/users/${userId}/posts`).then(
                        response => dispatch(loadPostsSuccess(userId, response)),
                        error => dispatch(loadPostsFailure(userId, error))
                    )
                }

                componentDidMount(){
                    this.loadData(this.props.userId);
                }

                componentWillReceiveProps(nextProps){
                    if(nextProps.userId !== this.props.userId){
                        this.loadData(nextProps.userId);
                    }
                }

                render(){
                    if(this.props.isFetching) return <p>Loading...</p>;

                    let posts = this.props.posts.map( post =>
                        <Post post={post} key = {post.id}/>
                    );
                    return <div>{posts}</div>
                }
            }

            export default connect( state => ({
                posts:state.posts
            }))(Posts);
            //然而不同的components从同样的API端点请求数据，而且我们想要在多个components中重用一些逻辑(如：当缓存数据有效的时候提前退出)，
            中间件让我们能写表达更清晰的、潜在的异步action creators。它允许我们dispatch普通对象之外的东西并解释它们的值，如：中间件能
            "捕捉"到已经dispatch的Promises并把他们变为一对请求和成功/失败的action。

            中间件最简单的例子是redux-thunk，'Thunk'中间件让你可以把action creators写成thunks，也就是返回函数的函数。这使得控制被反转了：
            你会像一个参数一样取得dispatch，所以你也能写一个多次分发的action creator。
            注意：Thunk只是一个中间件的例子，中间件不仅仅是关于"分发函数"的：而是关于你可以使用特定的中间件来分发任何该中间件可以处理的东西。
                  例子中Thunk中间件添加了一个特定的行为用来分发函数，但这实际取决于你用的中间件。
            //用redux-thunk重写上面代码
            //actionCreators.js
            export function loadPosts(userId){
                //使用thunk中间件解释
                return function(dispatch,getState){
                    let {posts} = getState();
                    if(posts[userId]){
                        return;//使用数据缓存
                    }

                    dispatch({
                        type:"LOAD_POSTS_REQUEST",
                        userId
                    });
                    fetch(`http://myapi.com/users/${userId}/posts`).then(
                          response => dispatch({
                            type: 'LOAD_POSTS_SUCCESS',
                            userId,
                            response
                          }),
                          error => dispatch({
                            type: 'LOAD_POSTS_FAILURE',
                            userId,
                            error
                          })
                        );
                }
            }
            //UserInfo.js
            import {Component} from 'react';
            import {connect} from 'react-redux';
            import {loadPosts} from 'actionCreators';
            class Posts extends Component{
                componentDidMount(){
                    this.props.dispatch(loadPosts(this.props.userId));
                }

                componentWillReceiveProps(nextProps){
                    if(nextProps.userId !== this.props.userId){
                        this.props.dispatch(loadPosts(nextProps.userId));
                    }
                }

                render(){
                    if(this.props.isLoading){
                        return <p>Loading...</p>
                    }

                    let posts = this.props.posts.map(post =>
                        <Post post={post} key={post.id}/>
                    );

                    return <div>{posts}</div>
                }
            }
            export default connect(state => ({
                posts:state.posts
            }))(Posts);

            //最后你可以编写你自己的中间件，把上面的模式泛化
            export function loadPosts(userId){
                return {
                    types:["LOAD_POSTS_REQUEST","LOAD_POSTS_SUCCESS",'LOAD_POSTS-FAILURE'],
                    //检查缓存
                    shouldCallAPI: state => !state.users[userId].
                    //获取
                    callAPI: () => fetch(`http://myapi.com/users/${userId}/posts`),
                    //在actions开始 结束注入的参数
                    payload:{userId}
                }
            }
            //解释上面这个action的中间件
            function callAPIMiddleware ({dispatch,getState}) {
                return next => action => {
                    const {
                        types,
                        callAPI,
                        shouldCallAPI = () => true,
                        payload = {}
                    } = action;

                    if(!types){
                        return next(action);//正常的action 跳过
                    }

                    if(
                        !Array.isArray(types) || types.length !== 3 ||
                        !types.every(type => typeof type === 'string')
                    ){
                        throw new Error('Expected an array of three string types.');
                    }

                    if(typeof callAPI !== 'function'){
                        throw new Error('Expected callAPI to be a function.')
                    }

                    if(!shouldCallAPI(getState())){
                        return;
                    }

                    const [requestType,successType,failureType] = types;

                    dispatch({
                        ...payload,
                        type:requestType
                    });

                    return callAPI().then(
                        response => dispatch({
                            ...payload,
                            response,
                            type:successType
                        }),
                        error => dispatch({
                            ...payload,
                            error,
                            type:failureType
                        })
                    );
                }
            }
            //在将上面的中间件传给applyMiddleware(...middlewares)一次以后，你能用相同的方式写你的API调用action creators：
            export function loadPosts(userId) {
              return {
                types: ['LOAD_POSTS_REQUEST', 'LOAD_POSTS_SUCCESS', 'LOAD_POSTS_FAILURE'],
                shouldCallAPI: (state) => !state.users[userId],
                callAPI: () => fetch(`http://myapi.com/users/${userId}/posts`),
                payload: { userId }
              };
            }

            export function loadComments(postId) {
              return {
                types: ['LOAD_COMMENTS_REQUEST', 'LOAD_COMMENTS_SUCCESS', 'LOAD_COMMENTS_FAILURE'],
                shouldCallAPI: (state) => !state.posts[postId],
                callAPI: () => fetch(`http://myapi.com/posts/${postId}/comments`),
                payload: { postId }
              };
            }

            export function addComment(postId, message) {
              return {
                types: ['ADD_COMMENT_REQUEST', 'ADD_COMMENT_SUCCESS', 'ADD_COMMENT_FAILURE'],
                callAPI: () => fetch(`http://myapi.com/posts/${postId}/comments`, {
                  method: 'post',
                  headers: {
                    'Accept': 'application/json',
                    'Content-Type': 'application/json'
                  },
                  body: JSON.stringify({ message })
                }),
                payload: { postId, message }
              };
            }
        》Reducers
            Redux reducer用函数描述逻辑更新减少了样板代码里大量的Flux stores。函数比对象简单，比类更简单得多。
            //Flux store
            let _todos = []

            const TodoStore = Object.assign({}, EventEmitter.prototype, {
              getAll() {
                return _todos
              }
            })

            AppDispatcher.register(function (action) {
              switch (action.type) {
                case ActionTypes.ADD_TODO:
                  let text = action.text.trim()
                  _todos.push(text)
                  TodoStore.emitChange()
              }
            })

            export default TodoStore

            //redux
            export function todos(state = [],action){
                switch(action.type){
                    case ActionTypes.ADD_TODO:
                        let text = action.text.trim();
                        return [...state,text];
                    default:
                        return state;
                }
            }

            》Reducers生成器
                写一个函数将reducers表达为action types到handles的映射对象
                //todos reducers
                export const todos = createReducer([],{
                    [ActionTypes.ADD_TODO](state,action){
                        let text = action.text.trim();
                        return [...state,text]
                    }
                })
                //reducers 生成器
                function createReducer(initialState,handlers){
                    return function reducer(state = initialState,action){
                        if (handlers.hasOwnProperty(action.type)) {
                          return handlers[action.type](state, action);
                        } else {
                          return state;
                        }
                    }
                }
    》服务端渲染
        服务端渲染一个很常见的场景是当用户(或搜索引擎爬虫)第一次请求页面时，用它来做初始渲染。当服务器接收到请求后，
        它把需要的组件渲染成HTML字符串，然后把它返回给客户端(浏览器)，之后客户端会接手渲染控制全。

        》服务端使用Redux
            当在服务器使用Redux渲染时，一定要在响应中包含应用的state，这样客户端就可以把它作为初始state。这点至关重要。
            因为如果在生成HTML前预加载了数据，希望客户端也能访问这些数据。否则客户端生成的HTML与服务器端返回的HTML就不会
            匹配，客户端还需要重新加载数据。

            把数据发送到客户端的步骤：
                》为每次请求创建全新的Redux store实例
                》按需dispatch一些action
                》从store中取出state
                》把state一同返回给客户端
            在客户端使用服务器返回的state创建并初始化一个全新的Redux store，Redux在服务端唯一要做的事情：提供应用所需的初始state

        》安装
            Counter计数器案例
            》安装依赖库
                使用Express做web服务器
                npm install --save express react-redux
            》服务端开发
                使用app.use挂载 Express middleware处理所有请求，每次服务器收到请求时都会调用handleRender函数。
                另外如果使用ES6和jsx语法，需要使用Babel和React preset。
                //server.js

                》处理请求
                    对每个请求创建一个新的Redux store实例。这个store唯一的作用是提供应用的初始的state

                    渲染时使用<Provider>来包住根组件<App/>以此来让组件树中所有组件都能访问store。

                    服务端渲染最关键的一步是：发送响应前渲染初始的HTML，需要React.renderToString()。
                    然后使用store.getState()从store得到初始state。
                    //handleRender.js
                》注入初始组件的HTML和state
                    服务端最后一步就是把初始组件的HTML和初始state注入到客户端能够渲染的模板中。如何传递state呢
                    我们添加一个<script>标签来把preloadedState赋给window.__INITIAL_STATE__。
                    客户端可以通过 window.__INITIAL_STATE__ 获取 preloadedState。

                    同时使用script标签来引入打包后的js bundle文件。这是打包工具输出的客户端入口文件，以静态文件或URL的方式
                    实现服务端开发中的热加载。
                    //renderFullPage.js
            》客户端开发
                只需要从window.__INITIAL_STATE__得到初始state，并传给createStore()函数即可
                //index.js
                使用打包工具编译并打包文件到dist/bundle.js
                当页面加载时，打包后的js会启动，并调用React.render()，然后与服务端渲染的HTML的data-react-id属性
                做关联。
                这会把新生成的 React 实例与服务端的虚拟 DOM 连接起来。因为同样使用了来自 Redux store 的初始 state，
                并且 view 组件代码是一样的，结果就是我们得到了相同的 DOM。
            》准备初始state
                因为客户端只是执行收到的代码，刚开始的初始state可能是空的，然后根据需要获取state。在服务端渲染时同步执行的而且我们
                只有一次渲染view的机会。在收到请求时，可能需要根据请求参数或外部state(访问API或数据库)计算后得到初始state。

                》处理request参数
                    服务端收到的唯一输入是来自浏览器的请求，在服务器启动时可能需要做一些配置(如：运行在开发环境还是生产环境)
                    但这些配置是静态的。

                    请求会包含在URL请求相关信息，包括请求参数，他们对于做React Router路由时可能会有用。也可能在请求头里面包含cookies
                    ，鉴权信息或者 POST 内容数据。

                    //基于请求参数得到初始state handleRender.js

                》获取异步state
                    服务端渲染常用的场景是处理异步state，因为服务端渲染天生是同步的，因此异步的数据获取操作对应到同步操作非常重要。

                    //api请求代码 counter.js
                》安全注意事项
                    任何应用都应该对用户输入做安全处理以避免跨站脚本攻击(XSS)或代码注入
                    可以考虑使用安全函数处理输入如Lvalidator.js
    》编写测试
        因为大部分的Redux代码都是函数，而大部分是纯函数，所以很好测试，不需要模拟。
        》设置
            建议使用Jest作为测试引擎。注意因为是在node环境下运行，所以你不能访问DOM。
            npm install --save-dev jest

            //若想结合Babel使用，你需要安装babel-jest:
            npm install --save-dev babel-jest
            //并且在.babelrc中启用ES2015的功能
            {
              "presets": ["es2015"]
            }

            //在package.json的scripts里加入
            {
              ...
              "scripts": {
                ...
                "test": "jest",//单次运行
                "test:watch": "npm test -- --watch"//每次文件改变时自动执行测试
              },
              ...
            }
        》Action创建函数 Action Creators
            Redux里的action创建函数是会返回普通对象的函数。在测试action创建函数的时候我们想要测试是否调用了正确的action创建函数，
            还有是否返回了正确的action。
            案例：
                export function addTodo(text) {
                  return {
                    type: 'ADD_TODO',
                    text
                  }
                }
                //测试
                import * as actions from '../../actions/TodoActions'
                import * as types from '../../constants/ActionTypes'

                describe('actions', () => {
                  it('should create an action to add a todo', () => {
                    const text = 'Finish docs'
                    const expectedAction = {
                      type: types.ADD_TODO,
                      text
                    }
                    expect(actions.addTodo(text)).toEqual(expectedAction)
                  })
                })
        》异步Action创建函数
            对于使用Redux Thunk或其他中间件的异步action创建函数，最好完全模拟Redux store来测试。你可以使用redux-mock-store把middleware
            应用到模拟的store。也可以使用nock来模拟HTTP请求。
            案例：
            import fetch from 'isomorphic-fetch'
            function fetchTodosRequest(){
                return {
                    type:FETCH_TODOS_REQUEST
                }
            }

            function fetchTodosSuccess(body){
                return {
                    type:FETCH_TODOS_SUCCESS,
                    body
                }
            }

            function fetchTodosFailure(ex){
                return {
                    type:FETCH_TODOS_FAILURE,
                    ex
                }
            }

            export function fetchTodos(){
                return dispatch => {
                    dispatch(fetchTodosRequest());
                    return fetch('http://example.com/todos')
                    .then(res => res.json())
                    .then(json => dispatch(fetchTodosSuccess(json.body)))
                    .catch(ex => dispatch(fetchTodosFailure(ex)))
                }
            }
            //测试
            import configureMockStore from 'redux-mock-store'
            import thunk from 'redux-thunk'
            import * as actions from '../../actions/TodoActions'
            import * as types from '../../constants/ActionTypes'
            import nock from 'nock'
            import expect from 'expect' // 你可以使用任何测试库

            const middlewares = [ thunk ]
            const mockStore = configureMockStore(middlewares)

            describe('async actions', () => {
              afterEach(() => {
                nock.cleanAll()
              })

              it('creates FETCH_TODOS_SUCCESS when fetching todos has been done', () => {
                nock('http://example.com/')
                  .get('/todos')
                  .reply(200, { body: { todos: ['do something'] }})

                const expectedActions = [
                  { type: types.FETCH_TODOS_REQUEST },
                  { type: types.FETCH_TODOS_SUCCESS, body: { todos: ['do something']  } }
                ]
                const store = mockStore({ todos: [] })

                return store.dispatch(actions.fetchTodos())
                  .then(() => { // 异步 actions 的返回
                    expect(store.getActions()).toEqual(expectedActions)
                  })
              })
            })
        》Reducers
            Reducer把action应用到之前的state，并返回新的state。
            案例：
            import {ADD_TODO} from '../constants/ActionTypes'
            const initialState = [
                {
                    text:"Use Redux",
                    completed:false,
                    id:0
                }
            ]

            export default function todos(state = initialState,action){
                switch(action.type){
                    case ADD_TODO:
                        return [
                            {
                                id:state.reduce( (maxId,todo) => Math.max(todo.id,maxId),-1) +1,
                                completed:false,
                                text:action.text
                            },
                            ...state
                        ]
                    default:
                        return state;
                }
            }
            //测试
            import reducer from '../../reducers/todos'
            import * as types from '../../constants/ActionTypes'

            describe('todos reducer', () => {
              it('should return the initial state', () => {
                expect(
                  reducer(undefined, {})
                ).toEqual([
                  {
                    text: 'Use Redux',
                    completed: false,
                    id: 0
                  }
                ])
              })

              it('should handle ADD_TODO', () => {
                expect(
                  reducer([], {
                    type: types.ADD_TODO,
                    text: 'Run the tests'
                  })
                ).toEqual(
                  [
                    {
                      text: 'Run the tests',
                      completed: false,
                      id: 0
                    }
                  ]
                )

                expect(
                  reducer(
                    [
                      {
                        text: 'Use Redux',
                        completed: false,
                        id: 0
                      }
                    ],
                    {
                      type: types.ADD_TODO,
                      text: 'Run the tests'
                    }
                  )
                ).toEqual(
                  [
                    {
                      text: 'Run the tests',
                      completed: false,
                      id: 1
                    },
                    {
                      text: 'Use Redux',
                      completed: false,
                      id: 0
                    }
                  ]
                )
              })
            })
        》Components
            React components的优点是，一般都很小且依赖于props。因此测试起来很简便。
            首先安装Enzyme，Enzyme底层使用了React Test Utilities，但是更方便，更易读，而且更强大。
            npm install --save-dev enzyme
            测试components要创建一个叫setup()的辅助方法，用来把模拟过的stubbed回调函数当作props传入。
            然后使用React浅渲染组件。这样就可以依据是否调用了回调函数的断言来写独立的测试。
            import React,{Component} from 'react'
            import TodoTextInput from './TodoTextInput'

            export default class Header extends Component{
                handleSave(text){
                    if(text.length !== 0){
                        this.props.addTodo(text);
                    }
                }

                render(){
                    return (
                        <header className='header'>
                            <h1>todos</h1>
                            <TodoTextInput newTodo={true}
                                onSave = {this.handleSave.bind(this)}
                                placeholder='What needs to be done?'
                            />
                        </header>
                    )
                }
            }
            //测试
            import React from 'react'
            import {shallow} from 'enzyme'
            import Header from '../../components/Header'

            function setup(){
                const props = {
                    addTodo:jest.fn()
                }

                const enzymeWrapper = shallow(<Header {...props} />);

                return {
                    props,
                    enzymeWrapper
                }
            }
            describe('components', () => {
              describe('Header', () => {
                it('should render self and subcomponents', () => {
                  const { enzymeWrapper } = setup()

                  expect(enzymeWrapper.find('header').hasClass('header')).toBe(true)

                  expect(enzymeWrapper.find('h1').text()).toBe('todos')

                  const todoInputProps = enzymeWrapper.find('TodoTextInput').props()
                  expect(todoInputProps.newTodo).toBe(true)
                  expect(todoInputProps.placeholder).toEqual('What needs to be done?')
                })

                it('should call addTodo if length of text is greater than 0', () => {
                  const { enzymeWrapper, props } = setup()
                  const input = enzymeWrapper.find('TodoTextInput')
                  input.props().onSave('')
                  expect(props.addTodo.mock.calls.length).toBe(0)
                  input.props().onSave('Use Redux')
                  expect(props.addTodo.mock.calls.length).toBe(1)
                })
              })
            })
        》连接组件
            如果你使用了React Redux，可能你也同时再使用类似的connect()的higher-order components,将Redux state注入到常见的React组件中。
            案例：
            import {connect} from 'react-redux'
            class App extends Component{}

            export default connect(mapStateToProps)(App);

            在单元测试中，一般会导入App组件
            import App from './App'
            但是，当这样导入时，实际上持有的是connect()返回的包装过的组件，而不是App组件本身。如果想测试它和Redux间的互动。
            可以使用一个专为单元测试创建的store，将它包装在<Provider>中。但有时我们仅仅是想测试组件的渲染，并不想要这么
            一个 Redux store。
            import {connect} from 'react-redux'
            //测试用的
            export class App extends Component{...}
            //app用
            export default connect(mapDispatchToProps)(App);

            //测试导入
            import {App} from './App'
        》中间件
            中间件函数会对Redux中的dispatch的调用行为进行封装。因此需要通过模拟dispatch的调用行为来测试。
            import * as types from '../../constants/ActionTypes'
            import singleDispatch from '../../middleware/singleDispatch'

            const createFakeStore = fakeData => ({
              getState() {
                return fakeData
              }
            })

            const dispatchWithStoreOf = (storeData, action) => {
              let dispatched = null
              const dispatch = singleDispatch(createFakeStore(storeData))(actionAttempt => dispatched = actionAttempt)
              dispatch(action)
              return dispatched
            }

            describe('middleware', () => {
              it('should dispatch if store is empty', () => {
                const action = {
                  type: types.ADD_TODO
                }

                expect(
                  dispatchWithStoreOf({}, action)
                ).toEqual(action)
              })

              it('should not dispatch if store already has type', () => {
                const action = {
                  type: types.ADD_TODO
                }

                expect(
                  dispatchWithStoreOf({
                    [types.ADD_TODO]: 'dispatched'
                  }, action)
                ).toNotExist()
              })
            })
    》计算衍生数据
        Reselect库可以创建可记忆的、可组合的selector函数。Reselect selectors可以用来高效地计算Redux store里面的衍生数据。
        》可记忆的Selectors初衷
            //containers/VisibleTodoList.js
            import {connect} from 'react-redux'
            import {toggleTodo} from '../actions'
            import TodoList from '../components/TodoList'

            const getVisibleTodos = (todos,filter) => {
                switch(filter){
                    case "SHOW_ALL":
                        return todos;
                    case 'SHOW_COMPLETED':
                        return todos.filter ( t=> t.completed)
                    case 'SHOW_ACTIVE':
                        return todos.filter( t=> !t.completed)
                }
            }

            const mapStateToProps = state => {
                return {
                    todos:getVisibleTodos(state.todos,state.visibilityFilter)
                }
            }

            const mapDispatchToProps = dispatch => {
                return {
                    onTodoClick: id => {
                        dispatch(toggleTodo(id))
                    }
                }
            }

            export default connect(mapStateToProps,mapDispatchToProps)(TodoList);
            //mapStateToProps调用了getVisibleTodos来计算todos。运行没有问题，但是有一个缺点：每次当组件更新时都会重新计算todos。
            如果state tree非常大或者计算量非常大，每次更新都重新计算可能会带来性能问题。Reselect能帮你省去这些没有必要的重新计算。

        》创建可记忆的Selector
            我们需要一个可记忆的selector来替代这个getVisibleTodos只有在state.todos或state.visibilityFilter变化时重新计算todos。
            而其他部分变化时不做计算。

            Reselect提供createSelector函数创建可记忆的selector。createSelector接收一个input-selectors数组和一个转换函数作为参数。
            如果state tree的改变会引起input-selector值变化，那么selector会调用转换函数，传入input-selectors作为参数，并返回结果。
            如果input-selectors的值和前一次的一样，它将会直接返回前一次的计算的数据，而不会在调用一次转换函数。

            //定义一个可记忆的selector getVisibleTodos来替代上面的无记忆版本
            selectors/index.js
            import {createSelector} from 'reselect'

            const getVisibilityFilter = state => state.visibilityFilter;
            const getTodos = state => state.todos;

            export const getVisibleTodos = createSelector(
                [getVisibilityFilter,getTodos],
                (visibilityFilter,todos) => {
                    switch (visibilityFilter) {
                      case 'SHOW_ALL':
                        return todos
                      case 'SHOW_COMPLETED':
                        return todos.filter(t => t.completed)
                      case 'SHOW_ACTIVE':
                        return todos.filter(t => !t.completed)
                    }
                }
            );
        》组合Selector
            可记忆的selector自身可以作为其它可记忆的selector的input-selector。
            //如将getVisibleTodos作为另一个selector的input-selector
            const getKeyword = state => state.keyword
            const getVisibleTodosFilteredByKeyword = createSelector(
                [getVisibleTodos,getKeyword],
                (visibleTodos,keyword) => visibleTodos.filter(
                    todo => todo.text.indexOf(keyword) > -1;
                )
            );
        》连接Selector和Redux Store
            如果你在使用React Redux，可以在mapStateToProps()中当正常函数来调用selectors
            //containers/VisibleTodoList.js
            import {connect} from 'react-redux'
            import {toggleTodo} from '../actions'
            import TodoList from '../components/TodoList'
            import {getVisibleTodos} from '../selectors'

            const mapStateToProps = state => {
                return {
                    todos:getVisibleTodos(state)
                }
            }

            const mapDispatchToProps = dispatch => {
                return {
                    onTodoClick: id => {
                        dispatch(toggleTodo(id))
                    }
                }
            }

            export default connect(mapStateToProps,mapDispatchToProps)(TodoList);
        》在selectors中访问React Props
            selector接收Redux store state以及props作为参数
            //components/App.js
            import React from 'react'
            import Footer from './Footer'
            import AddTodo from '../containers/AddTodo'
            import VisibleTodoList from '../containers/VisibleTodoList'

            const App = () => (
              <div>
                <VisibleTodoList listId="1" />
                <VisibleTodoList listId="2" />
                <VisibleTodoList listId="3" />
              </div>
            )
            //selectors/todoSelectors.js
            import {createSelector} from 'reselect'
            const getVisibilityFilter = (state,props) => state.todoLists[props.listId].visibilityFilter;

            const getTodos = (state,props) => state.todoLists[props.listId].todos;

            const getVisibleTodos = createSelector(
              [ getVisibilityFilter, getTodos ],
              (visibilityFilter, todos) => {
                switch (visibilityFilter) {
                  case 'SHOW_COMPLETED':
                    return todos.filter(todo => todo.completed)
                  case 'SHOW_ACTIVE':
                    return todos.filter(todo => !todo.completed)
                  default:
                    return todos
                }
              }
            )
            export default getVisibleTodos
            //props可以通过mapStateToProps传递给getVisibleTodos:
            const mapStateToProps = (state, props) => {
              return {
                todos: getVisibleTodos(state, props)
              }
            }

            //使用带有多个visibleTodoList容器实例的getVisibleTodos selector不能使用函数记忆功能
            containers/VisibleTodoList.js
            import { connect } from 'react-redux'
            import { toggleTodo } from '../actions'
            import TodoList from '../components/TodoList'
            import { getVisibleTodos } from '../selectors'

            const mapStateToProps = (state, props) => {
              return {
                // 警告：下面的 selector 不会正确记忆
                todos: getVisibleTodos(state, props)
              }
            }

            const mapDispatchToProps = (dispatch) => {
              return {
                onTodoClick: (id) => {
                  dispatch(toggleTodo(id))
                }
              }
            }

            const VisibleTodoList = connect(
              mapStateToProps,
              mapDispatchToProps
            )(TodoList)

            export default VisibleTodoList
            注意：用createSelector创建的selector只有在参数集与之前的参数集相同时才会返回缓存值，如果我们交替的
            渲染<VisibleTodoList listId='1'/>和<VisibleTodoList listId='2'/>，共享的selector将交替的接收listId:1与2
            .这会导致每次调用时传入的参数不同。因此selector将始终重新计算而不是返回缓存的值。
        》跨多组件的共享Selector
            需要React Redux v4.3.0以上版本
            为了跨越多个VisibleTodoList共享selector，并且正确的记忆。每个组件的实例需要有拷贝selector的私有版本。
            //创建一个makeGetVisibleTodos的函数，在每次调用的时候返回一个getVisibleTodos selector的新拷贝
            selectors/todoSelectors.js
            import {createSelector} from 'reselect'
            const getVisibilityFilter = (state, props) =>
              state.todoLists[props.listId].visibilityFilter

            const getTodos = (state, props) =>
              state.todoLists[props.listId].todos

            const makeGetVisibleTodos = () => {
              return createSelector(
                [ getVisibilityFilter, getTodos ],
                (visibilityFilter, todos) => {
                  switch (visibilityFilter) {
                    case 'SHOW_COMPLETED':
                      return todos.filter(todo => todo.completed)
                    case 'SHOW_ACTIVE':
                      return todos.filter(todo => !todo.completed)
                    default:
                      return todos
                  }
                }
              )
            }
            //我们还需要一种每个容器方法自己私有的selector的方式。connect的mapStateToProps函数可以帮助我们
            如果connect的mapStateToProps返回的不是一个对象而是一个函数，他将被用作为每个容器的实例创建一个单独
            的mapStateToProps函数。
                const makeMapStateToProps = () => {
                    const getVisibleTodos = makeGetVisibleTodos()
                    const mapStateToProps = (state, props) => {
                        return {
                          todos: getVisibleTodos(state, props)
                        }
                      }
                      return mapStateToProps
                }
                //现在记忆功能就能够正常使用了
                container/VisibleTodosList.js
                import { connect } from 'react-redux'
                import { toggleTodo } from '../actions'
                import TodoList from '../components/TodoList'
                import { makeGetVisibleTodos } from '../selectors'

                const makeMapStateToProps = () => {
                  const getVisibleTodos = makeGetVisibleTodos()
                  const mapStateToProps = (state, props) => {
                    return {
                      todos: getVisibleTodos(state, props)
                    }
                  }
                  return mapStateToProps
                }

                const mapDispatchToProps = (dispatch) => {
                  return {
                    onTodoClick: (id) => {
                      dispatch(toggleTodo(id))
                    }
                  }
                }

                const VisibleTodoList = connect(
                  makeMapStateToProps,
                  mapDispatchToProps
                )(TodoList)

                export default VisibleTodoList
    》实现撤销历史
        》设计状态结构
            撤销历史也是应用state的一部分，我们没有必要以不同的方式实现它。当你实现撤销和重做这个功能时，无论state如何随着时间
            不断变化，你都需要追踪state在不同时刻的历史记录。

            如：一个计数器应用的state结构
            {
                counter:10
            }
            //如果我们希望在这样一个应用中实现撤销和重做的话，我们必须保存更多的state以解决下面几个问题：
            》撤销或重做留下了那些信息
            》当前的状态是什么？
            》撤销堆栈中过去(和未来)的状态是什么？
            //为此我们对state结构做了以下修改
            {
                counter:{
                    past: [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ],
                    present: 10,
                    future: []
                }
            }
            //现在 按下撤销 恢复到过去的状态
            {
              counter: {
                past: [ 0, 1, 2, 3, 4, 5, 6, 7, 8 ],
                present: 9,
                future: [ 10 ]
              }
            }
            //再次撤销
            {
              counter: {
                past: [ 0, 1, 2, 3, 4, 5, 6, 7 ],
                present: 8,
                future: [ 9, 10 ]
              }
            }
            //当按下重做 往未来的状态移动一步
            {
              counter: {
                past: [ 0, 1, 2, 3, 4, 5, 6, 7, 8 ],
                present: 9,
                future: [ 10 ]
              }
            }
            //最终，当处于撤销堆栈中时，用户发起了一个操作(如：减少计数)，那么我们将会丢弃所有未来的信息
            {
              counter: {
                past: [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ],
                present: 8,
                future: []
              }
            }
            //在撤销堆栈中保存的数字 字符串 数组或是对象都不重要，因为整个结构始终保持一致

            //它看起来通常都是这样
            {
                past:Array<T>,
                present:T,
                future:Array<T>
            }
        》设计算法
            无论何种特定的数据类型，重做历史记录的state结构始终一致
            {
                past:Array<T>,
                present:T,
                future:Array<T>
            }
            //可以定义两个action来操作该state:UNDO和REDO。在reducer处理这两个action
            》处理Undo
                移除past中的**最后一个**元素
                将上一步移除的元素赋予present
                将原来的present插入到future的**最前面**
            》处理Redo
                移除future的*第一个*元素
                将上一步移除的元素赋予present
                将原来的present追加到past的*最后面*
            》处理其他Action
                将当前的present追加到past的最后面
                将处理完的action所产生的新的state赋予present
                清空future
            //编写Reducers
            const initialState = {
                past:[],
                present:null,//考虑如何初始化state
                future:[]
            }
            function undoable(state = initialState,action){
                const {past,present,future} = state;
                switch(action.type){
                    case "UNDO":
                        const previous = past[past.length -1];
                        const newPast = past.slice(0,past.length -1);
                        return {
                            past:newPast,
                            present:previous,
                            future:[present,...future]
                        }
                    case 'REDO':
                        const next = future[0];
                        const newFuture = future.slice(1);
                        return {
                            past:[...past,present],
                            present:next,
                            future:newFuture
                        }
                    default:
                        //如何处理其他action
                        return state;
                }
            }
            //上面的代码无法实现其功能的
        》初识Reducer Enhancers
            reducer enhancer(higher order reducer)作为一个函数，接收reducer作为参数并返回一个新的reducer，这个新的reducer可以
            处理新的action或维护更多的state亦或者将它无法处理的action委托给原始的reducer处理。combineReducers()也是reducer enhancer
            因为它同样接收多个reducer并返回一个新的reducer。

            //重写上面代码
            function undoable(reducer){

                //以一个空的action调用reducer来产生初始的state
                const initialState = {
                    past:[],
                    present:reducer(undefined,{}),
                    future:[]
                }

                //返回一个可以执行撤销和重做的新的reducer
                return function (state = initialState,action){
                    const {past,present,future} = state;

                    switch(action.type){
                        case 'UNDO':
                            const previous = past[past.length -1];
                            const newPast = past.slice(0,past.length -1);
                            return {
                                past:newPast,
                                present:previous,
                                future:[present,...future]
                            }
                        case 'REDO':
                            const next = future[0]
                            const newFuture =future.slice(1)
                            return {
                                past:[...past,present],
                                present:next,
                                future:newFuture
                            }
                        default:
                            //将其他action委托给原始的reducer处理
                            const newPresent = reducer(present,action);
                            if(present === newPresent){
                                return state;
                            }

                            return {
                                past:[...past,present],
                                present:newPresent,
                                future:[]
                            }
                    }
                }
            }
            //现在可以将任意的reducer封装到 可撤销的reducer enhancer，从而处理UNDO和REDO这两个action
            //reducers
            function todos(state = {},action){

            }

            //处理
            const undoableTodos = undoable(todos);
            import {createStore} from 'redux'
            const store = createStore(undoableTodos);
            store.dispatch({
              type: 'ADD_TODO',
              text: 'Use Redux'
            })

            store.dispatch({
              type: 'ADD_TODO',
              text: 'Implement Undo'
            })

            store.dispatch({
              type: 'UNDO'
            })
            注意：当恢复一个state时，必须把present追加到当前state上。同时还需要检测past.length和future.length确定撤销和重做按钮是否可用。
        》使用Redux Undo
             该库可以为你的Redux状态树种的任何部分提供撤销和重做功能
             》安装
                npm install --save redux-undo
             》封装Reducer
                你需要通过undoable函数来强化你的reducer。如果之前导出的是todos reducer，那么现在你需要把这个reducer传给undoable()
                然后把计算结果导出：
                //reducers/todos.js
                import undoable,{distinctState} from 'redux-undo'

                const todos = (state = [],action) => {...}

                export default const undoableTodos = undoable(todos,{
                    filter:distinctState()//过滤器会忽略那些没有引起state变化的actions，可撤销的reducer还可以通过其他选项进行配置
                    //如action type https://github.com/omnidan/redux-undo#configuration
                })


                //reducers/index.js
                import { combineReducers } from 'redux'
                import todos from './todos'
                import visibilityFilter from './visibilityFilter'

                const todoApp = combineReducers({
                  todos,
                  visibilityFilter
                })

                export default todoApp
             //containers/VisibleTodoList.js
             const mapStateToProps = (state) => {
               return {
                 todos: getVisibleTodos(state.todos.present, state.visibilityFilter)
               }
             }
             //添加按钮
             containers/UndoRedo.js
             import React from 'react'
             import { ActionCreators as UndoActionCreators } from 'redux-undo'
             let UndoRedo = ({canUndo,canRedo,onUndo,onRedo}) => (
                 <p>
                    <button onClick={onUndo} disabled={!canUndo}>
                      Undo
                    </button>
                    <button onClick={onRedo} disabled={!canRedo}>
                      Redo
                    </button>
                  </p>
             );
             const mapStateToProps = (state) => {
               return {
                 canUndo: state.todos.past.length > 0,
                 canRedo: state.todos.future.length > 0
               }
             }

             const mapDispatchToProps = (dispatch) => {
               return {
                 onUndo: () => dispatch(UndoActionCreators.undo()),
                 onRedo: () => dispatch(UndoActionCreators.redo())
               }
             }

             UndoRedo = connect(
               mapStateToProps,
               mapDispatchToProps
             )(UndoRedo)

             export default UndoRedo
             //你需要使用React Redux的connect函数生成容器组件，然后检测state.todos.past.length和state.todos.future.length来判断是否
             启用撤销和重做按钮你不再需要给撤销和重做编写 action creators 了，因为 Redux Undo 已经提供了这些 action creators：

             //现在把UndoRedo组件添加到App组件：
             components/App.js
             import React from 'react'
             import Footer from './Footer'
             import AddTodo from '../containers/AddTodo'
             import VisibleTodoList from '../containers/VisibleTodoList'
             import UndoRedo from '../containers/UndoRedo'

             const App = () => (
               <div>
                 <AddTodo />
                 <VisibleTodoList />
                 <Footer />
                 <UndoRedo />
               </div>
             )

             export default App
    》子应用隔离
        考虑一下这样的场景：有一个大应用(对应于<BigApp>组件)包含了很多小的子应用(subApp组件)
        import React ,{Component} from 'react'
        import SubApp from './subApp'
        class BigApp extends Component{
            render(){
                return (
                    <div>
                        <SubApp/>
                        <SubApp/>
                        <SubApp/>
                    </div>
                )
            }
        }
        //这些<SubApp>是完全独立的，它们并不会共享数据或action，也互不可见且不需要通信。
        这时最好的做法是不要把它混入到标准 Redux 的 reducer 组件中。 对于一般型的应用，
        是建议使用 reducer 组件。但对于 “应用集合”，“仪表板”，或者企业级软件这些把
        多个本来独立的工具凑到一起打包的场景，可以试下子应用的方案。

        子应用的方案还适用于有多个产品或垂直业务的大团队。小团队可以独立发布子应用或相互独立于自己的应用壳中。

        //下面是connect过的子应用的根组件。像其他组件一样，它还可以渲染更多子组件，connect或没有connect的都可以
        通常只要把它使用<Provider>渲染就够了
        class App extends Component { ... }
        export default connect(mapStateToProps)(App)
        //但是如果不想让外部知道子应用的组件是Redux应用的话，可以不调用ReactDOM.render(<Provider><App/></Provider>)

        //或可以在大应用中同时运行它的多个实例呢，还能保证每个在黑盒子里运行，外界对Redux无感知。
        //为了使用React API来隐藏Redux的痕迹，在组件的构造方法里初始化store并把它包到一个特殊的组件中
        import React ,{Component} from 'react'
        import {Provider} from 'react-redux'
        import reducer from './reducers'
        import App from './App'
        class SubApp extends Component{
            constructor(props){
                super(props);
                this.store = createStore(reducer);
            }

            render(){
                <Provider store={this.store}>
                    <App/>
                </Provider>
            }
        }
        //这样每个实例都是独立的
        //如果应用间需要共享数据，不推荐使用这个模式。但是如果大应用完全不需要访问子应用内部数据的话，
        这是非常有用的，同时我们还想把Redux作为一种内部细节实现方式对外部隐藏。每个组件实例都有它自己
        的store，所以它们彼此是不可见的。
    》组织Reducer
        Redux真的是一种十分简单的设计模式：所有你写的逻辑都集中在一个单独的函数中，并且执行这些逻辑的唯一
        方式就是传给Redux一个能够描述当时情景的普通对象。Redux store调用这些逻辑函数，并传入当前的state tree
        以及这些描述对象，返回新的state tree，接着Redux store便开始通知subscriber state tree已经改变了。

        Redux设置了一些基本的限制来保证这些逻辑函数的正常工作，就像Reducers里面描述的一样，它必须有类似
        (previousState,action) => newState这样的结构，它们通常被称为reducer函数并且必须是纯函数和可预测的。

        》Reducer基础概念
               一个Redux reducer函数需要具备：
                    》应该有类似 (previousState,action) => newState特征的函数，函数的类型与Array.prototype.reduce(reducer,?initialValue)
                      这个函数很相似。
                    》应该是纯函数，纯函数意味着不能突变它的参数。这意味着state的更新应该在不可变得理念下完成，这就是说总是去返回一个新的更新后
                      的对象而不是直接去修改原始的state tree。

               》突变的弊端
                    对于调试过程, Redux DevTools 期望重放 action 记录时能够输出 state 值，
                    而不会改变任何其他的状态。突变或者异步行为会产生一些副作用，可能使调试过程中的行为被替换，导致破坏了应用。

                    对于 React Redux connect 来说，为了确定一个组件（component）是否需要更新，它会检查从 mapStateToProps 中返回的
                    值是否发生改变。为了提升性能，connect 使用了一些依赖于不可变 state 的方法。并且使用浅引用（shallow reference）
                    来检测状态的改变。这意味着直接修改对象或者数组是不会被检测到的并且组件不会被重新渲染。
        》Reducer和state的基本结构
               》Reducer的基本结构
                    首先必须明确的是：整个应用只有一个单一的reducer函数：这个函数是传给createStore的第一个参数。一个单一的reducer
                    最终需要做以下几件事：
                    》reducer第一次被调用的时候，state的值是undefined。reducer需要在action传入之前提供一个默认的state来处理这种情况
                    》reducer需要先前的state和dispatch的action来决定需要做什么事。
                    》若需要更改数据，应该用更新后的数据创建新的对象或数组并返回它们
                    》如果没有什么更改，应该返回当前存在的state本身。
                        function counter(state = 0, action) {
                          switch (action.type) {
                            case 'INCREMENT':
                              return state + 1;
                            case 'DECREMENT':
                              return state - 1;
                            default:
                              return state;
                          }
                        }
               》State的基本结构
                    Redux鼓励你根据要管理的数据来思考你的应用程序。数据就是你应用的state，state的结构和组织方式通常会称为"shape"。
                    在你组织reducer的逻辑时，state的shape通常扮演一个重要的角色。

                    大多数应用会处理多种数据类型，通常可以分为三类：
                    》域数据Domain data:应用需要展示 使用或修改的数据 如从服务器检索到的数据
                    》应用状态 App State 特定于应用某个行为的数据
                    》UI状态 UI State 控制UI如何展示的数据
                    {
                        domainData1 : {},
                        domainData2 : {},
                        appState1 : {},
                        appState2 : {},
                        ui : {
                            uiState1 : {},
                            uiState2 : {},
                        }
                    }
        》拆分Reducer逻辑
               拆分的函数分为三类：
               》一些小的工具函数，包含一些可重用的逻辑片段
               》用于处理特定情况下的数据更新的函数，参数处理(state,action)之外，通常还包括其他参数
               》处理给定state切片的所有更新的函数，参数格式通常为(state,action)

               reducer:任何符合(state,action) => newState格式的函数
               root reducer:通常作为createStore第一个参数的函数，它是唯一的一个在所有reducer函数中必须符合(state,action) => newState格式的函数
               slice reducer:一个负责处理状态树种一块切片数据的函数，通常会作为combineReducers函数的参数
               case function:一个负责处理特殊action的更新逻辑的函数。可能是一个reducer函数，也可能需要其他参数才能正常工作。
               higher-order reducer:一个以reducer函数作为参数，且或返回一个新的reducer函数的函数 如：combineReducers redux-undo。
        》Reducer重构
               使用函数分解Functional Decomposition 和 Reducer组合 Reducer Composition 重构Reducer
               const initialState = {
                   visibilityFilter : 'SHOW_ALL',
                   todos : []
               };


               function appReducer(state = initialState, action) {
                   switch(action.type) {
                       case 'SET_VISIBILITY_FILTER' : {
                           return Object.assign({}, state, {
                               visibilityFilter : action.filter
                           });
                       }
                       case 'ADD_TODO' : {
                           return Object.assign({}, state, {
                               todos : state.todos.concat({
                                   id: action.id,
                                   text: action.text,
                                   completed: false
                               })
                           });
                       }
                       case 'TOGGLE_TODO' : {
                           return Object.assign({}, state, {
                               todos : state.todos.map(todo => {
                                   if (todo.id !== action.id) {
                                     return todo;
                                   }

                                   return Object.assign({}, todo, {
                                       completed : !todo.completed
                                   })
                                 })
                           });
                       }
                       case 'EDIT_TODO' : {
                           return Object.assign({}, state, {
                               todos : state.todos.map(todo => {
                                   if (todo.id !== action.id) {
                                     return todo;
                                   }

                                   return Object.assign({}, todo, {
                                       text : action.text
                                   })
                                 })
                           });
                       }
                       default : return state;
                   }
               }

               //提取工具函数
               //更新state工具函数
               function updateObject(oldObj,newObj){
                    return Object.assign({},oldObj,newObj);
               }
               function updateItemInArray(array,itemId,updateItemCallback){
                const updatedItems = array.map(item => {
                    if(item.id !== itemId) return item;

                    const updatedItem = updateItemCallback(item);
                    return updateItem;
                })

                return updatedItems;
               }

               //使用工具函数
               function appReducer(state = initialState, action) {
                   switch(action.type) {
                       case 'SET_VISIBILITY_FILTER' : {
                           return updateObject(state, {visibilityFilter : action.filter});
                       }
                       case 'ADD_TODO' : {
                           const newTodos = state.todos.concat({
                               id: action.id,
                               text: action.text,
                               completed: false
                           });

                           return updateObject(state, {todos : newTodos});
                       }
                       case 'TOGGLE_TODO' : {
                           const newTodos = updateItemInArray(state.todos, action.id, todo => {
                               return updateObject(todo, {completed : !todo.completed});
                           });

                           return updateObject(state, {todos : newTodos});
                       }
                       case 'EDIT_TODO' : {
                           const newTodos = updateItemInArray(state.todos, action.id, todo => {
                               return updateObject(todo, {text : action.text});
                           });

                           return updateObject(state, {todos : newTodos});
                       }
                       default : return state;
                   }
               }

               //提取case reducer
               function setVisibilityFilter(state, action) {
                   return updateObject(state, {visibilityFilter : action.filter });
               }

               function addTodo(state, action) {
                   const newTodos = state.todos.concat({
                       id: action.id,
                       text: action.text,
                       completed: false
                   });

                   return updateObject(state, {todos : newTodos});
               }

               function toggleTodo(state, action) {
                   const newTodos = updateItemInArray(state.todos, action.id, todo => {
                       return updateObject(todo, {completed : !todo.completed});
                   });

                   return updateObject(state, {todos : newTodos});
               }

               function editTodo(state, action) {
                   const newTodos = updateItemInArray(state.todos, action.id, todo => {
                       return updateObject(todo, {text : action.text});
                   });

                   return updateObject(state, {todos : newTodos});
               }

               function appReducer(state = initialState, action) {
                   switch(action.type) {
                       case 'SET_VISIBILITY_FILTER' : return setVisibilityFilter(state, action);
                       case 'ADD_TODO' : return addTodo(state, action);
                       case 'TOGGLE_TODO' : return toggleTodo(state, action);
                       case 'EDIT_TODO' : return editTodo(state, action);
                       default : return state;
                   }
               }

               //按域拆分数据
                function setVisibilityFilter(visibilityState, action) {
                    // 从技术上将，我们甚至不关心之前的状态
                    return action.filter;
                }

                function visibilityReducer(visibilityState = 'SHOW_ALL', action) {
                    switch(action.type) {
                        case 'SET_VISIBILITY_FILTER' : return setVisibilityFilter(visibilityState, action);
                        default : return visibilityState;
                    }
                };


                function addTodo(todosState, action) {
                    const newTodos = todosState.concat({
                        id: action.id,
                        text: action.text,
                        completed: false
                    });

                    return newTodos;
                }

                function toggleTodo(todosState, action) {
                    const newTodos = updateItemInArray(todosState, action.id, todo => {
                        return updateObject(todo, {completed : !todo.completed});
                    });

                    return newTodos;
                }

                function editTodo(todosState, action) {
                    const newTodos = updateItemInArray(todosState, action.id, todo => {
                        return updateObject(todo, {text : action.text});
                    });

                    return newTodos;
                }

                function todosReducer(todosState = [], action) {
                    switch(action.type) {
                        case 'ADD_TODO' : return addTodo(todosState, action);
                        case 'TOGGLE_TODO' : return toggleTodo(todosState, action);
                        case 'EDIT_TODO' : return editTodo(todosState, action);
                        default : return todosState;
                    }
                }

                function appReducer(state = initialState, action) {
                    return {
                        todos : todosReducer(state.todos, action),
                        visibilityFilter : visibilityReducer(state.visibilityFilter, action)
                    };
                }

                //减少样板代码
                function createReducer(initialState,handlers){
                    return function reducer(state = initialState,action){
                        if(handlers.hasOwnProperty(action.type)){
                            handlers[action.type](state,action);
                        }else{
                            return state;
                        }
                    }
                }

                function setVisibilityFilter(visibilityState, action) {}

                const visibilityReducer = createReducer('SHOW_ALL', {
                    'SET_VISIBILITY_FILTER' : setVisibilityFilter
                });

                // 省略了内容
                function addTodo(todosState, action) {}
                function toggleTodo(todosState, action) {}
                function editTodo(todosState, action) {}

                const todosReducer = createReducer([], {
                    'ADD_TODO' : addTodo,
                    'TOGGLE_TODO' : toggleTodo,
                    'EDIT_TODO' : editTodo
                });

                function appReducer(state = initialState, action) {
                    return {
                        todos : todosReducer(state.todos, action),
                        visibilityFilter : visibilityReducer(state.visibilityFilter, action)
                    };
                }

                //通过切片组合Reducer
                // 可重用的工具函数

                function updateObject(oldObject, newValues) {
                    // 将空对象作为第一个参数传递给 Object.assign，以确保只是复制数据，而不是去改变数据
                    return Object.assign({}, oldObject, newValues);
                }

                function updateItemInArray(array, itemId, updateItemCallback) {
                    const updatedItems = array.map(item => {
                        if(item.id !== itemId) {
                            // 因为我们只想更新一个项目，所以保留所有的其他项目
                            return item;
                        }

                         // 使用提供的回调来创建新的项目
                        const updatedItem = updateItemCallback(item);
                        return updatedItem;
                    });

                    return updatedItems;
                }

                function createReducer(initialState, handlers) {
                  return function reducer(state = initialState, action) {
                    if (handlers.hasOwnProperty(action.type)) {
                      return handlers[action.type](state, action)
                    } else {
                      return state
                    }
                  }
                }


                // 处理特殊 case 的 Handler ("case reducer")
                function setVisibilityFilter(visibilityState, action) {
                    // 从技术上将，我们甚至不关心之前的状态
                    return action.filter;
                }

                // 处理整个 state 切片的 Handler ("slice reducer")
                const visibilityReducer = createReducer('SHOW_ALL', {
                    'SET_VISIBILITY_FILTER' : setVisibilityFilter
                });

                // Case reducer
                function addTodo(todosState, action) {
                    const newTodos = todosState.concat({
                        id: action.id,
                        text: action.text,
                        completed: false
                    });

                    return newTodos;
                }

                // Case reducer
                function toggleTodo(todosState, action) {
                    const newTodos = updateItemInArray(todosState, action.id, todo => {
                        return updateObject(todo, {completed : !todo.completed});
                    });

                    return newTodos;
                }

                // Case reducer
                function editTodo(todosState, action) {
                    const newTodos = updateItemInArray(todosState, action.id, todo => {
                        return updateObject(todo, {text : action.text});
                    });

                    return newTodos;
                }

                // Slice reducer
                const todosReducer = createReducer([], {
                    'ADD_TODO' : addTodo,
                    'TOGGLE_TODO' : toggleTodo,
                    'EDIT_TODO' : editTodo
                });

                // 顶层 reducer
                const appReducer = combineReducers({
                    visibilityFilter : visibilityReducer,
                    todos : todosReducer
                });
    》combineReducers用法
        使用combineReducer的时候的注意点：
        》combineReducer只是一个工具函数，用于简化编写Redux reducer时最常见的场景。你没有必要一定在你的应用程序中使用它，它不会处理
          每一种可能的场景。你完全可以不使用它来编写reducer或者对combinerReducer不能处理的情况编写自定义的reducer。
        》虽然Redux本身并不管你的state是如何组织的，但是combineReducer强制约定来几个规则来帮助使用者避免常见的错误。
        》combineReducers会调用所有的reducer，严格来说是它包装的所有reducer
        》你可以在任何级别的reducer中使用combineReducer，不仅仅是在创建根reducer的时候。在不同地地方有多个组合的reducer是非常常见的，
          它们组合到一起来创建根reducer。

        》定义state结构
            》createStore函数可以将preloadedState作为第二个参数，主要用于初始化那些在其他地方有持久化存储的state。如localStorage
            》当state时undefined的时候返回initial state(定义reducer时的初始值)。

        combineReducers接收拆分后的reducer函数组成的对象，并且创建出具有相同键对应状态对象的函数。
        // reducers.js
        export default theDefaultReducer = (state = 0, action) => state;

        export const firstNamedReducer = (state = 1, action) => state;

        export const secondNamedReducer = (state = 2, action) => state;


        // rootReducer.js
        import {combineReducers, createStore} from "redux";

        import theDefaultReducer, {firstNamedReducer, secondNamedReducer} from "./reducers";


        // 使用 ES6 的对象字面量简写方式定义对象结构
        const rootReducer = combineReducers({
            theDefaultReducer,
            firstNamedReducer,
            secondNamedReducer
        });

        const store = createStore(rootReducer);
        console.log(store.getState());
        // {theDefaultReducer : 0, firstNamedReducer : 1, secondNamedReducer : 2}
    》combineReducers进阶
        》结合Immutable.js对象使用reducers
            目前combineReducers只能处理普通的js对象，对于把Immutable.js Map对象作为顶层state树的应用程序来说，可能无法使用combineReducers
            管理应用状态。推荐 redux-immutable(https://github.com/gajus/redux-immutable)，这个第三方实现了一个能处理Immutable Map数据而非
            普通的js都系的combineReducers。
        》不同reducers之间共享数据
            类似地，如果sliceReducerA为了处理特殊的action正好需要来自sliceReducerB的部分state数据或者sliceReducerB正好需要全部的state作为参数。
            单单是combineReducers是无法解决这种问题的。
            解决：把所需数据当额外参数的形式传递给自定义函数
                function combinedReducer(state, action) {
                    switch(action.type) {
                        case "A_TYPICAL_ACTION" : {
                            return {
                                a : sliceReducerA(state.a, action),
                                b : sliceReducerB(state.b, action)
                            };
                        }
                        case "SOME_SPECIAL_ACTION" : {
                            return {
                                // 明确地把 state.b 作为额外参数进行传递
                                a : sliceReducerA(state.a, action, state.b),
                                b : sliceReducerB(state.b, action)
                            }
                        }
                        case "ANOTHER_SPECIAL_ACTION" : {
                            return {
                                a : sliceReducerA(state.a, action),
                                // 明确地把全部的 state 作为额外参数进行传递
                                b : sliceReducerB(state.b, action, state)
                            }
                        }
                        default: return state;
                    }
                }
            方式2：共享片段数据更新，给action添加额外的数据 可以通过thunk函数或类似的方法轻松实现
                function someSpecialActionCreator(){
                    return (dispatch,getState) =>{
                        const state = getState();
                        const dataFromB = selectImportantDataFromB(state);

                        dispatch({
                            type : "SOME_SPECIAL_ACTION",
                            payload : {
                                dataFromB
                            }
                        });
                    }
                }
            方式3：使用combineReducers组合reducer来处理简单的场景，每个reducer依旧只更新自己的数据，同时新加一个reducer来处理多块
            数据交叉的复杂场景，最后写一个包裹函数依次调用这两类reducer并得到最终结果。
                const combinedReducer = combineReducers({
                    a : sliceReducerA,
                    b : sliceReducerB
                });

                function crossSliceReducer(state, action) {
                    switch(action.type) {
                        case "SOME_SPECIAL_ACTION" : {
                            return {
                                // 明确地把 state.b 作为额外参数进行传递
                                a : handleSpecialCaseForA(state.a, action, state.b),
                                b : sliceReducerB(state.b, action)
                            }
                        }
                        default : return state;
                    }
                }

                function rootReducer(state, action) {
                    const intermediateState = combinedReducer(state, action);
                    const finalState = crossSliceReducer(intermediateState, action);
                    return finalState;
                }
                //reduce-reducers可以简化以上操作流程。它接收多个reducer然后对它们依次执行reduce()操作，并把产生的中间值依次传递给下一个reducer。
                    // 与上述手动编写的 `rootReducer` 一样
                    const rootReducer = reduceReducers(combinedReducers, crossSliceReducer);
                    值得注意的是，如果你使用 reduceReducers 你应该确保第一个 reducer 能够定义初始状态的 state 数据，因为后续的 reducers 通常会
                    假定 state 树已经存在，也就不会为此提供默认状态。
    》State范式化
        》任何类型的数据在state中都有自己的表
        》任何数据表应将各个项目存储在对象中，其中每个项目的ID作为key，项目本身作为value
        》任何对单个项目的引用都应该根据存储项目的ID来完成
        》ID数组应用用于排序

        需要注意的是，范式化的 state 意味更多的组件被 connect，每个组件负责查找自己的数据，
        这和小部分的组件被 connect，然后查找大部分的数据再进行向下传递数据是恰恰相反的。事实
        证明，connect 父组件只需要将数据项的 Id 传递给 connect 的子对象是在 Redux 应用中优化 UI
        性能的良好模式，因此保持范式化的 state 在提高性能方面起着关键作用。
    》管理范式化数据
        》简单合并
            将action的内容合并到现有的state。在这种情况下，我们需要一个对数据的深拷贝。Lodash的merge方法可以处理这个
            import merge from "lodash/object/merge";
            function commentsById(state = {},action){
                switch(action.type){
                    default:{
                           if(action.entities && action.entities.comments) {
                            return merge({}, state, action.entities.comments.byId);
                           }
                           return state;
                    }
                }
            }
            //这样做会让reducer保持最小的工作量，但需要action creator在action dispatch之前做大量的工作来将数据转化成正确的形态。
            在删除数据项时这种方式也是不适合的。
        》reducer切片组合
            如果我们有一个由切片reducer组成的嵌套数据，每个切片的reducer都需要知道如何响应这个action。因为我们需要让action
            囊括所有的相关数据。比如更新相应的POst对象需要生成一个comment的id，然后使用id作为key创建一个新的comment对象，并且
            创建一个新的comment对象，并且让这个comment的id包括所有的comment id列表。

            //actions.js
            function addComment(postId,commentText){
                //生成comment ID
                const commentId = generateId('comment');

                return {
                    type:"ADD_COMMENT",
                    payload:{
                        postId,
                        commentId,
                        commentText
                    }
                }
            }

            //reducers/posts.js
            function addComment(state,action){
                const {payload} = action;
                const{postId,commentId} = payload;

                const post = state[postId];

                return {
                    ...state,
                    [postId]:{
                        ...post,
                        comments:post.comments.concat(commentId)
                    }
                }
            }
            function postsById(state = {}, action) {
                switch(action.type) {
                    case "ADD_COMMENT" : return addComment(state, action);
                    default : return state;
                }
            }

            function allPosts(state = [], action) {
                // 省略，这个例子中不需要它
            }

            const postsReducer = combineReducers({
                byId : postsById,
                allIds : allPosts
            });
            // reducers/comments.js
            function addCommentEntry(state, action) {
                const {payload} = action;
                const {commentId, commentText} = payload;

                // 创建一个新的 Comment 对象
                const comment = {id : commentId, text : commentText};

                // 在查询表中插入新的 Comment 对象
                return {
                    ...state,
                    [commentId] : comment
                };
            }

            function commentsById(state = {}, action) {
                switch(action.type) {
                    case "ADD_COMMENT" : return addCommentEntry(state, action);
                    default : return state;
                }
            }


            function addCommentId(state, action) {
                const {payload} = action;
                const {commentId} = payload;
                // 把新 Comment 的 ID 添加在 all IDs 的列表后面
                return state.concat(commentId);
            }

            function allComments(state = [], action) {
                switch(action.type) {
                    case "ADD_COMMENT" : return addCommentId(state, action);
                    default : return state;
                }
            }

            const commentsReducer = combineReducers({
                byId : commentsById,
                allIds : allComments
            });
        》基于任务的更新
            reducer仅仅是个函数，因此有无数种方法来拆分这个逻辑。使用切片reducer是最常见的，但也可以在更面向任务的结构中组织行为。
            由于通常会涉及到更多嵌套的更新因此常常会使用 dot-prop-immutable、object-path-immutable 等库实现不可变更新。
            import posts from './postsReducer'
            import comments from './commentsReducer'
            import dotProp from 'dot-prop-immutable'
            import {combineReducers} from 'redux'
            import reduceReducers from 'reduce-reducers'

            const combinedReducer = combineReducers({
                posts,
                comments
            });


            function addComment(state, action) {
                const {payload} = action;
                const {postId, commentId, commentText} = payload;

                // State here is the entire combined state
                const updatedWithPostState = dotProp.set(
                    state,
                    `posts.byId.${postId}.comments`,
                    comments => comments.concat(commentId)
                );

                const updatedWithCommentsTable = dotProp.set(
                    updatedWithPostState,
                    `comments.byId.${commentId}`,
                    {id : commentId, text : commentText}
                );

                const updatedWithCommentsList = dotProp.set(
                    updatedWithCommentsTable,
                    `comments.allIds`,
                    allIds => allIds.concat(commentId);
                );

                return updatedWithCommentsList;
            }

            const featureReducers = createReducer({}, {
                ADD_COMMENT : addComment,
            };

            const rootReducer = reduceReducers(
                combinedReducer,
                featureReducers
            );
        》Redux-ORM
            Redux-ORM库提供了一个非常有用的抽象层，用于管理Redux store中存储的范式化数据。它允许你声明Model类并定义它们之间的关系。
            然后它可以为你的数据类型生成新表，充当用于查找数据的特殊选择器工具，并且对数据执行不可变更新。

            有几种方法可以用Redux-ORM执行数据更新。首选Redux-ORM文档建议在每个Model子类上定义reducer函数，然后将自动生成的组合reducer
            函数放到store中。

            //models.js
            import {Model,many,Schema} from 'redux-orm'
            export class Post extends Model{
                static get fields(){
                    return {
                        //定义一个多边关系，一个Post可以有多个Comments，
                        comments:many('Comment')
                    }
                }

                static reducer(state,action,Post){
                    switch(action.type) {
                          case "CREATE_POST" : {
                            // 排队创建一个 Post 实例
                            Post.create(action.payload);
                            break;
                          }
                          case "ADD_COMMENT" : {
                            const {payload} = action;
                            const {postId, commentId} = payload;
                            // 排队增加一个 Comment ID 和 Post 实例的联系
                            Post.withId(postId).comments.add(commentId);
                            break;
                          }
                    }
                }
            }

            Post.modelName = "Post";

            export class Comment extends Model {
              static get fields() {
                return {};
              }

              static reducer(state, action, Comment) {
                switch(action.type) {
                  case "ADD_COMMENT" : {
                    const {payload} = action;
                    const {commentId, commentText} = payload;

                    // 排队创建一个 Comment 实例
                    Comment.create({id : commentId, text : commentText});
                    break;
                  }
                }

                // Redux-ORM 将在返回后自动应用排队的更新
              }
            }
            Comment.modelName = "Comment";

            // 创建 Schema 实例，然后和 Post、Comment 数据模型挂钩起来
            export const schema = new Schema();
            schema.register(Post, Comment);


            // main.js
            import { createStore, combineReducers } from 'redux'
            import {schema} from "./models";

            const rootReducer = combineReducers({
              // 插入 Redux-ORM 自动生成的 reducer，这将
              // 初始化一个数据模型 “表”，并且和我们在
              // 每个 Model 子类中定义的 reducer 逻辑挂钩起来
              entities : schema.reducer()
            });

            // dispatch 一个 action 以创建一个 Post 实例
            store.dispatch({
              type : "CREATE_POST",
              payload : {
                id : 1,
                name : "Test Post Please Ignore"
              }
            });

            // dispath 一个 action 以创建一个 Comment 实例作为上个 Post 的子元素
            store.dispatch({
              type : "ADD_COMMENT",
              payload : {
                postId : 1,
                commentId : 123,
                commentText : "This is a comment"
              }
        });
    //Redux-ORM库维护要应用的内部更新队列。这些更新是不可变更新，这个库简化了这个更新过程。
    //使用Redux-ORM的另一个变化是用一个单一的case reducer作为抽象层
    import {schema} from "./models";

    // 假设这个 case reducer 正在我们的 “entities” 切片 reducer 使用，
    // 并且我们在 Redux-ORM 的 Model 子类上没有定义 reducer
    function addComment(entitiesState, action) {
        const session = schema.from(entitiesState);
        const {Post, Comment} = session;
        const {payload} = action;
        const {postId, commentId, commentText} = payload;

        const post = Post.withId(postId);
        post.comments.add(commentId);

        Comment.create({id : commentId, text : commentText});

        return session.reduce();
    }
    总之，Redux-ORM 提供了一组非常有用的抽象，用于定义数据类型之间的关系，
    在我们的 state 中创建了一个 “表”，检索和反规划关系数据，以及将不可变更新应用于关系数据。

    》Reducer逻辑复用
        //假设想在程序中追踪多个计数器，分别命名为A B C。定义初始的counter reducer，然后使用combineReducer去设置状态。
        function counter(state = 0,action){
            switch (action.type) {
                    case 'INCREMENT':
                        return state + 1;
                    case 'DECREMENT':
                        return state - 1;
                    default:
                        return state;
            }
        }
        const rootReducer = combineReducers({
            counterA : counter,
            counterB : counter,
            counterC : counter
        });
        //这样设置有一个问题，因为combineReducers将会使用相同的action调用每个reducer，发送{type:"INCREMENT"}实际上将会
        导致所有三个计数器的值被增加，而不仅仅是其中一个，我们需要一些方法去封装counter的逻辑以此来保证只有我们关心的计
        数器被更新。

        》使用高阶Reducer来定制行为
            高阶reducer是一个接收reducer函数作为参数，并返回新的reducer函数的函数。
            我们可以使用这种模式来创建特定版本的reducer函数，每个版本只响应特定的action

            创建特定的reducer有两种最常见的方式，一个是使用给定的前缀或后缀生成新的action常量，另一个是
            在action对象上附加额外的信息
            //方式1
            function createCounterWidthNamedType(counterName = ''){
                return function counter (state = 0,action){
                    switch (action.type) {
                        case `INCREMENT_${counterName}`:
                            return state + 1;
                        case `DECREMENT_${counterName}`:
                            return state - 1;
                        default:
                            return state;
                    }
                }
            }
            //方式2
            function createCounterWithNameData(counterName = ''){
                return function counter(state = 0,action){
                    const {name} = action;
                    if(name !== counterName) return state;

                    switch (action.type) {
                        case `INCREMENT`:
                            return state + 1;
                        case `DECREMENT`:
                            return state - 1;
                        default:
                            return state;
                    }
                }
            }
            //现在我们应该可以使用它们任何一个去生成我们特定的计数器reducer，然后发送action
            const rootReducer = combineReducers({
                counterA : createCounterWithNamedType('A'),
                counterB : createCounterWithNamedType('B'),
                counterC : createCounterWithNamedType('C'),
            });

            store.dispatch({type : 'INCREMENT_B'});
            console.log(store.getState());
            // {counterA : 0, counterB : 1, counterC : 0}

        //在某种程度上也可以改变这个方法，创建一个更加通用的高级reducer，它可以接收一个给定的reducer，一个名字或标识符
            function counter(state = 0, action) {
                switch (action.type) {
                    case 'INCREMENT':
                        return state + 1;
                    case 'DECREMENT':
                        return state - 1;
                    default:
                        return state;
                }
            }
            function createNamedWrapperReducer(reducerFun,reducerName){
                return (state,action) => {
                    const {name} = action;
                    const isInitializationCall = state === undefined;
                    if(name !== reducerName && !isInitializationCall) return state;

                    return reducerFun(state,action);
                }
            }
            const rootReducer = combineReducers({
                counterA : createNamedWrapperReducer(counter, 'A'),
                counterB : createNamedWrapperReducer(counter, 'B'),
                counterC : createNamedWrapperReducer(counter, 'C'),
            });
        //甚至还可以写一个通用的高阶reducer过滤器
        function createFilteredReducer(reducerFun,reducerPredicate){
            return (state,action) => {
                const isInitializationCall = state === undefined;
                const shouldRunWrappedReducer = reducerPredicate(action) || isInitializationCall;
                return shouldRunWrappedReducer ? reducerFun(state,action) : state;
            }
        }
        const rootReducer = combineReducers({
            // 检查后缀
            counterA : createFilteredReducer(counter, action => action.type.endsWith('_A')),
            // 检查 action 中的额外数据
            counterB : createFilteredReducer(counter, action => action.name === 'B'),
            // 响应所有的 'INCREMENT' action，但不响应 'DECREMENT'
            counterC : createFilteredReducer(counter, action => action.type === 'INCREMENT')
        };
    》不可变更新模式
        》更新嵌套的对象
            更新嵌套数据的关键是必须适当的复制和更新嵌套的每个级别。
            //常见错误1：指向同一对象的新变量
            定义一个新变量不会创建一个新的实际都系，它只创建另一个引用到同一对象
            function updateNestedState(state,action){
                let nestedState = state.nestedState;
                // 错误: 这将导致直接修改已经存在的对象引用-不要这么做!
                nestedState.nestedField = action.data;

                return {
                    ...state,
                    nestedState
                };
            }
            //这个函数正确返回来顶层状态对象的浅复制，但是变量nestedState依然指向以及存在的对象，这个状态被直接修改了
            //常见错误2：仅仅在一个层级上做浅复制
            function updateNestedState(state, action) {
                // 问题: 这仅仅做了浅复制！
                let newState = {...state};

                // 错误: nestedState 仍然是同一个对象!
                newState.nestedState.nestedField = action.data;

                return newState;
            }
            //正确方法：复制嵌套数据的所有层级
            function updateVeryNestedField(state, action) {
                return {
                    ....state,
                    first : {
                        ...state.first,
                        second : {
                            ...state.first.second,
                            [action.someId] : {
                                ...state.first.second[action.someId],
                                fourth : action.someValue
                            }
                        }
                    }
                }
            }
        》在数组中插入和删除数据
            通常一个js数组中内容使用变化的函数来修改如：push unshift,shift。因为我们不想再reducer中直接修改状态，这些通常应该被避免。
            function insertItem(array,action){
                return[
                    ...array.slice(0,action.index),
                    action.item,
                    ...array.slice(action.index)
                ]
            }
            function removeItem(array,action){
                return [
                    ...array.slice(0,action.index),
                    ...array.slice(action.index+1)
                ]
            }
            //只要首先我们做了复制，就可以安全的变化这个复制
            function insertItem(array, action) {
                let newArray = array.slice();
                newArray.splice(action.index, 0, action.item);
                return newArray;
            }

            function removeItem(array, action) {
                let newArray = array.slice();
                newArray.splice(action.index, 1);
                return newArray;
            }
            //删除函数也可以是这样
            function removeItem(array, action) {
                return array.filter( (item, index) => index !== action.index);
            }
        》在一个数组中更新一个项目
            更新数组的一项可以使用Array.map返回我们想要更新哪项的一个新值和其他项原先的值：
            function updateObjectInArray(array, action) {
                return array.map( (item, index) => {
                    if(index !== action.index) {
                        // 这不是我们关心的项-保持原来的值
                        return item;
                    }

                    // 否则, 这是我们关心的-返回一个更新的值
                    return {
                        ...item,
                        ...action.item
                    };
                });
            }
        》不可变更新工具库
            因为编写不可变得更新代码可能变得乏味，所以许多工具程序库试图抽象出这个过程。这些库在API和用法上有所不同。
            但都试图提供一种更短和更简洁的方式来编写这些更新。如：dot-prop-immutable使用字符串路径作为命令：
            state = dotProp.set(state, `todos.${index}.complete`, true)
    》初始化State
        两种方法来初始化应用的state：
            》可以使用createStore方法中的第二个可选参数 preloadedState。
            》可以在reducer中为undefined的state参数指定默认的初始值。这个可以通过在reducer中添加一个明确的检查来完成，
              也可以使用Es6的默认参数语法function myReducer(state = someDefaultValue,action)。
        》概要
            如果不使用combineReducers()或类似的代码，那么preloadedState总是会优先于reducer里面使用state=...；因为state传到
            reducer里的事preloadState的state而不是undefined，所以ES6的默认参数并不起作用。

            如果使用combineReducers()方法，那么这个行为就会有差别。那些指定了preloadedState的reducer会接收到那些对应的state。而其他
            reducer将会接收到undefined并因此回到state=...这里获取指定的默认值。

            通常情况下，通过 preloadedState 指定的 state 要优先于通过 reducer 指定 state。这样可以使通过 reducer 默认参数指定初始数据
            显得更加的合理，并且当你从一些持久化的存储器或服务器更新 store 的时候，允许你更新已存在的数据（全部或者部分）。
        》单一简单的Reducer
            function counter(state = 0, action) {
              switch (action.type) {
              case 'INCREMENT': return state + 1;
              case 'DECREMENT': return state - 1;
              default: return state;
              }
            }
            import { createStore } from 'redux';
            let store = createStore(counter);
            console.log(store.getState()); // 0

            let store = createStore(counter, 42);
            console.log(store.getState()); // 42
        》组合多个Reducers
            function a(state = 'lol', action) {
              return state;
            }

            function b(state = 'wat', action) {
              return state;
            }

            function combined(state = {}, action) {
              return {
                a: a(state.a, action),
                b: b(state.b, action)
              };
            }

            import { createStore } from 'redux';
            let store = createStore(combined);
            console.log(store.getState()); // { a: 'lol', b: 'wat' }

            let store = createStore(combined, { a: 'horse' });
            console.log(store.getState()); // { a: 'horse', b: 'wat' }
7.Redux常见问题
    》综合
        》何时使用Redux
            一般而言，如果随着时间的推移，数据处于合理的变动之中、需要一个单一的数据源、在 React
            顶层组件 state 中维护所有内容的办法已经无法满足需求，这个时候就需要使用 Redux 了。
        》Redux只能搭配React使用？
            Redux 能作为任何 UI 层的 store。通常是与 React 或 React Native 搭配使用，但是也可以绑定
            Angular、 Angular 2、 Vue、 Mithril 等框架使用。 Redux 提供的订阅机制，可以与任何代码集成。
            这就是说，在结合 UI 随 state 变化的声明式视图时（如 React 或者其他相似的库），Redux 就发挥它的最大作用。
        》Redux需要特定的编译工具支持吗？
            Redux 写法遵循 ES6 语法，但在发布时被 Webpack 和 Babel 编译成了 ES5，所以在使用时可以忽略 JavaScript
            的编译过程。 Redux 也提供了 UMD 版本，可以直接使用而不需要任何编译过程。
            https://github.com/reactjs/redux/tree/master/examples/counter-vanilla(ES5的用法)
    》Reducer
        》如何在reducer之间共享state？combineReducers是必须的吗？
            Redux store 推荐的结构是将 state 对象按键值切分成 “层”（slice） 或者 “域”（domain），
            并提供独立的 reducer 方法管理各自的数据层。就像 Flux 模式中的多个独立 store 一样， Redux
            为此还提供了 combineReducers 工具来简化该模型。应当注意的是， combineReducers 不是 必须的，
            它仅仅是通过简单的 JavaScript 对象作为数据，让 state 层能与 reducer 一一关联的函数而已。

            //reducer之间共享数据，但是combineReducers不允许这种行为，方式：
            》如果一个 reducer 想获取其它 state 层的数据，往往意味着 state 树需要重构，需要让单独的 reducer 处理更多的数据。
            》你可能需要自定义方法去处理这些 action，用自定义的顶层 reducer 方法替换 combineReducers。你可以使用类似于 reduce-reducers
              的工具运行 combineReducers 去处理尽可能多的 action，同时还要为存在 state 交叉部分的若干 action 执行更专用的 reducer。
            》类似于 redux-thunk 的 异步 action 创建函数 能通过 getState() 方法获取所有的 state。 action 创建函数能从 state 中检索到额
              外的数据并传入 action，所以 reducer 有足够的信息去更新所维护的 state 层。
        》处理action必须用switch语句吗？
            不是。在 reducer 里面你可以使用任何方法响应 action。 switch 语句是最常用的方式，当然你也可以用 if、功能查找表、
            创建抽象函数等。事实上，虽然 Redux 要求每个 action 对象都有一个 type 的字段，但是你的 reducer 逻辑不必一定要依
            赖它做处理。也就是说，标准方法肯定是用基于 type 的 switch 语句或者查找表。
    》组织state
        》必须将所有state都维护在Redux中吗？可以用React的setState()方法吗？
            没有 “标准”。有些用户选择将所有数据都在 Redux 中维护，那么在任何时刻，应用都是完全有序及可控的。
            也有人将类似于“下拉菜单是否打开”的非关键或者 UI 状态，在组件内部维护。适合自己的才是最好的。

            使用局部组件状态是更好的。作为开发者应该决定使用何种state来组装你的应该，每个state的生存范围是什么。在
            两者之间做好平衡。

            》那些数据放入Redux的经验法则
                应用的其他部分是否关心这个数据
                是否需要根据需要在原始数据的基础上创建衍生数据
                相同的数据是否被用作驱动多个组件
                能否将状态恢复到特定时间点
                是否要缓存数据
        》可以将store的state设置为函数、promise或者其他非序列化的值吗
            强烈推荐只在 store 中维护普通的可序列化对象、数组以及基本数据类型。虽然从 技术 层面上将非序列化项保存在
            store 中是可行的，但这样会破坏 store 内容持久化和恢复能力，以及会干扰时间旅行。

            如果你不关心数据持久化和时间旅行，那么完全欢迎把不可以持久化的数据放入 Redux 的 Store 中存储。最终，他是你
            的应用程序，如何实现完全取决于你自己。与其他很多 Redux 的事情一样，你需要明白权衡所需。
        》如何在state中组织嵌套以及重复数据
            当数据存在 ID、嵌套或者关联关系时，应当以 “范式化” 形式存储：对象只能存储一次，ID 作为键值，对象间通过 ID
            相互引用。将 store 类比于数据库，每一项都是独立的 “表”。normalizr 、 redux-orm 此类的库能在管理规范化数据
            时提供参考和抽象。
    》创建Store
        




































