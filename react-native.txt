/************************React Native***********************/
1.环境搭建
    windows --> android
        》安装jdk
            v1.8以上
        》安装sdk
            http://www.androiddevtools.cn/
        》安装c++环境
            选择windows SDK cygwin或mingw等其他C++环境，编译node.js的c++模块需要用到
        》安装Node 与 Git
             echo %PATH% 查看环境变量(命令行)
             设置npm镜像：
                npm config set registry https://registry.npm.taobao.org --global
                npm config set disturl https://npm.taobao.org/dist --global
        》安装React Native命令行工具
            npm install -g react-native-cli
        》创建项目
            react-native init 项目名
        》进入工程目录运行packager
            react-native start
            可以用浏览器方法http://localhost:8081/index.android.bundle?platform=android(.49版本以前)查看是否可以看到打包后的脚本
            http://localhost:8081/index.bundle?platform=android(.49版本)
        》准备模拟器或真机运行android
            react-native run-android

            adb devices 查看手机列表 如果出错 可能是360等引起的  需要关闭

            android studio 管理genymotion模拟器 需要在插件中下载 genymotion 然后关联 自己的genymotion即可

            真机测试
                使用droidAtScreen-1.2.jar 把手机屏幕投到电脑屏幕上，方便查看
            问题：
                找不到SDK或者无法正常化SDK路径 --》 查看环境变量是否配置正确
                build成功后是红色：没有链接到服务器js Server --》 在手机端配置debug ip: ip+8081端口 如：192.168.1.100：8081
        》调试App -- 更新应用
            reload js (菜单中 reload)
            android -- 双击rr
            iOS -- Cmd+R (Cmd+D 打开菜单)

    Mac
        Win7是Server，Mac是Client，VMware上运行Mac系统
        1、在VMware的Options菜单中选择Shared Folders选项
        2、选择Always enabled选项
        3、然后选择要在Win7系统上共享的文件夹路径名
        4、在Win7系统下将改文件夹设为共享
        5、进入MAC系统桌面右键点击Finder前往菜单Connectting to Server
        6、在连接服务器对话框中输入[smb://Windows主机的IP地址],其中smb是访问Windows共享文件夹所使用的协议名称
        7、连接到Windows主机之后会显示该主机所共享的文件夹，选择想要访问的一个即可
        8、这样再次打开Finder的时候就可以直接访问到共享文件夹了

        》安装Homebrew
            /usr/bin/ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)"
            权限的问题安装失败：sudo chown -R `whoami` /usr/local
        》使用Homebrew安装Node
            brew install node
            npm config set registry https://registry.npm.taobao.org --global
            npm config set disturl https://npm.taobao.org/dist --global
        》安装react-native-cli
            npm install -g yarn react-native-cli
            yarn config set registry https://registry.npm.taobao.org --global
            yarn config set disturl https://npm.taobao.org/dist --global
            //EACCES: permission denied:
            sudo chown -R `whoami` /usr/local
        》Watchman -- 热更新
            brew install watchman
        》Flow -- 一个静态的JS类型检查工具
            brew install flow

        iOS：
            》Xcode -- App Store下载安装  需要8.0以上版本
            》测试安装
                        react-native init test
                        react-native run-ios
        Android
            》JDK 1.8以上
            》AndroidStudio v2.x以上
                ANDROID_HOME环境变量：
                    vi ~/.bash_profile
                    # 如果你不是通过Android Studio安装的sdk，则其路径可能不同，请自行确定清楚。
                    export ANDROID_HOME=~/Library/Android/sdk
                    立即生效：source ~/.bash_profile
                    查看：echo $ANDROID_HOME
                    #添加Android SDK环境变量的Tools添加到PATH变量中 ~/.bash_profile
                    export PATH=$PATH:$ANDROID_HOME/tools:$ANDROID_HOME/platform-tools
            》Git
                brew install git
            》Genymotion 模拟器
            》Gradle Daemon 开启Gradle Daemon可以极大地提升java代码的增量编译速度。
                touch ~/.gradle/gradle.properties && echo "org.gradle.daemon=true" >> ~/.gradle/gradle.properties
            》测试安装
                react-native init test
                react-native run-android
2.从React到RN
    》React特点
        》作为UI
        》虚拟DOM
            是React最重要的一个特性，放进内存最小更新视图(差异部分更新 -- diff算法)
        》数据流 -- 单向数据流
    》为什么要使用React Native
        如何在开发成本和用户体验做到更好的平衡？很多时候前端有一种乐观的想法：h5可以替代原生应用(但性能不理想)
        RN不仅可以使用前段开发的模式来开发应用，还能调用原生应用的UI组件和API。
3.flexbox布局
    flexbox是Flexible Box的缩写即弹性盒子布局 -- 主流浏览器都支持。

    flexbox是伸缩容器container和伸缩项目item组成。

    flexbox布局的主体思想是元素可以改变大小以适应可用空间，但可用空间变大Flex元素将伸展大小以填充可用空间，但Flex
    元素超出可用空间时将自动缩小。总之Flex元素是可以让你的布局根据浏览器的大小变化进行自动伸缩。

    按照伸缩流的方向布局：伸缩容器有主轴和交叉轴(垂直于主轴的次轴)组成，主轴既可以是水平轴也可以是垂直轴。

    flexbox目前还处于草稿状态，所有在使用flexbox布局的时候，需要加上各个浏览器的私有兼容前缀如：-webkit -moz -ms -o等。

    》伸缩容器的属性
        》display:flex(块级伸缩容器) | inline-flex(行内级伸缩容器)
        》flex-direction 指定主轴的方向
            flex-direction：row(默认值 从左到右) | row-reverse(从右到左) | column(从上到下) | column-reverse(从下到上)
        》flex-wrap 伸缩容器在主轴线方向空间不足的情况下，是否换行以及该如何换行
            flex-wrap:nowrap(默认值 不换行 flex的项会自动缩小) | wrap(换行 从上到下) | wrap-reverse(换行  从下到上)
        》flex-flow 是flex-direction和flex-wrap的缩写版本，它同时定义了伸缩容器的主轴和侧轴  其默认值 row nowrap;
        》justify-content 用来定义伸缩项目 在主轴线的对齐方式
            justify-content:flex-start(默认值 起始方向) | flex-end(结束位置) | center(中心) | space-between(均匀分布在主轴线上) | space-around(均匀分布在主轴线上，开始位置和结束为止留中间间隙的一半)
        》align-items 用来定义伸缩项目在交叉轴上的对齐方式
            align-items:flex-start(默认值 交叉轴起始位置) | flex-end(结束位置) | center(中心) | baseline(基准线) | stretch(沿着交叉轴拉伸铺满)

        》align-content
            用来调整伸缩项目换行后 在交叉轴上的对齐方式
            align-content:flex-start(交叉轴的起始位置) | flex-end(结束位置) | center(中心) | space-between(均匀分布在交叉轴上) | space-around(均匀分布在交叉轴上 起始位置和结束位置有间隙) | stretch(默认值)

        伸缩项目的属性
        》order:整数值
            定义项目排列顺序，数值越小，排列越靠前，默认值是0

        》flex-grow:整数值
            定义伸缩项目的放大比例     默认值是0--即表示如果存在剩余空间也不放大
        》flex-shrink:整数值  当容器大小不足的时候起作用
            定义伸缩项目的收缩能力，默认值是1
        》flex-basis:length(如：200px) | auto(默认值)
            用来设置伸缩项目的基准值，剩余的空间按比率进行伸缩。
        》flex ：none | flex-grow flex-shrink flex-basis 其中第二个和第三个参数为可选参数 默认值：0 1 auto;
            是flex-grow flex-shrink flex-basis这三个属性的缩写
        》align-self : auto | flex-start | flex-end | center | baseline | stretch(伸缩项目在交叉轴方向沾满伸缩容器，
            如果交叉轴沾满伸缩容器，如果交叉轴为垂直方向的话，只有在不设置高度的情况下才能看到效果。)
            用来设置单独的伸缩项目在交叉轴上的对齐方式，会覆盖默认的对齐方式
4.在React Native中使用flexbox
    RN目前主要支持flexbox的如下6个属性：
    》alignItems:flex-start(默认值) | flex-end | center| stretch
        用来定义伸缩项目在交叉轴上的对齐方式
    》alignSelf:auto | flex-start | flex-end | center | stretch(伸缩项目在交叉轴方向沾满伸缩容器，如果交叉轴为垂直方向的话，只有在不设置高度的情况下才能看到效果)
        用来设置单独的伸缩项在交叉轴的对齐方式，会覆盖默认的对齐方式。
    》flex
        和web端的flex用法一样
    》flexDirection:row | row-reverse | column(默认值) | column-reverse
        指定主轴的方向
    》flexWrap
        用法和web端一样
    》justifyContent
        用法和web端一样
5.html5与react native的区别
    》样式

    》元素

    》书写格式
6.JSX
    React是由ReactJs与React Native组成，其中ReactJs是Facebook开源的一个前端框架，React Native是ReactJs思想在native上的体现。
    JSX不是一门新的语言，仅仅是语法糖，允许开发者在js中书写HTML语法，最后每个HTML标签都转化为js代码来运行。

7.ReactJs
    核心思想：组件化 维护自己的状态和UI，自动重新渲染。多个组件组成了一个ReactJS应用。
    虚拟DOM：将真实的DOM结构映射成一个JSON的数据结构。

8.调式与打包发布
    调式：
        reload js --更新代码之后 reload js会更新app
        debug js 和chrome结合使用
        enable live reload --开启自动刷新app 更新代码自动刷新
        检查元素
        enable perf monitor -- 查看性能
        dev settings
    打包发布：
        1.生成一个签名密钥
            keytool -genkey -v -keystore my-release-key.keystore -alias my-key-alias -keyalg RSA -keysize 2048 -validity 10000
            或
            keytool -importkeystore -srckeystore my-release-key.keystore -destkeystore my-release-key.keystore -deststoretype pkcs12
        2.找到路径/android/app/src/main，并在该目录下新建assets文件夹
        3.在工程目录下将index.android.bundle下载并保存到assets资源文件夹中
            curl -k 'http://localhost:8081/index.android.bundle' > android/app/src/main/assets/index.android.bundle
            上面命令是重点，如果assets目录中不存在该文件，则打包的apk在执行时显示空白。

            如果出现：Protocol "'http" not supported or disabled in libcurl错误
            执行：curl -k "http://localhost:8081/index.android.bundle" > android/app/src/main/assets/index.android.bundle

            使用这个命令：curl -k "http://localhost:8081/index.bundle?platform=android" > android/app/src/main/assets/index.bundle

            如果curl命令不存在，windows安装使用curl命令：http://jingyan.baidu.com/article/a681b0dec4c67a3b1943467c.html
            将curl.exe放到需要执行curl命令的目录下 也可以设置环境变量
        4.添加gradle的android keystore配置
            打包的apk在未签名的情况下，在手机中(非root)是不允许安装的

            在app目录下的build.gradle文件中：
            //添加签名 -- defaultConfig下面
            signingConfigs {
                release {
                    storeFile file("my-release-key.keystore路径")
                    storePassword "密码"
                    keyAlias "keyAlias的名字"
                    keyPassword "密码"

                    如：
                    storeFile file("E://projects/record/react-native/myReactNative/my-release-key.keystore")
                    storePassword "123456"
                    keyAlias "my-key-alias"
                    keyPassword "123456"
                }
            }

            //在buildTypes中 引用签名配置
            buildTypes {
                release {
                    minifyEnable false
                    proguardFiles getDefaultProguardFile('......')
                    //添加下面即可
                    signingConfig signingConfigs.release
                }
            }
        5.启用Proguard代码混淆来缩小APK文件的大小
            Proguard是一个Java字节码混淆压缩工具，它可以移除掉React Native Java和它的依赖库中没有被使用到的部分，最终
            有效的减少APK的大小。
            重要：启用Proguard之后，你必须再次全面测试你的应用，Proguard有时候需要为你引入的每个原生库做一些额外的配置。
                  参见app/proguard-rules.pro文件。

            def enableProguardInReleaseBuilds = true //在app/build.gradle
        6.在**/android/**目录中执行gradle assembleRelease命令，打包后的文件在android/app/build/outputs/apk(debug.apk是开发环境用到的包)目录中，如：app-release.apk。
          如果打包碰到问题可以先执行 gradle clean清理一下。
          **unaligned.apk是没有签名的(不使用)**

          安装gradle工具(版本与android/gradle/wrapper/gradle-wrapper.properties下的一致)，并配置环境变量，配置GRADLE_HOME到gradle根目录中，然后把%GRADLE_HOME%/bin(
          linux或mac是$GRADLE_HOME/bin)加到PATH环境变量中。
          配置完成之后，运行gradle -v,检测是否安装无误。
        7.将apk发布到各大应用市场
9.React Native 组件
    》View组件
        它类似于div，支持多层嵌套，支持flexbox布局。

        组件使用步骤：
            》加载View组件
                import {View} from 'react-native'
            》创建组件
                class ViewTest extends React.Component{

                    render(){
                        return (
                            <View style={styles.flex}/>
                        );
                    }
                }
            》添加样式表
                import {StyleSheet} from 'react-native'
                const styles = StyleSheet.create({
                    flex:{flex:1}
                });

                外联样式: -- 推荐
                    <View style={ styles.flex }></View>
                内联样式：-- 不推荐
                    <View style={ {flex:1,borderWidth:1} }></View>
                多个样式:
                    <View style={ [styles.flex,{flexDirection:'row'}] }></View>


                import {PixelRatio} from 'react-native'
                //PixelRatio.get() -- 获取高清设备的像素比
                //1/PixelRatio.get() -- 当前设备的最小像素
                //使用场景：
                如：borderLeftWidth:1/PixelRatio.get()
            》注册入口 -- 一个应用，只有一个
                import { AppRegistry } from 'react-native';
                import App from './App';

                AppRegistry.registerComponent('myReactNative/*应用名称*/', () => App /*入口组件*/);
            》外层布局

            》flexbox水平三栏布局

            》上下两栏布局

            》完善效果
    》Text组件 主要用于显示文本，具有响应性，可以嵌套，可以继承样式
               内部Text组件可以继承外部Text组件的样式。
      Text组件的特性：
        》onPress 点击事件触发
        》numberOfLines 最多显示多少行，超过用省略号替代
        》onLayout 获取元素的位置和大小
    》Navigator组件
        一个应用往往是由多功能视图组成，多页面的切换：路由或导航。在RN中专门负责视图切换的组件：Navigator(android or iOS)，NavigatorIOS(iOS)。

        导航器对比：
            Navigator和NavigatorIOS都可以用来管理应用中"场景"的导航。导航器建立了一个路由栈，用来弹出，推入或替换路由状态。他们
            和HTML5中的history API很类似。主要区别在于NavigatorIOS使用了iOS中的UINavigationController类，而Navigator则完全用js
            重写了一个类似功能的React组件。因此Navigator可以兼容iOS和android，而NavigatorIOS只能用于iOS。

            NavigatorIOS轻量，受限的API设置，使其相对于Navigator来说不太方便定制。由开源社区主导开发，React Native的官方
            团队并不在自己的应用中使用它。

            对于大多数正式APP开发，建议使用Navigator -- 使用NavigatorIOS实现复杂的需求容易碰到麻烦。

            导航器通过路由对象来分辨不同的场景。利用renderScene方法，导航栏可以根据指定的路由来渲染场景。
            可以通过configureScene属性获取指定路由对象的配置信息，从而改变场景的动画或手势。
            renderScene = {
                (route,navigator) => {
                    let Component = route.component;
                    return <Component {...route.params} navigator={navigator}/>
                }
            }




































/************************文档分析***********************/
http://reactnative.cn/docs/0.49/getting-started.html
1.搭建开发环境
    1.1 Windows
      》Android
        安装
            必需的软件
            》Chocolatey(https://chocolatey.org/) -- 是windows上的包管理器，类似于linux上的yum和apt-get

                命令：
                @powershell -NoProfile -ExecutionPolicy Bypass -Command "iex ((new-object net.webclient).DownloadString('https://chocolatey.org/install.ps1'))" && SET PATH=%PATH%;%ALLUSERSPROFILE%\chocolatey\bin
                以管理员身份运行命令窗口，无法安装也无所谓，它只是一个包管理器
            》Python2
                使用Chocolatey来安装Python2，目前不支持Python3版本
                choco install python2
            》Node
                安装NodeJS
                choco install nodejs.install

                安装完node后建议设置npm镜像，注意：不要使用cnpm cnpm安装的模块路径比较奇怪，packager不能正常识别
                npm config set registry https://registry.npm.taobao.org --global
                npm config set disturl https://npm.taobao.org/dist --global
            》  Yarn、React Native的命令行工具(react-native-cli)
                Yarn是Facebook提供的替代npm的工具，可以加速node模块的下载。
                React Native的命令行工具用于执行创建、初始化、更新项目、运行打包服务packager等任务

                npm install -g yarn react-native-cli

                安装完yarn后同理设置镜像源
                yarn config set registry https://registry.npm.taobao.org --global
                yarn config set disturl https://npm.taobao.org/dist --global

                如果遇到EACCES: permission denied权限错误，可以尝试下面命令(Linux系统)：
                sudo npm install -g yarn react-native-cli

                安装完yarn之后可以使用yarn代替npm：
                    yarn 代替 npm install 命令
                    yarn add 第三方库名 代替 npm install --save 第三方库名

                注意：目前npm5存在安装新库时会删除其他库的问题，导致项目无法正常运行，所以尽量使用yarn代替npm操作。
            》Android Studio -- http://developer.android.com/sdk/index.html
                React Native目前需要Android Studio2.0或更高版本
                Android Studio需要Java Development Kit [JDK]1.8或更高版本。你可以在命令行中输入 javac -version查看你当前安装的
                JDK版本。
                choco install jdk8或apt-get install default-jdk

                Android Studio包含了运行和测试React Native应用所需要的Android SDK和模拟器。
                注意：除非特别注明，请不要改动安装过程中的选项，如：Android Studio默认安装了Android Support Repository，而这
                也是React Native必须的--否则react-native run-android时会报appcompat-v7包找不到的错误。

                确定所有安装都勾选了 尤其是android SDK 和Android Device Emulator。
                在初步安装完成后选择Custom安装项
                    》检测已安装的组件尤其是模拟器和HAXM加速驱动
                    》安装完成后，在Android Studio的欢迎界面中选择 Configure --》SDK Manager。
                        在SDK Platforms窗口中选择Show Package Details
                            然后再Android 6.0(Marshmallow)中勾选
                                Google APIs
                                Android SDK Platform 23
                                Intel x86 Atom System Image
                                Intel x86 Atom_64 System Image
                                Google APIs Intel x86 Atom_64 System Image

                        》在SDK Tools窗口中选择Show Package Details
                            然后再Android SDK Build Tools中勾选Android SDK Build-Tools 23.0.1 -- 必须包含有这个版本。如果其他
                            插件需要其他版本，你可以同时安装其他多个版本。然后勾选底部的Android Support Repository。

                ANDROID_HOME环境变量：
                    确保该环境变量指向了android的SDK路径(新建中配置)

            推荐安装的工具
                Gradle Daemon
                    开启Gradle Daemon可以极大地提升java代码的增量编译速度
                    (if not exist "%USERPROFILE%/.gradle" mkdir "%USERPROFILE%/.gradle") && (echo org.gradle.daemon=true >> "%USERPROFILE%/.gradle/gradle.properties")

                    将Android SDK的Tools目录添加到PATH变量中
                        你可以把Android SDK的tools和platform-tools目录添加到PATH变量中，以便在终端中运行一些Android工具，例如android avd或是adb logcat等。

                Git
                    choco install git
                    注意勾选"Run Git from Windows Command Prompt"，这样才会把git命令添加到PATH环境变量中。

                Genymotion -- https://www.genymotion.com/
                    比起Android Studio自带的原装模拟器，Genymotion是一个性能更好的选择，但它只对个人用户免费。

                    Genymotion需要依赖VirtualBox虚拟机，下载选项中提供了包含VirtualBox和不包含的选项。
                    创建一个新模拟器并启动
                    启动React Native应用后，可以按下F1来打开开发者菜单。

                Visual Studio Emulator for Android
                    是利用Hyper-v技术进行硬件加速的免费android模拟器，也是Android Studio自带的原装模拟器之外的一个很好的选择。
                    而且你并不需要安装Visual Studio。在用于React Native开发前，你需要先在注册表中进行一些修改

                        打开运行命令（按下Windows+R键）
                        输入regedit.exe然后回车
                        在注册表编辑器中找到HKEY_LOCAL_MACHINE\SOFTWARE\Wow6432Node\Android SDK Tools条目
                        右键点击Android SDK Tools，选择新建 > 字符串值
                        名称设为Path
                        双击Path，将其值设为你的Android SDK的路径。（例如C:\Program Files\Android\sdk）
            测试安装
                react-native init myProject
                cd myProject
                react-native run-android
                提示：你可以使用--version参数创建指定版本的项目。例如react-native init MyApp --version 0.44.3。注意版本号必须精确到两个小数点。

            修改项目
                使用你喜欢的文本编辑器打开App.js并随便改上几行
                按两下R键，或是用Menu键（通常是F2，在Genymotion模拟器中是⌘+M）打开开发者菜单，然后选择 Reload JS 就可以看到你的最新修改。
                在终端下运行adb logcat *:S ReactNative:V ReactNativeJS:V可以看到你的应用的日志。
      》iOS 不支持
    1.2 Linux
      》Android
        必须软件
            Node
            Yarn、React Native的命令行工具（react-native-cli）
                npm install -g yarn react-native-cli
                yarn config set registry https://registry.npm.taobao.org --global
                yarn config set disturl https://npm.taobao.org/dist --global
            Android Studio
                ANDROID_HOME环境变量
                    具体的做法是把下面的命令加入到~/.bashrc、~/.bash_profile文件中。如果你使用的是其他的shell，则选择对应的配置文件:
                    export ANDROID_HOME=~/Library/Android/sdk
                    然后使用下列命令使其立即生效（否则重启后才生效）：
                    source ~/.bash_profile
                    可以使用echo $ANDROID_HOME检查此变量是否已正确设置。
        推荐工具
            Watchman
                是Facebook提供的监视文件系统变更的工具，安装此工具可以提高开发时的性能（packager可以快速捕捉文件的变化从而实现实时刷新）。
                安装watchman还可以避免node的一个与文件监视有关的bug。

                在终端输入一下命令来编译并安装watchman:
                    git clone https://github.com/facebook/watchman.git
                    cd watchman
                    git checkout v4.5.0  # 这是本文发布时的最新版本，请自行选择更新的版本
                    ./autogen.sh
                    ./configure
                    make
                    sudo make install
            Flow
                是一个静态的js类型检测工具。你在很多示例中看到的奇奇怪怪的冒号问号，以及方法参数中像类型一样的写法，
                都是属于这个flow工具的语法。这一语法并不属于ES标准，只是Facebook自家的代码规范。
                所以新手可以直接跳过（即不需要安装这一工具，也不建议去费力学习flow相关语法）。
                npm install -g flow-bin
            Gradle Daemon
                开启Gradle Daemon可以极大地提升java代码的增量编译速度。
                touch ~/.gradle/gradle.properties && echo "org.gradle.daemon=true" >> ~/.gradle/gradle.properties
            Android模拟器加速器
                如果你的系统支持KVM，那就应该安装Intel的Android模拟器加速器。
            将Android SDK的Tools目录添加到PATH变量中
                你可以把Android SDK的tools和platform-tools目录添加到PATH变量中，以便在终端中运行一些Android工具，例如android avd或是adb logcat等。
                在~/.bashrc或是~/.bash_profile文件中添加：
                # 你的具体路径可能有所不同，请自行确认。
                PATH="~/Android/Sdk/tools:~/Android/Sdk/platform-tools:${PATH}"
                export PATH
            Git
                sudo apt-get install git-all
            Nuclide
                Nuclide（此链接需要科学上网）是由Facebook提供的基于atom的集成开发环境，可用于编写、运行和 调试React Native应用。
                我们更推荐使用WebStorm或Sublime Text来编写React Native应用。
            Genymotion
                比起Android Studio自带的原装模拟器，Genymotion是一个性能更好的选择，但它只对个人用户免费。

                下载和安装Genymotion（genymotion需要依赖VirtualBox虚拟机，下载选项中提供了包含VirtualBox和不包含的选项，请按需选择）。
                打开Genymotion。如果你还没有安装VirtualBox，则此时会提示你安装。
                创建一个新模拟器并启动。
                启动React Native应用后，可以按下F1来打开开发者菜单。
        测试安装
            react-native init AwesomeProject
            cd AwesomeProject
            react-native run-android
      》iOS
        不支持
    1.3 macOS
        》Android
            必须软件
                Homebrew -- Mac系统的包管理器，用于安装Nodejs和一些其他必须的工具软件
                    /usr/bin/ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)"
                    注意：在Max OS X10.11版本中homebrew在安装软件时可能会碰到/usr/local目录不可写的权限问题。可以使用下面的命令修复：
                        sudo chown -R `whoami` /usr/local
                Node
                    brew install node
                    npm config set registry https://registry.npm.taobao.org --global
                    npm config set disturl https://npm.taobao.org/dist --global
                Yarn、React Native的命令行工具（react-native-cli）
                    npm install -g yarn react-native-cli
                    yarn config set registry https://registry.npm.taobao.org --global
                    yarn config set disturl https://npm.taobao.org/dist --global

                    如果你看到EACCES: permission denied这样的权限报错，那么请参照上文的homebrew译注，修复/usr/local目录的所有权：
                    sudo chown -R `whoami` /usr/local
                Android Studio
                    ANDROID_HOME环境变量
                        确保ANDROID_HOME环境变量正确地指向了你安装的Android SDK的路径。具体的做法是把下面的命令加入到~/.bash_profile文件中：
                        (译注：~表示用户目录，即/Users/你的用户名/，而小数点开头的文件在Finder中是隐藏的，并且这个文件有可能并不存在。请在
                        终端下使用vi ~/.bash_profile命令创建或编辑。）。
                        如果你的命令行不是bash，而是例如zsh等其他，请使用对应的配置文件。
                        export ANDROID_HOME=~/Library/Android/sdk

                        然后使用下列命令使其立即生效（否则重启后才生效）：
                        source ~/.bash_profile
                        可以使用echo $ANDROID_HOME检查此变量是否已正确设置。
            推荐安装工具
                Watchman
                    Watchman是由Facebook提供的监视文件系统变更的工具。安装此工具可以提高开发时的性能（packager可以快速捕捉文件的变化从而实现实时刷新）。译注：此工具官方虽然是推荐安装，
                    但在实践中，我们认为此工具是必须安装，否则可能无法正常开发。
                    brew install watchman
                Flow
                    Flow是一个静态的JS类型检查工具。译注：你在很多示例中看到的奇奇怪怪的冒号问号，以及方法参数中像类型一样的写法，都是属于这个flow工具的语法。这一语法并不属于ES标准，只是Facebook自家的代码规范。
                    所以新手可以直接跳过（即不需要安装这一工具，也不建议去费力学习flow相关语法）。
                    brew install flow
                将Android SDK的Tools目录添加到PATH变量中
                    你可以把Android SDK的tools和platform-tools目录添加到PATH变量中，以便在终端中运行一些Android工具，例如android avd或是adb logcat等。具体做法仍然是在~/.bash_profile中添加：
                    export PATH=$PATH:$ANDROID_HOME/tools:$ANDROID_HOME/platform-tools
                Git
                    brew install git
                Nuclide
                Genymotion
                Gradle Daemon
                    touch ~/.gradle/gradle.properties && echo "org.gradle.daemon=true" >> ~/.gradle/gradle.properties
            测试安装
                react-native init AwesomeProject
                cd AwesomeProject
                react-native run-android
        》iOS
            必须软件
                Homebrew
                    /usr/bin/ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)"
                Node
                    brew install node
                    npm config set registry https://registry.npm.taobao.org --global
                    npm config set disturl https://npm.taobao.org/dist --global
                Yarn、React Native的命令行工具（react-native-cli）
                    npm install -g yarn react-native-cli
                    yarn config set registry https://registry.npm.taobao.org --global
                    yarn config set disturl https://npm.taobao.org/dist --global
                Xcode
                    React Native目前需要Xcode 8.0 或更高版本。你可以通过App Store或是到Apple开发者官网上下载。这一步骤会同时安装Xcode IDE和Xcode的命令行工具。
                    虽然一般来说命令行工具都是默认安装了，但你最好还是启动Xcode，并在Xcode | Preferences | Locations菜单中检查一下是否装有某个版本的Command Line Tools。Xcode的命令行工具中也包含一些必须的工具，比如git等。
            推荐安装工具 -- 同上
2.Hello World
    React Native的基础组件是原生组件而非web组件。
    import React from 'react'
    import {Text} from 'react-native'
    class HelloWorldApp extends React.Component{
        render(){
            return <Text>Hello world !</Text>
        }
    }
    注意：React Native内置了对ES2015标准的支持，无需担心兼容问题。
3.Props属性
    大多数组件在创建时就可以使用各种参数来进行定制。用于定制的这些参数就称为props属性。
    如下面的source以及style：
    import React from 'react'
    import {AppRegistry,Image} from 'react-native'
    class Bananas extends React.Component{
        render(){
            let pic = {
                uri:'https://upload.wikimedia.org/wikipedia/commons/d/de/Bananavarieties.jpg'
            }

            return (
                <Image source={pic} style={ {width:193,height:110} }/>
            );
        }
    }
    AppRegistry.registerComponent('Bananas',() => Bananas);
    注意：iOS上http的问题：https://segmentfault.com/a/1190000002933776

    自定义的组件也可以使用props。通过在不同场景使用不同的属性定制，可以尽量提高自定义组件的复用范畴。
    import React from 'react'
    import {AppRegistry,Text,View} from 'react-native'
    class Greeting extends React.Component{
        render(){
            return (
                <Text>Hello {this.props.name}</Text>
            );
        }
    }

    class LotsOfGreetings extends React.Component{
        render(){
            return (
                //View组件常常用作其他组件的容器，来帮助控制布局和样式
                <View style={ {alignItems:'center'} }>
                    <Greeting name='Rexxar'/>
                </View>
            );
        }
    }
    AppRegistry.registerComponent('LotsOfGreetings',() => LotsOfGreetings);
4.State状态
    使用两种数据来控制一个组件：props和state。props是在父组件中指定，而且一经指定，在被指定的组件的生命周期中则不再改变。
    对于需要改变的数据我们需要使用state。
    import React from 'react'
    import {AppRegistry,Text,View} from 'react-native'
    class Blink extends Component{
        constructor(props){
            super(props);
            this.state = {showText:true}

            setInterval( () => {
                this.setState(previousState => {
                    return {showText:!previousState.showText}
                })
            },1000);
        }

        render(){
            let display = this.state.showText ? this.props.text : '';

            return (
                <Text>{display}</Text>
            );
        }
    }
    class BlinkApp extends React.Component{
        render(){
            return (
                <View>
                    <Blink text='I love to blink'/>
                </View>
            );
        }
    }
    AppRegistry.registerComponent('BlinkApp',() => BlinkApp);
5. 样式
    在React Native中，你并不需要学习什么特殊的语法来定义样式。我们仍然是使用JS来写样式。所有的核心组件都接受名为style的
    属性，这些样式名基本上是遵循web上的css的命名，只是按照JS的语法要求使用驼峰命名法，如将background-color改为backgroundColor。

    style属性可以是一个普通的js对象。也可以传入一个数组--在数组中位置居后的样式对象比居前的优先级更高，这样可以间接实现样式的继承。

    在实际开发中组件的样式会越来越复杂，建议使用StyleSheet.create来集中定义组件的样式。
    import React from 'react'
    import {AppRegistry,StyleSheet,Text,View} from 'react-native'

    class LotsOfStyles extends React.Component{
        render(){
            return (
                <View>
                    <Text style={styles.red}>just red</Text>
                    <Text style={styles.bigblue}>just bigblue</Text>
                    <Text style={[styles.bigblue, styles.red]}>bigblue, then red</Text>
                    <Text style={[styles.red, styles.bigblue]}>red, then bigblue</Text>
                </View>
            );
        }
    }

    const styles = StyleSheet.create({
        bigblue:{
            color:'blue',
            fontWeight:'bold',
            fontSize:30
        },
        red:{
            color:'red'
        }
    });
    AppRegistry.registerComponent('LotsOfStyles',() => LotsOfStyles);
6.高度和宽度
    组件的高度和宽度决定了其在屏幕上显示的尺寸。
    指定宽高：
        最简单的给组件设定尺寸的方式就是在样式中指定固定的width和height。React Native中的尺寸都是无单位的，表示的是与
        设备像素密度无关的逻辑像素点。
        import React from 'react'
        import {AppRegistry,View} from 'react-native'
        class FixedDimensionsBasics extends Component {
            render(){
                return (
                    <View>
                        <View style={{width: 50, height: 50, backgroundColor: 'powderblue'}} />
                    </View>
                );
            }
        }
        //注册应用registerComponent后才能正确渲染，只把应用作为一个整体注册一次，而不是每个组件/模块都注册
        AppRegistry.registerComponent('AwesomeProject', () => FixedDimensionsBasics);
        //上面给组件设置尺寸是一种常见的模式，比如要求在不同尺寸的屏幕上都显示成一样的大小。
    弹性Flex宽高：
        在组件样式中使用flex可以使其在可利用的空间中动态地扩展或收缩，一般而言我们会使用flex:1来指定某个组件扩展以撑满
        所有剩余的空间，如果有多个并列的子组件使用了flex:1,则这些子组件会评分父容器中剩余的空间。如果这些并列的子组件的
        flex值不一样，则谁的值更大，谁占据剩余空间的比例就更大（即占据剩余空间的比等于并列组件间flex值的比）。

        组件能够撑满剩余空间的前提是其父容器的尺寸不为零。如果父容器即没有固定的width和height也没有设定flex，则父容器的尺寸为零。
        其子组件如果使用flex也是无法显示的。
        import React, { Component } from 'react';
        import { AppRegistry, View } from 'react-native';

        class FlexDimensionsBasics extends Component {
          render() {
            return (
              <View style={{flex: 1}}>
                <View style={{flex: 1, backgroundColor: 'powderblue'}} />
                <View style={{flex: 2, backgroundColor: 'skyblue'}} />
                <View style={{flex: 3, backgroundColor: 'steelblue'}} />
              </View>
            );
          }
        };

        AppRegistry.registerComponent('AwesomeProject', () => FlexDimensionsBasics);
7.使用Flexbox布局
    在React Native中使用flexbox规则来指定某个组件的子元素的布局。Flexbox可以在不同屏幕尺寸上提供一致的布局结构。
    一般来说使用flexDirection、alignItems、justifyContent三个样式属性就已经满足大多数布局需求。

    React Native中的Flexbox的工作原理和web上的CSS基本一致，当然也存在少许差异。首先是默认值不同：
    flexDirection的默认值是column而不是row，而flex也只能指定一个数字值。

    》Flex Direction
        在组件的style中指定flexDirection可以决定布局的主轴。子元素是应该沿着水平轴(row)方向排列还是沿着竖直轴(column)方向
        排列。默认是竖直轴(column)方向。
        import React from 'react'
        import {AppRegistry,View} from 'react-native'
        class FlexDirectionBasics extends React.Component{
            render(){
                return (
                    <View style={ {flex:1,flexDirection:"row"} }>
                        <View style={{width: 50, height: 50, backgroundColor: 'powderblue'}} />
                        <View style={{width: 50, height: 50, backgroundColor: 'skyblue'}} />
                        <View style={{width: 50, height: 50, backgroundColor: 'steelblue'}} />
                    </View>
                );
            }
        }
        AppRegistry.registerComponent('AwesomeProject', () => FlexDirectionBasics);
    》Justify Content
        在组件的style中指定justifyContent可以决定其子元素沿着主轴的排列方式。子元素是应该靠近主轴的起始端还是末尾段，亦或者均匀分布
        对应的值：flex-start、center、flex-end、space-around以及space-between。
        import React, { Component } from 'react';
        import { AppRegistry, View } from 'react-native';

        class JustifyContentBasics extends Component {
          render() {
            return (
              // 尝试把`justifyContent`改为`center`看看
              // 尝试把`flexDirection`改为`row`看看
              <View style={{
                flex: 1,
                flexDirection: 'column',
                justifyContent: 'space-between',
              }}>
                <View style={{width: 50, height: 50, backgroundColor: 'powderblue'}} />
                <View style={{width: 50, height: 50, backgroundColor: 'skyblue'}} />
                <View style={{width: 50, height: 50, backgroundColor: 'steelblue'}} />
              </View>
            );
          }
        };

        AppRegistry.registerComponent('AwesomeProject', () => JustifyContentBasics);
    》Align Items
        在组件的style中指定alignItems可以决定其子元素沿着次轴(与主轴垂直的轴，如主轴方向是row 则次轴方向为column)的排列方式。
        子元素是应该靠近次轴的起始端还是末尾段亦或者均匀分布：flex-start、center、flex-end以及stretch。
        注意：要是stretch选项生效的话，子元素在次轴方向上不能有固定的尺寸。
        import React, { Component } from 'react';
        import { AppRegistry, View } from 'react-native';

        class AlignItemsBasics extends Component {
          render() {
            return (
              // 尝试把`alignItems`改为`flex-start`看看
              // 尝试把`justifyContent`改为`flex-end`看看
              // 尝试把`flexDirection`改为`row`看看
              <View style={{
                flex: 1,
                flexDirection: 'column',
                justifyContent: 'center',
                alignItems: 'center',
              }}>
                <View style={{ height: 50, backgroundColor: 'powderblue'}} />
                <View style={{ height: 50, backgroundColor: 'skyblue'}} />
                <View style={{ height: 50, backgroundColor: 'steelblue'}} />
              </View>
            );
          }
        };

        AppRegistry.registerComponent('AwesomeProject', () => AlignItemsBasics);
8.处理文本输入
    TextInput是一个允许用户输入文本的基础组件，它有一个名为onChangeText的属性，此属性接受一个函数，而此函数会在文本变化时
    被调用。另外还有一个名为onSubmitEditing的属性，会在文本被提交时(用户按下软键盘上的提交键)调用。
    //如实时翻译单词
    import React from 'react'
    import {AppRegistry,Text,TextInput,View} from 'react-native';

    class PizzaTranslator extends React.Component{
        constructor(props){
            super(props);
            this.state = {text:''}
        }

        render(){
            return (
                <View style={{padding:10}}>
                    <TextInput
                        style={{height:40}}
                        placeholder='Type here to translate!'
                        onChangeText={
                            text => this.State({text})
                        }
                    />
                    <Text style={ {padding:10,fontSize:42} }>
                        {this.state.text.split(' ').map(
                            word => word && '🍕'
                        ).join(' ')}
                    </Text>
                </View>
            );
        }
    }
    AppRegistry.registerComponent('PizzaTranslator', () => PizzaTranslator);
9.如何使用滚动视图
    ScrollView是一个通用的可滚动的容器，你可以在其中放入多个组件和视图，而且这些组件并不需要是同类型的。ScrollView不仅
    可以垂直滚动，还能水平滚动，通过horizontal属性来设置。
    //创建一个垂直滚动的ScrollView
    import React, { Component } from 'react';
    import{ AppRegistry, ScrollView, Image, Text, View } from 'react-native'

    class IScrolledDownAndWhatHappenedNextShockedMe extends Component {
      render() {
          return(
            <ScrollView>
              <Text style={{fontSize:96}}>Scroll me plz</Text>
              <Image source={require('./img/favicon.png')} />
              <Image source={require('./img/favicon.png')} />
              <Image source={require('./img/favicon.png')} />
              <Image source={require('./img/favicon.png')} />
              <Image source={require('./img/favicon.png')} />
              <Text style={{fontSize:96}}>If you like</Text>
              <Image source={require('./img/favicon.png')} />
              <Image source={require('./img/favicon.png')} />
              <Image source={require('./img/favicon.png')} />
              <Image source={require('./img/favicon.png')} />
              <Image source={require('./img/favicon.png')} />
              <Text style={{fontSize:96}}>Scrolling down</Text>
              <Image source={require('./img/favicon.png')} />
              <Image source={require('./img/favicon.png')} />
              <Image source={require('./img/favicon.png')} />
              <Image source={require('./img/favicon.png')} />
              <Image source={require('./img/favicon.png')} />
              <Text style={{fontSize:96}}>What's the best</Text>
              <Image source={require('./img/favicon.png')} />
              <Image source={require('./img/favicon.png')} />
              <Image source={require('./img/favicon.png')} />
              <Image source={require('./img/favicon.png')} />
              <Image source={require('./img/favicon.png')} />
              <Text style={{fontSize:96}}>Framework around?</Text>
              <Image source={require('./img/favicon.png')} />
              <Image source={require('./img/favicon.png')} />
              <Image source={require('./img/favicon.png')} />
              <Image source={require('./img/favicon.png')} />
              <Image source={require('./img/favicon.png')} />
              <Text style={{fontSize:80}}>React Native</Text>
            </ScrollView>
        );
      }
    }
    AppRegistry.registerComponent(
      'IScrolledDownAndWhatHappenedNextShockedMe',
      () => IScrolledDownAndWhatHappenedNextShockedMe);

    ScrollView适合用来显示数量不多的滚动元素。放置在ScrollView中的所有组件都会被渲染，哪怕有些组件因为内容太长被挤出了
    屏幕外。如果你需要实现较长的滚动列表，那么应该使用功能差不多但性能更好的ListView组件。
10. 如何使用长列表
    React Native提供了几个适用于展示长列表数据的组件，一般而言我们会选用FlatList或SectionList。

    FlatList组件用于显示一个垂直的滚动列表，其中的元素之间结构近似而仅数据不同。

    FlatList更适用于长列表数据且元素个数可以增删和ScrollView不同的是FlatList并不立即渲染所有元素，而是优先渲染屏幕上可见的元素。

    FlatList组件必须的两个属性是data和renderItem。data是列表的数据元素，而renderItem是从数据源中逐个解析数据然后返回一个设定好
    格式的组件来渲染。
    //案例
    import React from 'react';
    import {AppRegistry,FlatList,StyleSheet,Text,View} from 'react-native'
    export default class FlatListBasics extends React.Component{
        render(){
            return (
                <View style={styles.container}>
                    <FlatList
                        data={[
                            {key: 'Devin'},
                            {key: 'Jackson'},
                            {key: 'James'},
                            {key: 'Joel'},
                            {key: 'John'},
                            {key: 'Jillian'},
                            {key: 'Jimmy'},
                            {key: 'Julie'},
                        ]}
                        renderItem = { {item} => <Text style={ styles.item }>{item.key}</Text>}
                    />
                </View>
            );
        }
    }
    const styles = StyleSheet.create({
      container: {
       flex: 1,
       paddingTop: 22
      },
      item: {
        padding: 10,
        fontSize: 18,
        height: 44,
      },
    })

    AppRegistry.registerComponent('AwesomeProject', () => FlatListBasics);

    //SectionList
    import React from 'react'
    import {AppRegistry,SectionList,StyleSheet,Text,View} from 'react-native'
    export default class SectionListBasics extends React.Component{
        render(){
            return (
                <View style={styles.container}>
                    <SectionList
                        sections={
                          [
                            {title: 'D', data: ['Devin']},
                            {title: 'J', data: ['Jackson', 'James', 'Jillian', 'Jimmy', 'Joel', 'John', 'Julie']},
                          ]
                        }
                        renderItem = { {item}=> <Text style={styles.item}>{item}</Text>}
                        renderSectionHeader={ {section} => <Text style={styles.sectionHeader}>{section.title}</Text>}
                    />
                </View>
            );
        }
    }
    const styles = StyleSheet.create({
      container: {
       flex: 1,
       paddingTop: 22
      },
      sectionHeader: {
        paddingTop: 2,
        paddingLeft: 10,
        paddingRight: 10,
        paddingBottom: 2,
        fontSize: 14,
        fontWeight: 'bold',
        backgroundColor: 'rgba(247,247,247,1.0)',
      },
      item: {
        padding: 10,
        fontSize: 18,
        height: 44,
      },
    })

    AppRegistry.registerComponent('AwesomeProject', () => SectionListBasics);
11.网络
    使用Fetch
        React Native提供了和web标准一致的Fetch API，用于满足开发者访问网络的需求。
        发起网络请求：
            fetch('https://mywebsite.com/mydata.json')
            fetch的可选第二个参数：
            fetch('https://mywebsite.com/endpoint/', {
              method: 'POST',
              headers: {
                'Accept': 'application/json',
                'Content-Type': 'application/json',
              },
              body: JSON.stringify({
                firstParam: 'yourValue',
                secondParam: 'yourOtherValue',
              })
            })
            //如果服务器无法识别上面POST的数据格式，可以使用传统的form格式
            fetch('https://mywebsite.com/endpoint/', {
              method: 'POST',
              headers: {
                'Content-Type': 'application/x-www-form-urlencoded',
              },
              body: 'key1=value1&key2=value2'
            })
        处理服务器的响应数据：
            getMoviesFromApiAsync() {
                return fetch('https://facebook.github.io/react-native/movies.json')
                  .then((response) => response.json())
                  .then((responseJson) => {
                    return responseJson.movies;
                  })
                  .catch((error) => {
                    console.error(error);
                  });
              }
              //使用ES7的语法 async /await
              async getMoviesFromApi(){
                try{
                    let response = await fetch('https://facebook.github.io/react-native/movies.json');
                    let responseJSON = await response.json();

                    return responseJSON.movies;
                }catch(error){
                    console.error(error)
                }
              }
            注意：iOS默认会阻止所有非https得请求。https://segmentfault.com/a/1190000002933776
    使用其他的网络库
        React Native已经内置了ajax(XMLHttpRequest)。一些基于ajax封装的第三方库也是可以使用的如：frisbee或axios等。
        但注意不能不使用jquery，因为jquery中还使用了很多浏览器才有而RN没有的东西。即不是所有web中的
        ajax库都可以直接使用。
        var request = new XMLHttpRequest();
        request.onreadystatechange = (e) => {
          if (request.readyState !== 4) {
            return;
          }

          if (request.status === 200) {
            console.log('success', request.responseText);
          } else {
            console.warn('error');
          }
        };

        request.open('GET', 'https://mywebsite.com/endpoint/');
        request.send();
        注意：安全机制与网页环境有所不同：在应用中你可以访问任何网站没有跨域的限制。
    WebSocket支持
        React Native还支持WebSocket，这种协议可以在单个TCP连接上提供全双工的通信信道。
        var ws = new WebSocket('ws://host.com/path');

        ws.onopen = () => {
          // 打开一个连接

          ws.send('something'); // 发送一个消息
        };

        ws.onmessage = (e) => {
          // 接收到了一个消息
          console.log(e.data);
        };

        ws.onerror = (e) => {
          // 发生了一个错误
          console.log(e.message);
        };

        ws.onclose = (e) => {
          // 连接被关闭了
          console.log(e.code, e.reason);
        };
12.其他参考资源
    常用的第三方库：
        https://github.com/reactnativecn/react-native-guide
        https://github.com/jondot/awesome-react-native
    示例应用
        https://github.com/fbsamples/f8app
        https://f8-app.liaohuqiu.net/#content
    开发工具
        Nuclide
        Lgnite
        CodePush(Pushy) -- 热更新
        Exponent
        Deco
13. 集成到现有原生应用
    》Android
        把React Native组件集成到Android应用中的步骤：
        //了解要集成的React Native组件
        //在Android项目根目录中使用npm安装react-native
        //创建js文件编写React Native组件的js代码
        //在build.gradle文件中添加com.facebook.react:react-native:+，
          以及一个指向node_nodules/目录中的react-native预编译库的maven路径
        //创建一个React Native专属的Activity，在其中再创建ReactRootView
        //启动React Native的Packager服务，运行应用。
        //根据需要添加更多React Native的组件。
        //在真机上运行、调试。
        //打包。

        开发环境准备：
        1.安装React Native在安卓平台上所需依赖
        2.设置项目目录结构
            在其中创建一个/android子目录，把现有的Android项目拷贝到该目录中
        3.安装js依赖包
            创建package.json
            {
              "name": "MyReactNativeApp",
              "version": "0.0.1",
              "private": true,
              "scripts": {
                //启动packager服务的命令
                "start": "node node_modules/react-native/local-cli/cli.js start"
              },
              "dependencies": {
                //react native对react版本有要求 注意安装过程的错误提示
                "react": "16.0.0-alpha.6",
                "react-native": "0.44.3"
              }
            }
            //执行npm install
        把React Native添加到你的应用中
        1.配置maven
            在app中的build.gradle文件中添加React Native依赖：
            dependencies {
                 ...
                 //如果想要指定特定的React Native版本，可以用具体的版本号替换+ 前提是npm里面下载了这个版本
                 compile "com.facebook.react:react-native:+" // From node_modules.
             }

             在项目的build.gradle文件中为React Native添加一个maven依赖的入口，必须写在'allprojects'代码块中：
             allprojects {
                 repositories {
                     ...
                     maven {
                         // All of React Native (JS, Android binaries) is installed from npm
                         //确保依赖路径的正确以免在 Android Studio 运行Gradle同步构建时抛出 “Failed to resolve: com.facebook.react:react-native:0.x.x" 异常。
                         url "$rootDir/../node_modules/react-native/android"
                     }
                 }
                 ...
             }
        配置权限
            接着再AndroidManifest.xml清单文件中声明网络权限：
            <uses-permission android:name="android.permission.INTERNET" />
            如果需要访问DevSettingsActivity 界面(即开发者菜单)，则还需要再AndroidManifest.xml中声明：
            //开发者菜单一般仅用于在开发时从Packager服务器刷新JavaScript代码，所以在正式发布时你可以去掉这一权限。
            <activity android:name="com.facebook.react.devsupport.DevSettingsActivity" />
        代码集成
            1.React Native组件
                //创建一个index.js文件(入口文件) 注意在0.49版本之前是index.android.js文件

                //在index.js中添加自己的组件
                import React from 'react';
                import {
                  AppRegistry,
                  StyleSheet,
                  Text,
                  View
                } from 'react-native';

                class HelloWorld extends React.Component {
                  render() {
                    return (
                      <View style={styles.container}>
                        <Text style={styles.hello}>Hello, World</Text>
                      </View>
                    )
                  }
                }
                var styles = StyleSheet.create({
                  container: {
                    flex: 1,
                    justifyContent: 'center',
                  },
                  hello: {
                    fontSize: 20,
                    textAlign: 'center',
                    margin: 10,
                  },
                });

                AppRegistry.registerComponent('MyReactNativeApp', () => HelloWorld);

                //配置权限以便于开发中的红屏错误能正确显示
                如果你的应用会运行在Android6.0(API level23)或更高版本，请确保在开发版本中有打开悬浮窗(overlay)权限。
                你可以在代码中使用Settings.canDrawOverlays(this);来检测。之所以需要这个权限，是因为我们会把开发中的报错
                显示在悬浮窗中(仅在开发阶段需要)。在Android 6.0（API level 23）中用户需要手动同意授权。具体请求授权的做法是
                在onCreate()中添加如下代码。其中OVERLAY_PERMISSION_REQ_CODE是用于回传授权结果的字段。
                if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
                    if (!Settings.canDrawOverlays(this)) {
                        Intent intent = new Intent(Settings.ACTION_MANAGE_OVERLAY_PERMISSION,
                                                   Uri.parse("package:" + getPackageName()));
                        startActivityForResult(intent, OVERLAY_PERMISSION_REQ_CODE);
                    }
                }

                最终onActivityResult()必须被覆盖用于处理用户的授权情况
                @Override
                protected void onActivityResult(int requestCode, int resultCode, Intent data) {
                    if (requestCode == OVERLAY_PERMISSION_REQ_CODE) {
                        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
                            if (!Settings.canDrawOverlays(this)) {
                                // SYSTEM_ALERT_WINDOW permission not granted...
                            }
                        }
                    }
                }
            2.ReactRootView
                还需要添加一些原生代码来启动React Native的运行时环境并让它开始渲染。首先需要在一个Activity中创建一个
                ReactRootView对象，然后再这个对象中启动React Native应用并将它设为界面的主视图
                如果你想在安卓5.0以下的系统上运行，请用 com.android.support:appcompat 包中的 AppCompatActivity 代替 Activity 。
                public class MyReactActivity extends Activity implements DefaultHardwareBackBtnHandler {
                    private ReactRootView mReactRootView;
                    private ReactInstanceManager mReactInstanceManager;

                    @Override
                    protected void onCreate(Bundle savedInstanceState) {
                        super.onCreate(savedInstanceState);

                        mReactRootView = new ReactRootView(this);
                        mReactInstanceManager = ReactInstanceManager.builder()
                                .setApplication(getApplication())
                                .setBundleAssetName("index.android.bundle")
                                .setJSMainModuleName("index.android")
                                .addPackage(new MainReactPackage())
                                .setUseDeveloperSupport(BuildConfig.DEBUG)
                                .setInitialLifecycleState(LifecycleState.RESUMED)
                                .build();

                        // 注意这里的MyReactNativeApp必须对应“index.android.js”中的
                        // “AppRegistry.registerComponent()”的第一个参数
                        mReactRootView.startReactApplication(mReactInstanceManager, "MyReactNativeApp", null);

                        setContentView(mReactRootView);
                    }

                    @Override
                    public void invokeDefaultOnBackPressed() {
                        super.onBackPressed();
                    }
                }

                //我们需要把MyReactActivity的主题设定为Theme.AppCompat.Light.NoActionBar，因为里面有许多组件都使用了这个主题。
                <activity
                   android:name=".MyReactActivity"
                   android:label="@string/app_name"
                   android:theme="@style/Theme.AppCompat.Light.NoActionBar">
                 </activity>

                具体查看文档
    》Swift
    》Objective-C
14.使用导航器跳转页面
    React Native中现有的几个导航组件。如果你刚开始接触那么直接选择React Navigation 。如果你只针对iOS平台开发，并且想和系统原生
    外观一致，那么可以选择NavigatorIOS。你还可能在很多地方听过Navigator，这个老组件会逐步被React Navigation替代。但是它经历过
    长期的实践，较为稳定。过去还有一个实验性的导航器组件NavigationExperimental，这个组件已经完全弃用。
    注意：
        从.44版本开始，Navigator被从react native的核心组件库中剥离到react-native-deprecated-custom-components的单独模块中。如果
        你需要使用Navigator则需要先yarn add react-native-deprecated-custom-components安装，然后从这个模块中import，即import {
        Navigator } from 'react-native-deprecated-custom-components'
    》React Navigation
        社区今后主推的方案是一个单独的导航库react-navigation，它的使用十分简单。
        先安装此库：yarn add react-navigation

        案例：
        import React,{Component} from 'react'
        import {View,Text,Button} from 'react-native'
        import {StackNavigator} from 'react-navigation'

        /**
         * 其中每个screen组件都可以单独设置导航头选项 如：导航头的标题 还可以使用navigation属性中的方法跳转到别的页面
         */

        class MainComponent extends React.Component {
            //设置导航头选项
            static navigationOptions = {
                title: '主页',
            };

            render() {
                const { navigate } = this.props.navigation;
                return (
                    <View>
                        <Text>主页</Text>
                        <Button
                            title="Go to Jane's profile"
                            //跳转到其他页面
                            onPress={() => navigate('Profile', { name: 'Jane' }) }
                        />
                    </View>
                );
            }
        }

        class ProfileComponent extends React.Component {
            static navigationOptions = {
                title: '个人页',
            };
            render() {
                const { navigate } = this.props.navigation;
                return <Text>profile</Text>
            }
        }


        const App = StackNavigator({
            Main:{screen:MainComponent},
            Profile:{screen:ProfileComponent}
        });

        class NavigationTest extends Component{

            render(){

                return <App/>
            }
        }

        export default NavigationTest
        //React Navigation的路由写法使其非常容易扩展导航逻辑，或者整合到redux中。由于路由可以嵌套使用，因而开发者可以根据不同页面编写不同
        //的导航逻辑且彼此互不影响。

        //React Navigation中的视图是原生组件，同时用到了运行在原生线程上的Animated动画库，因此性能表现十分流畅。此外其动画形式和手势都非常便于
        //定制。

        》其文档 https://reactnavigation.org/docs/intro/
            》介绍
                React Navigation源自于React Native社区，基于js的可扩展且易于使用的导航解决方案。
                React Navigation是来自于Facebook ，Expo和React社区的开发者之间的合作结果：它取代并改进了生态系统中的多个导航库，包括
                Ex-Navigation,React Native的Navigator和NavigationExperimental组件。
            》快速入门
                》安装
                    npm: npm install --save react-navigation
                    yarn:yarn add react-navigation
                》注意
                    要开始使用React Navigation，必须创建一个导航器。React Navigation带有三个默认的导航器。
                    StackNavigator -- 为您的应用程序在每个**新屏幕顶部**的屏幕之间的切换
                    TabNavigator -- 用于设置多个选项卡的屏幕
                    DrawerNavigator -- 用于设置带抽屉导航的屏幕
                》创建一个StackNavigator
                    StackNavigator是最常见的导航形式。
                    案例：
                       import React from 'react'
                       import {View,Text,Button} from 'react-native'
                       import {StackNavigator} from 'react-navigation'

                       /**
                        * 创建每屏视图
                        */
                       const HomeScreen = ({navigation}) => (
                           <View style={{flex:1,alignItems:'center',justifyContent:'center'}}>
                               <Text>Home Screen</Text>
                               {/*从主屏幕导航到详细信息屏幕*/}
                               {/*当你使用导航器注册一个组件时，组件会添加一个道具。这个道具驱动我们如何在不同的屏幕之间移动。navigation.navigate*/}
                               <Button
                                   onPress={ () => navigation.navigate('Detail')}
                                   title="Go to detail"
                               />
                           </View>
                       );

                       const DetailScreen = () => (
                           <View style={{flex:1,alignItems:'center',justifyContent:'center'}}>
                               <Text>Details Screen</Text>
                           </View>
                       );

                       //创建StackNavigator
                       const RootNavigator = StackNavigator({
                           //为每屏添加试图组件
                           Home:{
                               screen:HomeScreen,
                               //添加导航标题
                               navigationOptions:{
                                   headerTitle:'home'
                               }
                           },
                           Detail:{
                               screen:DetailScreen,
                               navigationOptions:{
                                   headerTitle:'Detail'
                               }
                           }
                       });

                       export default RootNavigator
                》创建一个TabNavigator
                    //添加图标 npm install react-native-vector-icons 或yarn add react-native-vector-icons
                    import React from 'react'
                    import {View,Text} from 'react-native'
                    import {TabNavigator} from 'react-navigation'
                    import Ionicons from 'react-native-vector-icons/Ionicons'

                    const HomeScreen = () => (
                        <View style={ {flex:1,alignItems:'center',justifyContent:'center'} }>
                            <Text>Home Screen</Text>
                        </View>
                    );

                    const ProfileScreen = () => (
                        <View style={ {flex:1,alignItems:'center',justifyContent:'center'} }>
                            <Text>Profile Screen</Text>
                        </View>
                    );

                    //创建TabNavigator
                    const RootTabs = TabNavigator({
                        Home:{
                            screen:HomeScreen,
                            navigationOptions:{
                                tabBarLabel:'Home',
                                //添加图标
                                tabBarIcon: ({tintColor,focused}) => (
                                    <Ionicons name={ focused ? 'ios-home' : 'ios-home-outline'} size={26} style={{color:tintColor}}/>
                                )
                            }
                        },
                        Profile:{
                            screen:ProfileScreen,
                            navigationOptions:{
                                tabBarLabel:'Profile',
                                tabBarIcon:({tintColor,focused}) => (
                                    <Ionicons
                                        name={focused ? 'ios-person' : 'ios-person-outline'}
                                        size={26}
                                        style={{color:tintColor}}
                                    />
                                )
                            }
                        }
                    });

                    export default RootTabs
                》DrawerNavigator
                    import React from 'react'
                    import {DrawerNavigator} from 'react-navigation'
                    import {View,Text,Button} from 'react-native'
                    import Ionicons from 'react-native-vector-icons/Ionicons'

                    const HomeScreen = ({navigation}) => (
                        <View style={{flex:1,alignItems:'center',justifyContent:'center'}}>
                            <Text>Home Screen</Text>
                            {/*要打开抽屉，可以从屏幕左边缘向右滑动，也可以用代码实现*/}
                            <Button title="Open Drawer" onPress={() => navigation.navigate('DrawerToggle')}/>
                        </View>
                    );

                    const ProfileScreen = () => (
                        <View style={{flex:1,alignItems:'center',justifyContent:'center'}}>
                            <Text>Profile Screen</Text>
                        </View>
                    );


                    //创建
                    const RootDrawer = DrawerNavigator({
                        Home:{
                            screen:HomeScreen,
                            navigationOptions:{
                                drawerLabel:'主页',
                                drawerIcon: ({tintColor,focused}) => (<Ionicons name={focused ? 'ios-home' : 'ios-home-outline'} size={20} style={{color:tintColor}}/>)
                            }
                        },
                        Profile:{
                            screen:ProfileScreen,
                            navigationOptions:{
                                drawerLabel:'个人',
                                drawerIcon: ({tintColor,focused}) => (<Ionicons name={focused ? 'ios-person' : 'ios-person-outline'} size={20} style={{color:tintColor}}/>)
                            }
                        }
                    });

                    export default RootDrawer
            》Hello Mobile导航
                》设置和安装
                    react-native init SimpleApp
                    cd SimpleApp
                    npm install --save react-navigation
                    react-native run-android || react-native run-ios

                    或
                    create-react-native-app SimpleApp
                    cd SimpleApp
                    npm install --save react-navigation
                    npm start
                》StackNavigation

                》传递参数
                    navigate除了导航功能指定目标外，我们还可以将传递的参数放入其中。
                    onPress={() => navigate('Chat', { user: 'Lucy' })}

                》案例
                    import React from 'react'
                    import {Text,View,Button} from 'react-native'
                    import {StackNavigator} from 'react-navigation'

                    class HomeScreen extends React.Component{
                        static navigationOptions = {
                            title:'Welcome'
                        }

                        render(){
                            const {navigate} = this.props.navigation;

                            return (

                                <View>
                                    <Text>Hello,Navigation!</Text>
                                    {/*传递参数*/}
                                    <Button title="Chat with Lucy" onPress={ () => navigate('Chat',{user:'Lucy'})}/>
                                </View>
                            )
                        }
                    }

                    class ChatScreen extends React.Component{
                        static navigationOptions = {
                            title:'Chat with Lucy'
                        }

                        render(){
                            //获取参数
                            const {params} = this.props.navigation.state;

                            return <View>
                                <Text>Chat with {params.user}</Text>
                            </View>
                        }
                    }

                    export default SimpleApp = StackNavigator({
                        Home:{
                            screen:HomeScreen
                        },
                        Chat:{
                            screen:ChatScreen
                        }
                    });
            》嵌套导航
                在移动应用中常见的是组合各种各样的导航。React Navigation中的路由和导航器是可组合的。这使得可以为应用定义复杂的导航结构。
                //NestNavigationTest -- children component
                import React ,{Component} from 'react'
                import {TabNavigator} from 'react-navigation'
                import {Text,View,Button} from 'react-native'

                class RecentChatsScreen extends Component{

                    render(){
                        const {params} = this.props.navigation.state;

                        return (
                            <View>
                                <Text>List of recent chats,from {params ? params.user : 'default'}</Text>
                                <Button title="Chat with Lucy" onPress={ () => this.props.navigation.navigate('Chat',{user:'Lucy'})}/>
                            </View>
                        );
                    }
                }

                class AllContactsScreen extends Component{

                    render(){
                        return (
                            <View>
                                <Text>List of all contacts</Text>
                                <Button title="to Recent" onPress={ () => this.props.navigation.navigate('Recent',{user:'all'})}/>
                            </View>
                        )
                    }
                }

                const MainScreenNavigator = TabNavigator({
                    Recent:{screen:RecentChatsScreen},
                    All:{screen:AllContactsScreen}
                });

                export default MainScreenNavigator

                //HelloNavigation -- parent component
                import React from 'react'
                import {Text,View,Button} from 'react-native'
                import {StackNavigator} from 'react-navigation'
                import NestNavigationTest from '../NestNavigationTest'

                class HomeScreen extends React.Component{
                    static navigationOptions = {
                        title:'Welcome'
                    }

                    render(){
                        const {navigate} = this.props.navigation;

                        return (

                            //避免导航器无法显示  给容器使用flex:1
                            <View style={{flex:1}}>
                                <Text>Hello,Navigation!</Text>
                                {/*传递参数*/}
                                <Button title="Chat with Lucy" onPress={ () => navigate('Chat',{user:'Lucy'})}/>

                                {/*在组件中嵌套导航器*/}
                                <NestNavigationTest navigation={this.props.navigation}/>
                            </View>
                        )
                    }
                }

                /**
                 * 在组件中嵌套导航器
                 *
                 * 为了把NestNavigationTest的导航链接到导航树上，我们需要把NestNavigationTest的router给HomeScreen的router。
                 * 这使得HomeScreen“导航感知”，即告诉父导航器将导航对象传递下去。由于HomeScreen的router被子组件NestNavigationTest的
                 * router覆盖，这个子组件将接受navigation props。
                 */
                HomeScreen.router = NestNavigationTest.router;

                class ChatScreen extends React.Component{
                    static navigationOptions = {
                        title:'Chat with Lucy'
                    }

                    render(){
                        //获取参数
                        const {params} = this.props.navigation.state;

                        return (
                            <View>
                                <Text>Chat with {params.user}</Text>
                            </View>
                        );
                    }
                }

                const SimpleApp = StackNavigator({
                    Home:{
                        screen:HomeScreen
                    },
                    Chat:{
                        screen:ChatScreen
                    }
                });

                //嵌套导航 -- 将导航器嵌套在屏幕中 该导航器内容将沾满整个屏幕 使用navigate切换视图
                const NestNavigation = StackNavigator({
                    Home:{
                        screen:NestNavigationTest,
                        navigationOptions:{
                            title:'My Chats'
                        }
                    },
                    Chat:{screen:ChatScreen}
                });

                /**
                 * 嵌套导航器 -- 在组件中嵌套导航器
                 *
                 * 有时候需要嵌套包装在组件中的导航器。该导航器只占有屏幕的一部分的情况下非常有用
                 *
                 * 为了将子导航器链接到导航树中，需要父导航器的属性navigation
                 */
                const NestNavigationComponent = StackNavigator({
                    Home:{
                        screen:HomeScreen
                    },
                    Chat:{screen:ChatScreen}
                });
                export default NestNavigationComponent
            》配置 Headers
                配置header仅适用于StackNavigator。

                》设置header title
                    class ChatScreen extends React.Component{
                        static navigationOptions = ({navigation}) => ({
                            title:'Chat with ${navigation.state.params.user}'
                        })
                    }
                》添加一个右边按钮
                    header的导航选项是允许我们添加一个自定义的右按钮的
                    static navigationOptions = {
                        headerRight:<Button title='Info'/>
                    }
                    //导航选项能够被navigation prop定义。
                    //根据route的params的不同来渲染不同的button，并且当button 被点击时执行navigation.setParams。
                    state navigationOptions = ({navigation}) => {
                        const {state,setParams} = navigation;
                        const isInfo = state.params.mode === 'info';
                        const {user} = state.params;

                        return {
                            title: isInfo ? `${user}'s Contact Info'` : `Chat with ${user}`,
                            headerRight:(
                                <Button title={isInfo ? 'Done' : `${user}'s info'`}
                                    onPress = { () => setParams({mode:isInfo ? 'none' : 'info'})}
                                />
                            )
                        }
                    }
                    //现在header就可以和路由state交互了
                》header和屏幕组件的交互
                    有时候，header需要访问屏幕组件的函数或state属性。
                    class EditInfoScreen extends React.Component{
                        static navigationOptions = ({navigation}) => {
                            const {params = {}} = navigation.state;
                            let headerRight = (
                                <Button
                                    title = 'Save'
                                    onPress = {params.handleSave ? params.handleSave : () => null}
                                />
                            );

                            if(params.isSaving) headerRight = <ActivityIndicator/>;

                            return {headerRight}
                        }

                        state={
                            nickname:'Lucy jacuzzi'
                        }

                        _handleSave = () => {
                            this.props.navigation.setParams({isSaving:true});

                            saveInfo().then( () => {
                                this.props.navigation.setParams(isSaving:false);
                            });
                        }

                        componentDidMount(){
                            this.props.navigation.setParams({handleSave:this._handleSave});
                        }

                        render(){
                            return <TextInput
                                onChangeText = {(nickname) => this.setState({nickname})}
                                placeholder={'Nickname'}
                                value={this.state.nickname}
                            />
                        }
                    }
                    //注意，由于param handleSave仅仅在组件挂载时设置，它不是立即可用的。因此handleSave被默认为空的函数从而避免组件
                    //渲染的闪烁。

                    作为一个可替代setParams的方案。你可以考虑使用state状态管理库如：Mobx或Redux。当导航到一个屏幕时，传递一个对象，
                    该对象包含要呈现的屏幕所需的数据，以及您可能想要调用的函数修改数据、发出网络请求等等。这样，您的屏幕组件和静态
                    的navbarOptions块都可以访问该对象。当遵循此方法时，请确保考虑深层链接，在只将javascript原语作为导航道具传递到屏
                    幕的情况下，这是最有效的。如果需要进行深度链接，您可以使用更高阶组件(HOC)将原语转换为屏幕组件所期望的对象。
            》Navigators
                Navigators允许你定义应用的导航结构，并且它还允许渲染可配置的相同元素，如：headers以及tab bars。
                其实，navigators只是普通的React 组件。
                》内置的Navigators
                    react-navigation包含了以下函数从而来帮你创建navigators：
                    》StackNavigator
                        一次渲染一个屏并提供屏幕切换之间的过渡。当一个新屏幕被打开时，它被放置在栈顶。
                    》TabNavigator
                        渲染一个标签栏，让用户在多个屏幕之间切换
                    》DrawerNavigator
                        提供一个从屏幕左侧滑动的抽屉。
                》用Navigators渲染屏幕
                    这个navigators渲染应用的屏幕仅仅是React组件。
                    要了解怎样创建屏幕需要学习：
                    》屏幕的navigation prop -- 允许屏幕分发导航操作 如：打开应用的其他屏
                    》屏幕的navigationOptions -- 自定义navigator的呈现 如：header的title tab的label。
                》在顶层组件调用 Navigate
                    如果你想使用同一级别的navigator，你可以使用ref属性声明。
                    import {NavigationActions} from 'react-navigation'
                    const AppNavigator = StackNavigator(SomeAppRouteConfigs);
                    class App extends React.Component{
                        someEvent(){
                            this.navigator && this.navigator.dispatch(
                                NavigationActions.navigate({routeName:someRouteName});
                            );
                        }

                        render(){
                            <AppNavigator ref={ nav => {this.navigator = nav}}/>
                        }
                    }
                    //注意：这个解决方案只能用在顶级导航器上。
                》navigation 容器
                    当navigation prop缺失时，内置的navigators能够自动的成为顶级navigators。这个功能提供了一个透明的navigation 容器，这就是
                    顶级navigation prop的来源。

                    当渲染一个包含navigators的组件时，navigation prop时可选的。当它缺失时，这个容器自动管理自己的navigation state，处理url、
                    外部链接和android 返回键等。

                    为了达到上面效果，这个内置navigators有上面功能。因为它们使用了createNavigationContainer。通常navigators需要一个navigation
                    prop才能运行。

                    顶级navigators接受下列属性：
                    onNavigationStateChange(prevState, newState, action);
                    这个函数在navigator state 改变时被调用。默认情况下会在控制台打印state的改变。
                    uriPrefix -- 应用的url前缀可能会被处理，这将在深层次的链接中用来提取router。
            》StackNavigator
                提供了一个方式使得应用从一个屏到新屏的过渡，新屏将被放置在栈顶。
                默认情况下StackNavigator被配置为iOS和android是相似的。在iOS中新屏从屏幕右侧滑入，android从底部进入屏幕。
                在iOS中StackNavigator也可以配置成新屏从底部滑入。

                案例：
                class MyHomeScreen extends React.Component{
                    static navigationOptions = {
                        title:'Home'
                    }

                    render(){
                        return (
                            <Button
                                onPress={ ()=> this.props.navigation.navigate('Profile',{name:'Lucy'})}
                                title="Go to Lucy's profile"
                            />
                        );
                    }
                }

                const ModalStack = StackNavigator({
                    Home:{
                        screen:MyHomeScreen
                    },
                    Profile:{
                        path:'people/:name',
                        screen:MyProfileScreen
                    }
                });


                》API解析
                    StackNavigator(RouteConfigs,StackNavigatorConfig);
                    》RouteConfigs
                        这个路由配置对象是从route的name 到 route的配置的一个映射，这将告诉navigator怎样呈现这个route。
                        {
                            //为每个可以导航到的screen，创建如下一样的入口。
                            Profile:{
                                screen:ProfileScreen,//ProfileScreen是React组件，这将是该屏的主要内容，当该组件被StackNavigator加载后，它将得到navigation prop。
                                path:'people/:name',//可选的 当深度链接或利用react-navigation在web应用中时，该属性被使用 。 可以提取route的action以及params。
                                navigationOptions:({navigation}) => ({//可选的 会覆盖屏幕本身的 navigationOptions
                                  title:`${navigation.state.params.name}'s Profile'`,
                                })
                            }
                        }
                    》StackNavigatorConfig
                        {
                            //router 选项
                            initialRouteName,//设置stack中的默认screen，必须是RouteConfigs的一个key
                            initialRouteParams,//初始化route的参数
                            navigationOptions,//所有屏幕的默认navigation options
                            paths,//覆盖RouteConfigs中设置的path的映射

                            //视觉 选项
                            mode,//定义渲染和过渡的样式 card(利用标准的iOS和android的屏幕过渡 默认值) modal(让屏幕从底部滑动，这是一个常见的iOS模式。只在iOS上运行，对Android无效。)
                            headerMode,//指定怎样渲染header ，其值如下：
                                》float 在屏幕更改时渲染保留在顶部的单个header和动画。这是iOS上的常见模式
                                》screen 每个屏幕都有一个header，header与屏幕一起淡入淡出。这是Android上的常见模式
                                》none 没有header将被渲染
                            cardStyle,//使用这个属性来覆盖或扩展stack中单个卡片的默认样式
                            transitionConfig:function(transitionProps,prevTransitionProps,isModal){//值为一个函数，并返回一个合并了默认屏过渡类型的对象
                                //transitionProps -- 新屏的过渡props
                                //prevTransitionProps -- 旧屏的过渡prop
                                //isModal -- Boolean  指定屏幕是否为modal
                            },
                            onTransitionStart，//当卡片过渡动画开始时调用的函数
                            onTransitionEnd//当卡片过渡动画结束时调用的函数
                        }
                    》navigationOptions属性
                        {
                            title,//String (StackNavigator中的headerTitle,TabNavigator中的tabBarLabel，DrawerNavigator中的drawerLabel中的备用)
                            header,//React Element 或 接受HeaderProps参数的函数，该函数返回React Element，用于显示header，如果需要隐藏header则设置为null
                            headerTitle,//String,React Element或React组件使用这个header，其默认值为title值。当一个组件被使用，它将接受allowFontScaling、style、children props，这个title字符串通过children传递
                            headerTitleAllowFontScaling,//headerTitle是否被缩放 默认true
                            headerBackTitle,//iOS上后退按钮的title字符串，如果为null表示不可用。默认为上一个屏幕的headerTitle
                            headerTruncatedBackTitle,//当headerBackTitle不适合于当前屏幕时的返回按钮的title字符串。默认'Back'
                            headerRight,//显示在header右边的React Element
                            headerLeft,//显示在header左边的React Element或组件 当一个组件被使用时，它将接收一些props 如：onPress title titleStyle等
                            headerStyle,//header的样式对象
                            headerTitleStyle,//title组件的样式对象
                            headerBackTitleStyle，//返回title的样式对象
                            headerTintColor,//header的颜色
                            headerPressColorAndroid,//点击header的颜色 仅仅android>=5.0支持
                            gesturesEnabled，//是否可以使用手势来消除此屏幕。在iOS上默认为true，在Android上为false。
                            gestureResponseDistance：{//手势识别的距离
                                horizontal： number - 水平方向的距离。默认为25。
                                vertical：number - 垂直方向的距离。默认为135
                            }，
                            gestureDirection ，//String 重置关闭手势的方向 default -- 正常的行为 inverted-- 从右到左滑动
                        }
                    》Navigator Props
                        通过StackNavigator(...)的方式创建的navigator组件有如下属性：
                        》screenProps -- 将额外的参数传递给子屏幕 如：
                            const SomeStack = StackNavigator({...});

                            <SomeStack screenProps={
                                //这个属性将被传递到screen组件中
                            }/>
            》TabNavigator
                利用TabRouter可以更容易的设置有多个选项卡的屏。

                class MyHomeScreen extends React.Component{
                    static navigationOptions = {
                        tabBarLabel:'Home',
                        tabBarIcon:({tintColor}) => (
                            <Image
                                source={ require('./chats-icon.png')}
                                style={[styles.icon,{tintColor:tintColor}]}
                            />
                        )
                    }

                    render(){

                        return (
                            <Button
                                onPress = { () => this.props.navigation.navigate('Notifications') }
                                title='Go to notifications'
                            />
                        );
                    }
                }

                class MyNotificationsScreen extends React.Component{
                    static navigationOptions = {
                        tabBarLabel:'Notifications',
                        tabBarIcon:({tintColor}) => (
                            <Image
                                source={require('./notif-icon.png')}
                                style={[styles.icon,{tintColor:tintColor}]}
                            />
                        )
                    }

                    render(){
                        return (
                            <Button
                                onPress = { ()=> this.props.navigation.goBack()}
                                title='Go back home'
                            />
                        );
                    }
                }

                const styles = StyleSheet.create({
                    icon:{
                        width:26,
                        height:26,
                    }
                });

                const MyApp = TabNavigator({
                    Home:{
                        screen:MyHomeScreen
                    },
                    Notifications:{
                        screen:MyNotificationsScreen
                    }
                },{
                    tabBarPosition:'top',
                    animationEnabled:true,
                    tabBarOptions:{
                        activeTintColor:'#e91e63'
                    }
                });

                》API 解析
                    TabNavigator(RouteConfigs,TabNavigatorConfig);
                    》RouteConfigs
                        其配置和StackNavigator Route configs 一样

                        》navigationOptions 配置属性：
                            {
                                title//headerTitle 与tabBarLabel的备用字段
                                tabBarVisible//是否显示tab bar  默认为true
                                swipeEnabled//是否启用tabs之间的滑动，不设置则使用TabNavigatorConfig的选项值
                                tabBarIcon //添加图标 React Element 或接受focused(boolean) tintColor(string)参数的函数 返回一个React Node
                                tabBarLabel //String || React Element || ({focused:boolean,tintColor:string}) => { return React.Node } 如不设置即undefined 则使用title的值
                                tabBarOnPress:function({previousScene,scene,jumpToIndex }){// onPress事件回调函数
                                    //previousScene:{route, index} 离开的屏
                                    //scene: { route, index }
                                    //jumpToIndex -- 函数 执行导航的函数
                                }
                            }
                    》TabNavigatorConfig
                        {
                            tabBarComponent，//tabBar使用的组件 iOS默认 TabBarBottom ，android默认 TabBarTop
                            tabBarPosition,//tabBar的位置 其值'top' ,'bottom'
                            swipeEnabled，//是否允许tabs 屏幕之间的滑动
                            animationEnabled，//是否启用动画 在tabs切换时
                            configureTransition，//其值是一个函数 接收currentTransitionProps  和 nextTransitionProps参数，返回一个配置对象用于描述tabs之间的动画
                            initialLayout:{//避免延时帧
                                    width,
                                    height
                            },
                            tabBarOptions:{//配置tab bar
                                //为TabBarBottom组件(默认是iOS上的tab bar)的配置如下
                                activeTintColor,//激活tab是 Label和icon的颜色
                                activeBackgroundColor，//激活tab的背景颜色
                                inactiveTintColor，//未激活的tab的 Label和icon的颜色
                                inactiveBackgroundColor，//未激活tab的背景颜色
                                showLabel，//是否显示label  默认true
                                style，//tab bar的样式对象
                                labelStyle，//tab label的样式对象
                                tabStyle,//tab的样式对象
                                allowFontScaling，//label 字体是否能够缩放  默认true

                                //为TabBarTop(android上的tab bar)组件的配置
                                activeTintColor//tab激活的label和icon颜色
                                inactiveTintColor//tab未激活的label icon颜色
                                showIcon//是否显示icon 默认false
                                showLabel //是否显示label 默认true
                                upperCaseLabel//是否让label转成大写  默认true
                                pressColor //按下时的波纹颜色 Android >= 5.0 only
                                pressOpacity //按下时波纹透明度 iOS and Android < 5.0 only
                                scrollEnabled //是否可以滚动tab
                                tabStyle //tab的样式对象
                                indicatorStyle //tab 下面line的样式对象
                                labelStyle //label样式对象
                                iconStyle //tab icon的样式对象
                                style //tab bar样式对象
                                allowFontScaling //是否允许label 字体缩放
                            },
                            initialRouteName，//需要首次加载的tab  其值routeName
                            order，//tabs的顺序， 其值是routeName的数组
                            paths，//为路径配置提供一个routeName映射，它覆盖了在routeConfigs中设置的路径
                            backBehavior，//后退按钮是否会导致标签切换到初始tab，如果是设置为initialRoute(默认值)，否则设置为'none'
                        }
                    》navigator props
                        被TabNavigator创建的navigator组件有如下属性：
                        screenProps -- 传递给子屏幕的额外属性和navigation 选项

                        const TabNav = TabNavigator({});
                        <TabNav screenProps={}/>
            》DrawerNavigator
                使用DrawerNavigator可以更容易创建抽屉导航。

                class MyHomeScreen extends React.Component{
                    static navigationOptions = {
                        drawerLabel:'Home',
                        drawerIcon:({tintColor}) => (
                            <Image source={require('./chats-icon.png')} style={[styles.icon,{tintColor}]}/>
                        )
                    }

                    render(){
                        return (
                            <Button
                                onPress={ () => this.props.navigation.navigate('Notifications')}
                                title='Go to notifications'
                            />
                        );
                    }
                }

                class MyNotificationsScreen extends React.Component{
                    static navigationOptions = {
                        drawerLabel:'Notifications',
                        drawerIcon:({tintColor}) => (
                            <Image source={require('./notif-icon.png')} style={[styles.icon,{tintColor}]}/>
                        )
                    }

                    render(){
                        return (
                            <Button onPress={() => this.props.navigation.goBack()} title='Go back home'/>
                        );
                    }
                }

                const styles = StyleSheet.create({
                    icon:{
                        width:24,
                        height:24
                    }
                });

                const MyApp = DrawerNavigator({
                    Home:{
                        screen:MyHomeScreen
                    },
                    Notifications:{
                        screen:MyNotificationsScreen
                    }
                });

                //打开抽屉卡片
                this.props.navigation.navigate('DrawerOpen');
                //关闭抽屉卡片
                this.props.navigation.navigate('DrawerClose');
                //切换抽屉卡片
                this.props.navigation.navigate('DrawerToggle');

                》API
                    DrawerNavigator(RouteConfig,DrawerNavigatorConfig);

                    》RouteConfigs
                        和StackNavigator一样的
                    》DrawerNavigatorConfig
                        {
                            drawerWidth //抽屉的宽度 数值或返回数值的函数
                            drawerPosition//抽屉的位置 默认left 其值left right
                            contentComponent //抽屉的渲染内容组件。如 导航items。该组件接收navigation prop 默认是DrawerItems组件
                            contentOptions:{//配置抽屉内容
                                //针对DrawerItems 的抽屉条目的配置
                                items //routes数组
                                activeItemKey //激活route的key
                                activeTintColor //激活label 和 icon的颜色
                                activeBackgroundColor //激活label的背景颜色
                                inactiveTintColor //未激活项 label icon的颜色
                                inactiveBackgroundColor //未激活项 的背景颜色
                                onItemPress(route)//点击item的执行函数
                                itemsContainerStyle //内容容器的样式对象
                                itemStyle //条目的样式对象
                                labelStyle //label的样式对象
                                iconContainerStyle //图标容器View的样式对象
                            }
                            useNativeAnimations //是否启用原生动画 默认true
                            drawerBackgroundColor //抽屉的背景颜色  默认是white
                            initialRouteName //初始化routeName
                            order //导航条目的顺序  routeNames组成的数组
                            paths //它将覆盖routeConfigs中设置的path
                            backBehavior //返回按钮的行为 initialRoute(默认值) -- 回到初始页面 none -- 退出应用程序
                        }
                    》contentComponent -- 自定义抽屉内容的属性
                        这个抽屉的默认组件(DrawerItems)是可滚动的，并且只包含了RouteConfigs中路由的链接。您可以轻松地覆盖默认组件，
                        在抽屉中添加页眉、页脚或其他内容。默认情况下，抽屉是可滚动的，支持iPhone X安全区。如果您自定义内容，
                        请确保将内容包装在一个SafeAreaView中:

                        import {DrawerItems,SafeAreaView} from 'react-navigation'
                        const CustomDrawerContentComponent = (props) => (
                          <ScrollView>
                            <SafeAreaView style={styles.container} forceInset={{ top: 'always', horizontal: 'never' }}>
                              <DrawerItems {...props} />
                            </SafeAreaView>
                          </ScrollView>
                        );

                        const styles = StyleSheet.create({
                          container: {
                            flex: 1,
                          },
                        });


































