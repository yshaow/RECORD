/************************React Native***********************/
1.环境搭建
    windows --> android
        》安装jdk
            v1.8以上
        》安装sdk
            http://www.androiddevtools.cn/
        》安装c++环境
            选择windows SDK cygwin或mingw等其他C++环境，编译node.js的c++模块需要用到
        》安装Node 与 Git
             echo %PATH% 查看环境变量(命令行)
             设置npm镜像：
                npm config set registry https://registry.npm.taobao.org --global
                npm config set disturl https://npm.taobao.org/dist --global
        》安装React Native命令行工具
            npm install -g react-native-cli
        》创建项目
            react-native init 项目名
        》进入工程目录运行packager
            react-native start
            可以用浏览器方法http://localhost:8081/index.android.bundle?platform=android(.49版本以前)查看是否可以看到打包后的脚本
            http://localhost:8081/index.bundle?platform=android(.49版本)
        》准备模拟器或真机运行android
            react-native run-android

            adb devices 查看手机列表 如果出错 可能是360等引起的  需要关闭

            android studio 管理genymotion模拟器 需要在插件中下载 genymotion 然后关联 自己的genymotion即可

            真机测试
                使用droidAtScreen-1.2.jar 把手机屏幕投到电脑屏幕上，方便查看
            问题：
                找不到SDK或者无法正常化SDK路径 --》 查看环境变量是否配置正确
                build成功后是红色：没有链接到服务器js Server --》 在手机端配置debug ip: ip+8081端口 如：192.168.1.100：8081
        》调试App -- 更新应用
            reload js (菜单中 reload)
            android -- 双击rr
            iOS -- Cmd+R (Cmd+D 打开菜单)

    Mac
        Win7是Server，Mac是Client，VMware上运行Mac系统
        1、在VMware的Options菜单中选择Shared Folders选项
        2、选择Always enabled选项
        3、然后选择要在Win7系统上共享的文件夹路径名
        4、在Win7系统下将改文件夹设为共享
        5、进入MAC系统桌面右键点击Finder前往菜单Connectting to Server
        6、在连接服务器对话框中输入[smb://Windows主机的IP地址],其中smb是访问Windows共享文件夹所使用的协议名称
        7、连接到Windows主机之后会显示该主机所共享的文件夹，选择想要访问的一个即可
        8、这样再次打开Finder的时候就可以直接访问到共享文件夹了

        》安装Homebrew
            /usr/bin/ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)"
            权限的问题安装失败：sudo chown -R `whoami` /usr/local
        》使用Homebrew安装Node
            brew install node
            npm config set registry https://registry.npm.taobao.org --global
            npm config set disturl https://npm.taobao.org/dist --global
        》安装react-native-cli
            npm install -g yarn react-native-cli
            yarn config set registry https://registry.npm.taobao.org --global
            yarn config set disturl https://npm.taobao.org/dist --global
            //EACCES: permission denied:
            sudo chown -R `whoami` /usr/local
        》Watchman -- 热更新
            brew install watchman
        》Flow -- 一个静态的JS类型检查工具
            brew install flow

        iOS：
            》Xcode -- App Store下载安装  需要8.0以上版本
            》测试安装
                        react-native init test
                        react-native run-ios
        Android
            》JDK 1.8以上
            》AndroidStudio v2.x以上
                ANDROID_HOME环境变量：
                    vi ~/.bash_profile
                    # 如果你不是通过Android Studio安装的sdk，则其路径可能不同，请自行确定清楚。
                    export ANDROID_HOME=~/Library/Android/sdk
                    立即生效：source ~/.bash_profile
                    查看：echo $ANDROID_HOME
                    #添加Android SDK环境变量的Tools添加到PATH变量中 ~/.bash_profile
                    export PATH=$PATH:$ANDROID_HOME/tools:$ANDROID_HOME/platform-tools
            》Git
                brew install git
            》Genymotion 模拟器
            》Gradle Daemon 开启Gradle Daemon可以极大地提升java代码的增量编译速度。
                touch ~/.gradle/gradle.properties && echo "org.gradle.daemon=true" >> ~/.gradle/gradle.properties
            》测试安装
                react-native init test
                react-native run-android
2.从React到RN
    》React特点
        》作为UI
        》虚拟DOM
            是React最重要的一个特性，放进内存最小更新视图(差异部分更新 -- diff算法)
        》数据流 -- 单向数据流
    》为什么要使用React Native
        如何在开发成本和用户体验做到更好的平衡？很多时候前端有一种乐观的想法：h5可以替代原生应用(但性能不理想)
        RN不仅可以使用前段开发的模式来开发应用，还能调用原生应用的UI组件和API。
3.flexbox布局
    flexbox是Flexible Box的缩写即弹性盒子布局 -- 主流浏览器都支持。

    flexbox是伸缩容器container和伸缩项目item组成。

    flexbox布局的主体思想是元素可以改变大小以适应可用空间，但可用空间变大Flex元素将伸展大小以填充可用空间，但Flex
    元素超出可用空间时将自动缩小。总之Flex元素是可以让你的布局根据浏览器的大小变化进行自动伸缩。

    按照伸缩流的方向布局：伸缩容器有主轴和交叉轴(垂直于主轴的次轴)组成，主轴既可以是水平轴也可以是垂直轴。

    flexbox目前还处于草稿状态，所有在使用flexbox布局的时候，需要加上各个浏览器的私有兼容前缀如：-webkit -moz -ms -o等。

    》伸缩容器的属性
        》display:flex(块级伸缩容器) | inline-flex(行内级伸缩容器)
        》flex-direction 指定主轴的方向
            flex-direction：row(默认值 从左到右) | row-reverse(从右到左) | column(从上到下) | column-reverse(从下到上)
        》flex-wrap 伸缩容器在主轴线方向空间不足的情况下，是否换行以及该如何换行
            flex-wrap:nowrap(默认值 不换行 flex的项会自动缩小) | wrap(换行 从上到下) | wrap-reverse(换行  从下到上)
        》flex-flow 是flex-direction和flex-wrap的缩写版本，它同时定义了伸缩容器的主轴和侧轴  其默认值 row nowrap;
        》justify-content 用来定义伸缩项目 在主轴线的对齐方式
            justify-content:flex-start(默认值 起始方向) | flex-end(结束位置) | center(中心) | space-between(均匀分布在主轴线上) | space-around(均匀分布在主轴线上，开始位置和结束为止留中间间隙的一半)
        》align-items 用来定义伸缩项目在交叉轴上的对齐方式
            align-items:flex-start(默认值 交叉轴起始位置) | flex-end(结束位置) | center(中心) | baseline(基准线) | stretch(沿着交叉轴拉伸铺满)

        》align-content
            用来调整伸缩项目换行后 在交叉轴上的对齐方式
            align-content:flex-start(交叉轴的起始位置) | flex-end(结束位置) | center(中心) | space-between(均匀分布在交叉轴上) | space-around(均匀分布在交叉轴上 起始位置和结束位置有间隙) | stretch(默认值)

        伸缩项目的属性
        》order:整数值
            定义项目排列顺序，数值越小，排列越靠前，默认值是0

        》flex-grow:整数值
            定义伸缩项目的放大比例     默认值是0--即表示如果存在剩余空间也不放大
        》flex-shrink:整数值  当容器大小不足的时候起作用
            定义伸缩项目的收缩能力，默认值是1
        》flex-basis:length(如：200px) | auto(默认值)
            用来设置伸缩项目的基准值，剩余的空间按比率进行伸缩。
        》flex ：none | flex-grow flex-shrink flex-basis 其中第二个和第三个参数为可选参数 默认值：0 1 auto;
            是flex-grow flex-shrink flex-basis这三个属性的缩写
        》align-self : auto | flex-start | flex-end | center | baseline | stretch(伸缩项目在交叉轴方向沾满伸缩容器，
            如果交叉轴沾满伸缩容器，如果交叉轴为垂直方向的话，只有在不设置高度的情况下才能看到效果。)
            用来设置单独的伸缩项目在交叉轴上的对齐方式，会覆盖默认的对齐方式
4.在React Native中使用flexbox
    RN目前主要支持flexbox的如下6个属性：
    》alignItems:flex-start(默认值) | flex-end | center| stretch
        用来定义伸缩项目在交叉轴上的对齐方式
    》alignSelf:auto | flex-start | flex-end | center | stretch(伸缩项目在交叉轴方向沾满伸缩容器，如果交叉轴为垂直方向的话，只有在不设置高度的情况下才能看到效果)
        用来设置单独的伸缩项在交叉轴的对齐方式，会覆盖默认的对齐方式。
    》flex
        和web端的flex用法一样
    》flexDirection:row | row-reverse | column(默认值) | column-reverse
        指定主轴的方向
    》flexWrap
        用法和web端一样
    》justifyContent
        用法和web端一样
5.html5与react native的区别
    》样式

    》元素

    》书写格式
6.JSX
    React是由ReactJs与React Native组成，其中ReactJs是Facebook开源的一个前端框架，React Native是ReactJs思想在native上的体现。
    JSX不是一门新的语言，仅仅是语法糖，允许开发者在js中书写HTML语法，最后每个HTML标签都转化为js代码来运行。

7.ReactJs
    核心思想：组件化 维护自己的状态和UI，自动重新渲染。多个组件组成了一个ReactJS应用。
    虚拟DOM：将真实的DOM结构映射成一个JSON的数据结构。

8.调式与打包发布
    调式：
        reload js --更新代码之后 reload js会更新app
        debug js 和chrome结合使用
        enable live reload --开启自动刷新app 更新代码自动刷新
        检查元素
        enable perf monitor -- 查看性能
        dev settings
    打包发布：
        1.生成一个签名密钥
            keytool -genkey -v -keystore my-release-key.keystore -alias my-key-alias -keyalg RSA -keysize 2048 -validity 10000
            或
            keytool -importkeystore -srckeystore my-release-key.keystore -destkeystore my-release-key.keystore -deststoretype pkcs12
        2.找到路径/android/app/src/main，并在该目录下新建assets文件夹
        3.在工程目录下将index.android.bundle下载并保存到assets资源文件夹中
            curl -k 'http://localhost:8081/index.android.bundle' > android/app/src/main/assets/index.android.bundle
            上面命令是重点，如果assets目录中不存在该文件，则打包的apk在执行时显示空白。

            如果出现：Protocol "'http" not supported or disabled in libcurl错误
            执行：curl -k "http://localhost:8081/index.android.bundle" > android/app/src/main/assets/index.android.bundle

            使用这个命令：curl -k "http://localhost:8081/index.bundle?platform=android" > android/app/src/main/assets/index.bundle

            如果curl命令不存在，windows安装使用curl命令：http://jingyan.baidu.com/article/a681b0dec4c67a3b1943467c.html
            将curl.exe放到需要执行curl命令的目录下 也可以设置环境变量
        4.添加gradle的android keystore配置
            打包的apk在未签名的情况下，在手机中(非root)是不允许安装的

            在app目录下的build.gradle文件中：
            //添加签名 -- defaultConfig下面
            signingConfigs {
                release {
                    storeFile file("my-release-key.keystore路径")
                    storePassword "密码"
                    keyAlias "keyAlias的名字"
                    keyPassword "密码"

                    如：
                    storeFile file("E://projects/record/react-native/myReactNative/my-release-key.keystore")
                    storePassword "123456"
                    keyAlias "my-key-alias"
                    keyPassword "123456"
                }
            }

            //在buildTypes中 引用签名配置
            buildTypes {
                release {
                    minifyEnable false
                    proguardFiles getDefaultProguardFile('......')
                    //添加下面即可
                    signingConfig signingConfigs.release
                }
            }
        5.启用Proguard代码混淆来缩小APK文件的大小
            Proguard是一个Java字节码混淆压缩工具，它可以移除掉React Native Java和它的依赖库中没有被使用到的部分，最终
            有效的减少APK的大小。
            重要：启用Proguard之后，你必须再次全面测试你的应用，Proguard有时候需要为你引入的每个原生库做一些额外的配置。
                  参见app/proguard-rules.pro文件。

            def enableProguardInReleaseBuilds = true //在app/build.gradle
        6.在**/android/**目录中执行gradle assembleRelease命令，打包后的文件在android/app/build/outputs/apk(debug.apk是开发环境用到的包)目录中，如：app-release.apk。
          如果打包碰到问题可以先执行 gradle clean清理一下。
          **unaligned.apk是没有签名的(不使用)**

          安装gradle工具(版本与android/gradle/wrapper/gradle-wrapper.properties下的一致)，并配置环境变量，配置GRADLE_HOME到gradle根目录中，然后把%GRADLE_HOME%/bin(
          linux或mac是$GRADLE_HOME/bin)加到PATH环境变量中。
          配置完成之后，运行gradle -v,检测是否安装无误。
        7.将apk发布到各大应用市场
9.React Native 组件
    》View组件
        它类似于div，支持多层嵌套，支持flexbox布局。

        组件使用步骤：
            》加载View组件
                import {View} from 'react-native'
            》创建组件
                class ViewTest extends React.Component{

                    render(){
                        return (
                            <View style={styles.flex}/>
                        );
                    }
                }
            》添加样式表
                import {StyleSheet} from 'react-native'
                const styles = StyleSheet.create({
                    flex:{flex:1}
                });

                外联样式: -- 推荐
                    <View style={ styles.flex }></View>
                内联样式：-- 不推荐
                    <View style={ {flex:1,borderWidth:1} }></View>
                多个样式:
                    <View style={ [styles.flex,{flexDirection:'row'}] }></View>


                import {PixelRatio} from 'react-native'
                //PixelRatio.get() -- 获取高清设备的像素比
                //1/PixelRatio.get() -- 当前设备的最小像素
                //使用场景：
                如：borderLeftWidth:1/PixelRatio.get()
            》注册入口 -- 一个应用，只有一个
                import { AppRegistry } from 'react-native';
                import App from './App';

                AppRegistry.registerComponent('myReactNative/*应用名称*/', () => App /*入口组件*/);
            》外层布局

            》flexbox水平三栏布局

            》上下两栏布局

            》完善效果
    》Text组件 主要用于显示文本，具有响应性，可以嵌套，可以继承样式
               内部Text组件可以继承外部Text组件的样式。
      Text组件的特性：
        》onPress 点击事件触发
        》numberOfLines 最多显示多少行，超过用省略号替代
        》onLayout 获取元素的位置和大小
    》Navigator组件
        一个应用往往是由多功能视图组成，多页面的切换：路由或导航。在RN中专门负责视图切换的组件：Navigator(android or iOS)，NavigatorIOS(iOS)。

        导航器对比：
            Navigator和NavigatorIOS都可以用来管理应用中"场景"的导航。导航器建立了一个路由栈，用来弹出，推入或替换路由状态。他们
            和HTML5中的history API很类似。主要区别在于NavigatorIOS使用了iOS中的UINavigationController类，而Navigator则完全用js
            重写了一个类似功能的React组件。因此Navigator可以兼容iOS和android，而NavigatorIOS只能用于iOS。

            NavigatorIOS轻量，受限的API设置，使其相对于Navigator来说不太方便定制。由开源社区主导开发，React Native的官方
            团队并不在自己的应用中使用它。

            对于大多数正式APP开发，建议使用Navigator -- 使用NavigatorIOS实现复杂的需求容易碰到麻烦。

            导航器通过路由对象来分辨不同的场景。利用renderScene方法，导航栏可以根据指定的路由来渲染场景。
            可以通过configureScene属性获取指定路由对象的配置信息，从而改变场景的动画或手势。
            renderScene = {
                (route,navigator) => {
                    let Component = route.component;
                    return <Component {...route.params} navigator={navigator}/>
                }
            }




































/************************文档分析***********************/
http://reactnative.cn/docs/0.49/getting-started.html
1.搭建开发环境
    1.1 Windows
      》Android
        安装
            必需的软件
            》Chocolatey(https://chocolatey.org/) -- 是windows上的包管理器，类似于linux上的yum和apt-get

                命令：
                @powershell -NoProfile -ExecutionPolicy Bypass -Command "iex ((new-object net.webclient).DownloadString('https://chocolatey.org/install.ps1'))" && SET PATH=%PATH%;%ALLUSERSPROFILE%\chocolatey\bin
                以管理员身份运行命令窗口，无法安装也无所谓，它只是一个包管理器
            》Python2
                使用Chocolatey来安装Python2，目前不支持Python3版本
                choco install python2
            》Node
                安装NodeJS
                choco install nodejs.install

                安装完node后建议设置npm镜像，注意：不要使用cnpm cnpm安装的模块路径比较奇怪，packager不能正常识别
                npm config set registry https://registry.npm.taobao.org --global
                npm config set disturl https://npm.taobao.org/dist --global
            》  Yarn、React Native的命令行工具(react-native-cli)
                Yarn是Facebook提供的替代npm的工具，可以加速node模块的下载。
                React Native的命令行工具用于执行创建、初始化、更新项目、运行打包服务packager等任务

                npm install -g yarn react-native-cli

                安装完yarn后同理设置镜像源
                yarn config set registry https://registry.npm.taobao.org --global
                yarn config set disturl https://npm.taobao.org/dist --global

                如果遇到EACCES: permission denied权限错误，可以尝试下面命令(Linux系统)：
                sudo npm install -g yarn react-native-cli

                安装完yarn之后可以使用yarn代替npm：
                    yarn 代替 npm install 命令
                    yarn add 第三方库名 代替 npm install --save 第三方库名

                注意：目前npm5存在安装新库时会删除其他库的问题，导致项目无法正常运行，所以尽量使用yarn代替npm操作。
            》Android Studio -- http://developer.android.com/sdk/index.html
                React Native目前需要Android Studio2.0或更高版本
                Android Studio需要Java Development Kit [JDK]1.8或更高版本。你可以在命令行中输入 javac -version查看你当前安装的
                JDK版本。
                choco install jdk8或apt-get install default-jdk

                Android Studio包含了运行和测试React Native应用所需要的Android SDK和模拟器。
                注意：除非特别注明，请不要改动安装过程中的选项，如：Android Studio默认安装了Android Support Repository，而这
                也是React Native必须的--否则react-native run-android时会报appcompat-v7包找不到的错误。

                确定所有安装都勾选了 尤其是android SDK 和Android Device Emulator。
                在初步安装完成后选择Custom安装项
                    》检测已安装的组件尤其是模拟器和HAXM加速驱动
                    》安装完成后，在Android Studio的欢迎界面中选择 Configure --》SDK Manager。
                        在SDK Platforms窗口中选择Show Package Details
                            然后再Android 6.0(Marshmallow)中勾选
                                Google APIs
                                Android SDK Platform 23
                                Intel x86 Atom System Image
                                Intel x86 Atom_64 System Image
                                Google APIs Intel x86 Atom_64 System Image

                        》在SDK Tools窗口中选择Show Package Details
                            然后再Android SDK Build Tools中勾选Android SDK Build-Tools 23.0.1 -- 必须包含有这个版本。如果其他
                            插件需要其他版本，你可以同时安装其他多个版本。然后勾选底部的Android Support Repository。

                ANDROID_HOME环境变量：
                    确保该环境变量指向了android的SDK路径(新建中配置)

            推荐安装的工具
                Gradle Daemon
                    开启Gradle Daemon可以极大地提升java代码的增量编译速度
                    (if not exist "%USERPROFILE%/.gradle" mkdir "%USERPROFILE%/.gradle") && (echo org.gradle.daemon=true >> "%USERPROFILE%/.gradle/gradle.properties")

                    将Android SDK的Tools目录添加到PATH变量中
                        你可以把Android SDK的tools和platform-tools目录添加到PATH变量中，以便在终端中运行一些Android工具，例如android avd或是adb logcat等。

                Git
                    choco install git
                    注意勾选"Run Git from Windows Command Prompt"，这样才会把git命令添加到PATH环境变量中。

                Genymotion -- https://www.genymotion.com/
                    比起Android Studio自带的原装模拟器，Genymotion是一个性能更好的选择，但它只对个人用户免费。

                    Genymotion需要依赖VirtualBox虚拟机，下载选项中提供了包含VirtualBox和不包含的选项。
                    创建一个新模拟器并启动
                    启动React Native应用后，可以按下F1来打开开发者菜单。

                Visual Studio Emulator for Android
                    是利用Hyper-v技术进行硬件加速的免费android模拟器，也是Android Studio自带的原装模拟器之外的一个很好的选择。
                    而且你并不需要安装Visual Studio。在用于React Native开发前，你需要先在注册表中进行一些修改

                        打开运行命令（按下Windows+R键）
                        输入regedit.exe然后回车
                        在注册表编辑器中找到HKEY_LOCAL_MACHINE\SOFTWARE\Wow6432Node\Android SDK Tools条目
                        右键点击Android SDK Tools，选择新建 > 字符串值
                        名称设为Path
                        双击Path，将其值设为你的Android SDK的路径。（例如C:\Program Files\Android\sdk）
            测试安装
                react-native init myProject
                cd myProject
                react-native run-android
                提示：你可以使用--version参数创建指定版本的项目。例如react-native init MyApp --version 0.44.3。注意版本号必须精确到两个小数点。

            修改项目
                使用你喜欢的文本编辑器打开App.js并随便改上几行
                按两下R键，或是用Menu键（通常是F2，在Genymotion模拟器中是⌘+M）打开开发者菜单，然后选择 Reload JS 就可以看到你的最新修改。
                在终端下运行adb logcat *:S ReactNative:V ReactNativeJS:V可以看到你的应用的日志。
      》iOS 不支持
    1.2 Linux
      》Android
        必须软件
            Node
            Yarn、React Native的命令行工具（react-native-cli）
                npm install -g yarn react-native-cli
                yarn config set registry https://registry.npm.taobao.org --global
                yarn config set disturl https://npm.taobao.org/dist --global
            Android Studio
                ANDROID_HOME环境变量
                    具体的做法是把下面的命令加入到~/.bashrc、~/.bash_profile文件中。如果你使用的是其他的shell，则选择对应的配置文件:
                    export ANDROID_HOME=~/Library/Android/sdk
                    然后使用下列命令使其立即生效（否则重启后才生效）：
                    source ~/.bash_profile
                    可以使用echo $ANDROID_HOME检查此变量是否已正确设置。
        推荐工具
            Watchman
                是Facebook提供的监视文件系统变更的工具，安装此工具可以提高开发时的性能（packager可以快速捕捉文件的变化从而实现实时刷新）。
                安装watchman还可以避免node的一个与文件监视有关的bug。

                在终端输入一下命令来编译并安装watchman:
                    git clone https://github.com/facebook/watchman.git
                    cd watchman
                    git checkout v4.5.0  # 这是本文发布时的最新版本，请自行选择更新的版本
                    ./autogen.sh
                    ./configure
                    make
                    sudo make install
            Flow
                是一个静态的js类型检测工具。你在很多示例中看到的奇奇怪怪的冒号问号，以及方法参数中像类型一样的写法，
                都是属于这个flow工具的语法。这一语法并不属于ES标准，只是Facebook自家的代码规范。
                所以新手可以直接跳过（即不需要安装这一工具，也不建议去费力学习flow相关语法）。
                npm install -g flow-bin
            Gradle Daemon
                开启Gradle Daemon可以极大地提升java代码的增量编译速度。
                touch ~/.gradle/gradle.properties && echo "org.gradle.daemon=true" >> ~/.gradle/gradle.properties
            Android模拟器加速器
                如果你的系统支持KVM，那就应该安装Intel的Android模拟器加速器。
            将Android SDK的Tools目录添加到PATH变量中
                你可以把Android SDK的tools和platform-tools目录添加到PATH变量中，以便在终端中运行一些Android工具，例如android avd或是adb logcat等。
                在~/.bashrc或是~/.bash_profile文件中添加：
                # 你的具体路径可能有所不同，请自行确认。
                PATH="~/Android/Sdk/tools:~/Android/Sdk/platform-tools:${PATH}"
                export PATH
            Git
                sudo apt-get install git-all
            Nuclide
                Nuclide（此链接需要科学上网）是由Facebook提供的基于atom的集成开发环境，可用于编写、运行和 调试React Native应用。
                我们更推荐使用WebStorm或Sublime Text来编写React Native应用。
            Genymotion
                比起Android Studio自带的原装模拟器，Genymotion是一个性能更好的选择，但它只对个人用户免费。

                下载和安装Genymotion（genymotion需要依赖VirtualBox虚拟机，下载选项中提供了包含VirtualBox和不包含的选项，请按需选择）。
                打开Genymotion。如果你还没有安装VirtualBox，则此时会提示你安装。
                创建一个新模拟器并启动。
                启动React Native应用后，可以按下F1来打开开发者菜单。
        测试安装
            react-native init AwesomeProject
            cd AwesomeProject
            react-native run-android
      》iOS
        不支持
    1.3 macOS
        》Android
            必须软件
                Homebrew -- Mac系统的包管理器，用于安装Nodejs和一些其他必须的工具软件
                    /usr/bin/ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)"
                    注意：在Max OS X10.11版本中homebrew在安装软件时可能会碰到/usr/local目录不可写的权限问题。可以使用下面的命令修复：
                        sudo chown -R `whoami` /usr/local
                Node
                    brew install node
                    npm config set registry https://registry.npm.taobao.org --global
                    npm config set disturl https://npm.taobao.org/dist --global
                Yarn、React Native的命令行工具（react-native-cli）
                    npm install -g yarn react-native-cli
                    yarn config set registry https://registry.npm.taobao.org --global
                    yarn config set disturl https://npm.taobao.org/dist --global

                    如果你看到EACCES: permission denied这样的权限报错，那么请参照上文的homebrew译注，修复/usr/local目录的所有权：
                    sudo chown -R `whoami` /usr/local
                Android Studio
                    ANDROID_HOME环境变量
                        确保ANDROID_HOME环境变量正确地指向了你安装的Android SDK的路径。具体的做法是把下面的命令加入到~/.bash_profile文件中：
                        (译注：~表示用户目录，即/Users/你的用户名/，而小数点开头的文件在Finder中是隐藏的，并且这个文件有可能并不存在。请在
                        终端下使用vi ~/.bash_profile命令创建或编辑。）。
                        如果你的命令行不是bash，而是例如zsh等其他，请使用对应的配置文件。
                        export ANDROID_HOME=~/Library/Android/sdk

                        然后使用下列命令使其立即生效（否则重启后才生效）：
                        source ~/.bash_profile
                        可以使用echo $ANDROID_HOME检查此变量是否已正确设置。
            推荐安装工具
                Watchman
                    Watchman是由Facebook提供的监视文件系统变更的工具。安装此工具可以提高开发时的性能（packager可以快速捕捉文件的变化从而实现实时刷新）。译注：此工具官方虽然是推荐安装，
                    但在实践中，我们认为此工具是必须安装，否则可能无法正常开发。
                    brew install watchman
                Flow
                    Flow是一个静态的JS类型检查工具。译注：你在很多示例中看到的奇奇怪怪的冒号问号，以及方法参数中像类型一样的写法，都是属于这个flow工具的语法。这一语法并不属于ES标准，只是Facebook自家的代码规范。
                    所以新手可以直接跳过（即不需要安装这一工具，也不建议去费力学习flow相关语法）。
                    brew install flow
                将Android SDK的Tools目录添加到PATH变量中
                    你可以把Android SDK的tools和platform-tools目录添加到PATH变量中，以便在终端中运行一些Android工具，例如android avd或是adb logcat等。具体做法仍然是在~/.bash_profile中添加：
                    export PATH=$PATH:$ANDROID_HOME/tools:$ANDROID_HOME/platform-tools
                Git
                    brew install git
                Nuclide
                Genymotion
                Gradle Daemon
                    touch ~/.gradle/gradle.properties && echo "org.gradle.daemon=true" >> ~/.gradle/gradle.properties
            测试安装
                react-native init AwesomeProject
                cd AwesomeProject
                react-native run-android
        》iOS
            必须软件
                Homebrew
                    /usr/bin/ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)"
                Node
                    brew install node
                    npm config set registry https://registry.npm.taobao.org --global
                    npm config set disturl https://npm.taobao.org/dist --global
                Yarn、React Native的命令行工具（react-native-cli）
                    npm install -g yarn react-native-cli
                    yarn config set registry https://registry.npm.taobao.org --global
                    yarn config set disturl https://npm.taobao.org/dist --global
                Xcode
                    React Native目前需要Xcode 8.0 或更高版本。你可以通过App Store或是到Apple开发者官网上下载。这一步骤会同时安装Xcode IDE和Xcode的命令行工具。
                    虽然一般来说命令行工具都是默认安装了，但你最好还是启动Xcode，并在Xcode | Preferences | Locations菜单中检查一下是否装有某个版本的Command Line Tools。Xcode的命令行工具中也包含一些必须的工具，比如git等。
            推荐安装工具 -- 同上
2.Hello World
    React Native的基础组件是原生组件而非web组件。
    import React from 'react'
    import {Text} from 'react-native'
    class HelloWorldApp extends React.Component{
        render(){
            return <Text>Hello world !</Text>
        }
    }
    注意：React Native内置了对ES2015标准的支持，无需担心兼容问题。
3.Props属性
    大多数组件在创建时就可以使用各种参数来进行定制。用于定制的这些参数就称为props属性。
    如下面的source以及style：
    import React from 'react'
    import {AppRegistry,Image} from 'react-native'
    class Bananas extends React.Component{
        render(){
            let pic = {
                uri:'https://upload.wikimedia.org/wikipedia/commons/d/de/Bananavarieties.jpg'
            }

            return (
                <Image source={pic} style={ {width:193,height:110} }/>
            );
        }
    }
    AppRegistry.registerComponent('Bananas',() => Bananas);
    注意：iOS上http的问题：https://segmentfault.com/a/1190000002933776

    自定义的组件也可以使用props。通过在不同场景使用不同的属性定制，可以尽量提高自定义组件的复用范畴。
    import React from 'react'
    import {AppRegistry,Text,View} from 'react-native'
    class Greeting extends React.Component{
        render(){
            return (
                <Text>Hello {this.props.name}</Text>
            );
        }
    }

    class LotsOfGreetings extends React.Component{
        render(){
            return (
                //View组件常常用作其他组件的容器，来帮助控制布局和样式
                <View style={ {alignItems:'center'} }>
                    <Greeting name='Rexxar'/>
                </View>
            );
        }
    }
    AppRegistry.registerComponent('LotsOfGreetings',() => LotsOfGreetings);
4.State状态
    使用两种数据来控制一个组件：props和state。props是在父组件中指定，而且一经指定，在被指定的组件的生命周期中则不再改变。
    对于需要改变的数据我们需要使用state。
    import React from 'react'
    import {AppRegistry,Text,View} from 'react-native'
    class Blink extends Component{
        constructor(props){
            super(props);
            this.state = {showText:true}

            setInterval( () => {
                this.setState(previousState => {
                    return {showText:!previousState.showText}
                })
            },1000);
        }

        render(){
            let display = this.state.showText ? this.props.text : '';

            return (
                <Text>{display}</Text>
            );
        }
    }
    class BlinkApp extends React.Component{
        render(){
            return (
                <View>
                    <Blink text='I love to blink'/>
                </View>
            );
        }
    }
    AppRegistry.registerComponent('BlinkApp',() => BlinkApp);
5. 样式
    在React Native中，你并不需要学习什么特殊的语法来定义样式。我们仍然是使用JS来写样式。所有的核心组件都接受名为style的
    属性，这些样式名基本上是遵循web上的css的命名，只是按照JS的语法要求使用驼峰命名法，如将background-color改为backgroundColor。

    style属性可以是一个普通的js对象。也可以传入一个数组--在数组中位置居后的样式对象比居前的优先级更高，这样可以间接实现样式的继承。

    在实际开发中组件的样式会越来越复杂，建议使用StyleSheet.create来集中定义组件的样式。
    import React from 'react'
    import {AppRegistry,StyleSheet,Text,View} from 'react-native'

    class LotsOfStyles extends React.Component{
        render(){
            return (
                <View>
                    <Text style={styles.red}>just red</Text>
                    <Text style={styles.bigblue}>just bigblue</Text>
                    <Text style={[styles.bigblue, styles.red]}>bigblue, then red</Text>
                    <Text style={[styles.red, styles.bigblue]}>red, then bigblue</Text>
                </View>
            );
        }
    }

    const styles = StyleSheet.create({
        bigblue:{
            color:'blue',
            fontWeight:'bold',
            fontSize:30
        },
        red:{
            color:'red'
        }
    });
    AppRegistry.registerComponent('LotsOfStyles',() => LotsOfStyles);
6.高度和宽度
    组件的高度和宽度决定了其在屏幕上显示的尺寸。
    指定宽高：
        最简单的给组件设定尺寸的方式就是在样式中指定固定的width和height。React Native中的尺寸都是无单位的，表示的是与
        设备像素密度无关的逻辑像素点。
        import React from 'react'
        import {AppRegistry,View} from 'react-native'
        class FixedDimensionsBasics extends Component {
            render(){
                return (
                    <View>
                        <View style={{width: 50, height: 50, backgroundColor: 'powderblue'}} />
                    </View>
                );
            }
        }
        //注册应用registerComponent后才能正确渲染，只把应用作为一个整体注册一次，而不是每个组件/模块都注册
        AppRegistry.registerComponent('AwesomeProject', () => FixedDimensionsBasics);
        //上面给组件设置尺寸是一种常见的模式，比如要求在不同尺寸的屏幕上都显示成一样的大小。
    弹性Flex宽高：
        在组件样式中使用flex可以使其在可利用的空间中动态地扩展或收缩，一般而言我们会使用flex:1来指定某个组件扩展以撑满
        所有剩余的空间，如果有多个并列的子组件使用了flex:1,则这些子组件会评分父容器中剩余的空间。如果这些并列的子组件的
        flex值不一样，则谁的值更大，谁占据剩余空间的比例就更大（即占据剩余空间的比等于并列组件间flex值的比）。

        组件能够撑满剩余空间的前提是其父容器的尺寸不为零。如果父容器即没有固定的width和height也没有设定flex，则父容器的尺寸为零。
        其子组件如果使用flex也是无法显示的。
        import React, { Component } from 'react';
        import { AppRegistry, View } from 'react-native';

        class FlexDimensionsBasics extends Component {
          render() {
            return (
              <View style={{flex: 1}}>
                <View style={{flex: 1, backgroundColor: 'powderblue'}} />
                <View style={{flex: 2, backgroundColor: 'skyblue'}} />
                <View style={{flex: 3, backgroundColor: 'steelblue'}} />
              </View>
            );
          }
        };

        AppRegistry.registerComponent('AwesomeProject', () => FlexDimensionsBasics);
7.使用Flexbox布局
    在React Native中使用flexbox规则来指定某个组件的子元素的布局。Flexbox可以在不同屏幕尺寸上提供一致的布局结构。
    一般来说使用flexDirection、alignItems、justifyContent三个样式属性就已经满足大多数布局需求。

    React Native中的Flexbox的工作原理和web上的CSS基本一致，当然也存在少许差异。首先是默认值不同：
    flexDirection的默认值是column而不是row，而flex也只能指定一个数字值。

    》Flex Direction
        在组件的style中指定flexDirection可以决定布局的主轴。子元素是应该沿着水平轴(row)方向排列还是沿着竖直轴(column)方向
        排列。默认是竖直轴(column)方向。
        import React from 'react'
        import {AppRegistry,View} from 'react-native'
        class FlexDirectionBasics extends React.Component{
            render(){
                return (
                    <View style={ {flex:1,flexDirection:"row"} }>
                        <View style={{width: 50, height: 50, backgroundColor: 'powderblue'}} />
                        <View style={{width: 50, height: 50, backgroundColor: 'skyblue'}} />
                        <View style={{width: 50, height: 50, backgroundColor: 'steelblue'}} />
                    </View>
                );
            }
        }
        AppRegistry.registerComponent('AwesomeProject', () => FlexDirectionBasics);
    》Justify Content
        在组件的style中指定justifyContent可以决定其子元素沿着主轴的排列方式。子元素是应该靠近主轴的起始端还是末尾段，亦或者均匀分布
        对应的值：flex-start、center、flex-end、space-around以及space-between。
        import React, { Component } from 'react';
        import { AppRegistry, View } from 'react-native';

        class JustifyContentBasics extends Component {
          render() {
            return (
              // 尝试把`justifyContent`改为`center`看看
              // 尝试把`flexDirection`改为`row`看看
              <View style={{
                flex: 1,
                flexDirection: 'column',
                justifyContent: 'space-between',
              }}>
                <View style={{width: 50, height: 50, backgroundColor: 'powderblue'}} />
                <View style={{width: 50, height: 50, backgroundColor: 'skyblue'}} />
                <View style={{width: 50, height: 50, backgroundColor: 'steelblue'}} />
              </View>
            );
          }
        };

        AppRegistry.registerComponent('AwesomeProject', () => JustifyContentBasics);
    》Align Items
        在组件的style中指定alignItems可以决定其子元素沿着次轴(与主轴垂直的轴，如主轴方向是row 则次轴方向为column)的排列方式。
        子元素是应该靠近次轴的起始端还是末尾段亦或者均匀分布：flex-start、center、flex-end以及stretch。
        注意：要是stretch选项生效的话，子元素在次轴方向上不能有固定的尺寸。
        import React, { Component } from 'react';
        import { AppRegistry, View } from 'react-native';

        class AlignItemsBasics extends Component {
          render() {
            return (
              // 尝试把`alignItems`改为`flex-start`看看
              // 尝试把`justifyContent`改为`flex-end`看看
              // 尝试把`flexDirection`改为`row`看看
              <View style={{
                flex: 1,
                flexDirection: 'column',
                justifyContent: 'center',
                alignItems: 'center',
              }}>
                <View style={{ height: 50, backgroundColor: 'powderblue'}} />
                <View style={{ height: 50, backgroundColor: 'skyblue'}} />
                <View style={{ height: 50, backgroundColor: 'steelblue'}} />
              </View>
            );
          }
        };

        AppRegistry.registerComponent('AwesomeProject', () => AlignItemsBasics);
8.处理文本输入
    TextInput是一个允许用户输入文本的基础组件，它有一个名为onChangeText的属性，此属性接受一个函数，而此函数会在文本变化时
    被调用。另外还有一个名为onSubmitEditing的属性，会在文本被提交时(用户按下软键盘上的提交键)调用。
    //如实时翻译单词
    import React from 'react'
    import {AppRegistry,Text,TextInput,View} from 'react-native';

    class PizzaTranslator extends React.Component{
        constructor(props){
            super(props);
            this.state = {text:''}
        }

        render(){
            return (
                <View style={{padding:10}}>
                    <TextInput
                        style={{height:40}}
                        placeholder='Type here to translate!'
                        onChangeText={
                            text => this.State({text})
                        }
                    />
                    <Text style={ {padding:10,fontSize:42} }>
                        {this.state.text.split(' ').map(
                            word => word && '🍕'
                        ).join(' ')}
                    </Text>
                </View>
            );
        }
    }
    AppRegistry.registerComponent('PizzaTranslator', () => PizzaTranslator);
9.如何使用滚动视图
    ScrollView是一个通用的可滚动的容器，你可以在其中放入多个组件和视图，而且这些组件并不需要是同类型的。ScrollView不仅
    可以垂直滚动，还能水平滚动，通过horizontal属性来设置。
    //创建一个垂直滚动的ScrollView
    import React, { Component } from 'react';
    import{ AppRegistry, ScrollView, Image, Text, View } from 'react-native'

    class IScrolledDownAndWhatHappenedNextShockedMe extends Component {
      render() {
          return(
            <ScrollView>
              <Text style={{fontSize:96}}>Scroll me plz</Text>
              <Image source={require('./img/favicon.png')} />
              <Image source={require('./img/favicon.png')} />
              <Image source={require('./img/favicon.png')} />
              <Image source={require('./img/favicon.png')} />
              <Image source={require('./img/favicon.png')} />
              <Text style={{fontSize:96}}>If you like</Text>
              <Image source={require('./img/favicon.png')} />
              <Image source={require('./img/favicon.png')} />
              <Image source={require('./img/favicon.png')} />
              <Image source={require('./img/favicon.png')} />
              <Image source={require('./img/favicon.png')} />
              <Text style={{fontSize:96}}>Scrolling down</Text>
              <Image source={require('./img/favicon.png')} />
              <Image source={require('./img/favicon.png')} />
              <Image source={require('./img/favicon.png')} />
              <Image source={require('./img/favicon.png')} />
              <Image source={require('./img/favicon.png')} />
              <Text style={{fontSize:96}}>What's the best</Text>
              <Image source={require('./img/favicon.png')} />
              <Image source={require('./img/favicon.png')} />
              <Image source={require('./img/favicon.png')} />
              <Image source={require('./img/favicon.png')} />
              <Image source={require('./img/favicon.png')} />
              <Text style={{fontSize:96}}>Framework around?</Text>
              <Image source={require('./img/favicon.png')} />
              <Image source={require('./img/favicon.png')} />
              <Image source={require('./img/favicon.png')} />
              <Image source={require('./img/favicon.png')} />
              <Image source={require('./img/favicon.png')} />
              <Text style={{fontSize:80}}>React Native</Text>
            </ScrollView>
        );
      }
    }
    AppRegistry.registerComponent(
      'IScrolledDownAndWhatHappenedNextShockedMe',
      () => IScrolledDownAndWhatHappenedNextShockedMe);

    ScrollView适合用来显示数量不多的滚动元素。放置在ScrollView中的所有组件都会被渲染，哪怕有些组件因为内容太长被挤出了
    屏幕外。如果你需要实现较长的滚动列表，那么应该使用功能差不多但性能更好的ListView组件。
10. 如何使用长列表
    React Native提供了几个适用于展示长列表数据的组件，一般而言我们会选用FlatList或SectionList。

    FlatList组件用于显示一个垂直的滚动列表，其中的元素之间结构近似而仅数据不同。

    FlatList更适用于长列表数据且元素个数可以增删和ScrollView不同的是FlatList并不立即渲染所有元素，而是优先渲染屏幕上可见的元素。

    FlatList组件必须的两个属性是data和renderItem。data是列表的数据元素，而renderItem是从数据源中逐个解析数据然后返回一个设定好
    格式的组件来渲染。
    //案例
    import React from 'react';
    import {AppRegistry,FlatList,StyleSheet,Text,View} from 'react-native'
    export default class FlatListBasics extends React.Component{
        render(){
            return (
                <View style={styles.container}>
                    <FlatList
                        data={[
                            {key: 'Devin'},
                            {key: 'Jackson'},
                            {key: 'James'},
                            {key: 'Joel'},
                            {key: 'John'},
                            {key: 'Jillian'},
                            {key: 'Jimmy'},
                            {key: 'Julie'},
                        ]}
                        renderItem = { {item} => <Text style={ styles.item }>{item.key}</Text>}
                    />
                </View>
            );
        }
    }
    const styles = StyleSheet.create({
      container: {
       flex: 1,
       paddingTop: 22
      },
      item: {
        padding: 10,
        fontSize: 18,
        height: 44,
      },
    })

    AppRegistry.registerComponent('AwesomeProject', () => FlatListBasics);

    //SectionList
    import React from 'react'
    import {AppRegistry,SectionList,StyleSheet,Text,View} from 'react-native'
    export default class SectionListBasics extends React.Component{
        render(){
            return (
                <View style={styles.container}>
                    <SectionList
                        sections={
                          [
                            {title: 'D', data: ['Devin']},
                            {title: 'J', data: ['Jackson', 'James', 'Jillian', 'Jimmy', 'Joel', 'John', 'Julie']},
                          ]
                        }
                        renderItem = { {item}=> <Text style={styles.item}>{item}</Text>}
                        renderSectionHeader={ {section} => <Text style={styles.sectionHeader}>{section.title}</Text>}
                    />
                </View>
            );
        }
    }
    const styles = StyleSheet.create({
      container: {
       flex: 1,
       paddingTop: 22
      },
      sectionHeader: {
        paddingTop: 2,
        paddingLeft: 10,
        paddingRight: 10,
        paddingBottom: 2,
        fontSize: 14,
        fontWeight: 'bold',
        backgroundColor: 'rgba(247,247,247,1.0)',
      },
      item: {
        padding: 10,
        fontSize: 18,
        height: 44,
      },
    })

    AppRegistry.registerComponent('AwesomeProject', () => SectionListBasics);
11.网络
    使用Fetch
        React Native提供了和web标准一致的Fetch API，用于满足开发者访问网络的需求。
        发起网络请求：
            fetch('https://mywebsite.com/mydata.json')
            fetch的可选第二个参数：
            fetch('https://mywebsite.com/endpoint/', {
              method: 'POST',
              headers: {
                'Accept': 'application/json',
                'Content-Type': 'application/json',
              },
              body: JSON.stringify({
                firstParam: 'yourValue',
                secondParam: 'yourOtherValue',
              })
            })
            //如果服务器无法识别上面POST的数据格式，可以使用传统的form格式
            fetch('https://mywebsite.com/endpoint/', {
              method: 'POST',
              headers: {
                'Content-Type': 'application/x-www-form-urlencoded',
              },
              body: 'key1=value1&key2=value2'
            })
        处理服务器的响应数据：
            getMoviesFromApiAsync() {
                return fetch('https://facebook.github.io/react-native/movies.json')
                  .then((response) => response.json())
                  .then((responseJson) => {
                    return responseJson.movies;
                  })
                  .catch((error) => {
                    console.error(error);
                  });
              }
              //使用ES7的语法 async /await
              async getMoviesFromApi(){
                try{
                    let response = await fetch('https://facebook.github.io/react-native/movies.json');
                    let responseJSON = await response.json();

                    return responseJSON.movies;
                }catch(error){
                    console.error(error)
                }
              }
            注意：iOS默认会阻止所有非https得请求。https://segmentfault.com/a/1190000002933776
    使用其他的网络库
        React Native已经内置了ajax(XMLHttpRequest)。一些基于ajax封装的第三方库也是可以使用的如：frisbee或axios等。
        但注意不能不使用jquery，因为jquery中还使用了很多浏览器才有而RN没有的东西。即不是所有web中的
        ajax库都可以直接使用。
        var request = new XMLHttpRequest();
        request.onreadystatechange = (e) => {
          if (request.readyState !== 4) {
            return;
          }

          if (request.status === 200) {
            console.log('success', request.responseText);
          } else {
            console.warn('error');
          }
        };

        request.open('GET', 'https://mywebsite.com/endpoint/');
        request.send();
        注意：安全机制与网页环境有所不同：在应用中你可以访问任何网站没有跨域的限制。
    WebSocket支持
        React Native还支持WebSocket，这种协议可以在单个TCP连接上提供全双工的通信信道。
        var ws = new WebSocket('ws://host.com/path');

        ws.onopen = () => {
          // 打开一个连接

          ws.send('something'); // 发送一个消息
        };

        ws.onmessage = (e) => {
          // 接收到了一个消息
          console.log(e.data);
        };

        ws.onerror = (e) => {
          // 发生了一个错误
          console.log(e.message);
        };

        ws.onclose = (e) => {
          // 连接被关闭了
          console.log(e.code, e.reason);
        };
12.其他参考资源
    常用的第三方库：
        https://github.com/reactnativecn/react-native-guide
        https://github.com/jondot/awesome-react-native
    示例应用
        https://github.com/fbsamples/f8app
        https://f8-app.liaohuqiu.net/#content
    开发工具
        Nuclide
        Lgnite
        CodePush(Pushy) -- 热更新
        Exponent
        Deco
13. 集成到现有原生应用
    》Android
        把React Native组件集成到Android应用中的步骤：
        //了解要集成的React Native组件
        //在Android项目根目录中使用npm安装react-native
        //创建js文件编写React Native组件的js代码
        //在build.gradle文件中添加com.facebook.react:react-native:+，
          以及一个指向node_nodules/目录中的react-native预编译库的maven路径
        //创建一个React Native专属的Activity，在其中再创建ReactRootView
        //启动React Native的Packager服务，运行应用。
        //根据需要添加更多React Native的组件。
        //在真机上运行、调试。
        //打包。

        开发环境准备：
        1.安装React Native在安卓平台上所需依赖
        2.设置项目目录结构
            在其中创建一个/android子目录，把现有的Android项目拷贝到该目录中
        3.安装js依赖包
            创建package.json
            {
              "name": "MyReactNativeApp",
              "version": "0.0.1",
              "private": true,
              "scripts": {
                //启动packager服务的命令
                "start": "node node_modules/react-native/local-cli/cli.js start"
              },
              "dependencies": {
                //react native对react版本有要求 注意安装过程的错误提示
                "react": "16.0.0-alpha.6",
                "react-native": "0.44.3"
              }
            }
            //执行npm install
        把React Native添加到你的应用中
        1.配置maven
            在app中的build.gradle文件中添加React Native依赖：
            dependencies {
                 ...
                 //如果想要指定特定的React Native版本，可以用具体的版本号替换+ 前提是npm里面下载了这个版本
                 compile "com.facebook.react:react-native:+" // From node_modules.
             }

             在项目的build.gradle文件中为React Native添加一个maven依赖的入口，必须写在'allprojects'代码块中：
             allprojects {
                 repositories {
                     ...
                     maven {
                         // All of React Native (JS, Android binaries) is installed from npm
                         //确保依赖路径的正确以免在 Android Studio 运行Gradle同步构建时抛出 “Failed to resolve: com.facebook.react:react-native:0.x.x" 异常。
                         url "$rootDir/../node_modules/react-native/android"
                     }
                 }
                 ...
             }
        配置权限
            接着再AndroidManifest.xml清单文件中声明网络权限：
            <uses-permission android:name="android.permission.INTERNET" />
            如果需要访问DevSettingsActivity 界面(即开发者菜单)，则还需要再AndroidManifest.xml中声明：
            //开发者菜单一般仅用于在开发时从Packager服务器刷新JavaScript代码，所以在正式发布时你可以去掉这一权限。
            <activity android:name="com.facebook.react.devsupport.DevSettingsActivity" />
        代码集成
            1.React Native组件
                //创建一个index.js文件(入口文件) 注意在0.49版本之前是index.android.js文件

                //在index.js中添加自己的组件
                import React from 'react';
                import {
                  AppRegistry,
                  StyleSheet,
                  Text,
                  View
                } from 'react-native';

                class HelloWorld extends React.Component {
                  render() {
                    return (
                      <View style={styles.container}>
                        <Text style={styles.hello}>Hello, World</Text>
                      </View>
                    )
                  }
                }
                var styles = StyleSheet.create({
                  container: {
                    flex: 1,
                    justifyContent: 'center',
                  },
                  hello: {
                    fontSize: 20,
                    textAlign: 'center',
                    margin: 10,
                  },
                });

                AppRegistry.registerComponent('MyReactNativeApp', () => HelloWorld);

                //配置权限以便于开发中的红屏错误能正确显示
                如果你的应用会运行在Android6.0(API level23)或更高版本，请确保在开发版本中有打开悬浮窗(overlay)权限。
                你可以在代码中使用Settings.canDrawOverlays(this);来检测。之所以需要这个权限，是因为我们会把开发中的报错
                显示在悬浮窗中(仅在开发阶段需要)。在Android 6.0（API level 23）中用户需要手动同意授权。具体请求授权的做法是
                在onCreate()中添加如下代码。其中OVERLAY_PERMISSION_REQ_CODE是用于回传授权结果的字段。
                if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
                    if (!Settings.canDrawOverlays(this)) {
                        Intent intent = new Intent(Settings.ACTION_MANAGE_OVERLAY_PERMISSION,
                                                   Uri.parse("package:" + getPackageName()));
                        startActivityForResult(intent, OVERLAY_PERMISSION_REQ_CODE);
                    }
                }

                最终onActivityResult()必须被覆盖用于处理用户的授权情况
                @Override
                protected void onActivityResult(int requestCode, int resultCode, Intent data) {
                    if (requestCode == OVERLAY_PERMISSION_REQ_CODE) {
                        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
                            if (!Settings.canDrawOverlays(this)) {
                                // SYSTEM_ALERT_WINDOW permission not granted...
                            }
                        }
                    }
                }
            2.ReactRootView
                还需要添加一些原生代码来启动React Native的运行时环境并让它开始渲染。首先需要在一个Activity中创建一个
                ReactRootView对象，然后再这个对象中启动React Native应用并将它设为界面的主视图
                如果你想在安卓5.0以下的系统上运行，请用 com.android.support:appcompat 包中的 AppCompatActivity 代替 Activity 。
                public class MyReactActivity extends Activity implements DefaultHardwareBackBtnHandler {
                    private ReactRootView mReactRootView;
                    private ReactInstanceManager mReactInstanceManager;

                    @Override
                    protected void onCreate(Bundle savedInstanceState) {
                        super.onCreate(savedInstanceState);

                        mReactRootView = new ReactRootView(this);
                        mReactInstanceManager = ReactInstanceManager.builder()
                                .setApplication(getApplication())
                                .setBundleAssetName("index.android.bundle")
                                .setJSMainModuleName("index.android")
                                .addPackage(new MainReactPackage())
                                .setUseDeveloperSupport(BuildConfig.DEBUG)
                                .setInitialLifecycleState(LifecycleState.RESUMED)
                                .build();

                        // 注意这里的MyReactNativeApp必须对应“index.android.js”中的
                        // “AppRegistry.registerComponent()”的第一个参数
                        mReactRootView.startReactApplication(mReactInstanceManager, "MyReactNativeApp", null);

                        setContentView(mReactRootView);
                    }

                    @Override
                    public void invokeDefaultOnBackPressed() {
                        super.onBackPressed();
                    }
                }

                //我们需要把MyReactActivity的主题设定为Theme.AppCompat.Light.NoActionBar，因为里面有许多组件都使用了这个主题。
                <activity
                   android:name=".MyReactActivity"
                   android:label="@string/app_name"
                   android:theme="@style/Theme.AppCompat.Light.NoActionBar">
                 </activity>

                具体查看文档
    》Swift
    》Objective-C
14.使用导航器跳转页面
    React Native中现有的几个导航组件。如果你刚开始接触那么直接选择React Navigation 。如果你只针对iOS平台开发，并且想和系统原生
    外观一致，那么可以选择NavigatorIOS。你还可能在很多地方听过Navigator，这个老组件会逐步被React Navigation替代。但是它经历过
    长期的实践，较为稳定。过去还有一个实验性的导航器组件NavigationExperimental，这个组件已经完全弃用。
    注意：
        从.44版本开始，Navigator被从react native的核心组件库中剥离到react-native-deprecated-custom-components的单独模块中。如果
        你需要使用Navigator则需要先yarn add react-native-deprecated-custom-components安装，然后从这个模块中import，即import {
        Navigator } from 'react-native-deprecated-custom-components'
    》React Navigation
        社区今后主推的方案是一个单独的导航库react-navigation，它的使用十分简单。
        先安装此库：yarn add react-navigation

        案例：
        import React,{Component} from 'react'
        import {View,Text,Button} from 'react-native'
        import {StackNavigator} from 'react-navigation'

        /**
         * 其中每个screen组件都可以单独设置导航头选项 如：导航头的标题 还可以使用navigation属性中的方法跳转到别的页面
         */

        class MainComponent extends React.Component {
            //设置导航头选项
            static navigationOptions = {
                title: '主页',
            };

            render() {
                const { navigate } = this.props.navigation;
                return (
                    <View>
                        <Text>主页</Text>
                        <Button
                            title="Go to Jane's profile"
                            //跳转到其他页面
                            onPress={() => navigate('Profile', { name: 'Jane' }) }
                        />
                    </View>
                );
            }
        }

        class ProfileComponent extends React.Component {
            static navigationOptions = {
                title: '个人页',
            };
            render() {
                const { navigate } = this.props.navigation;
                return <Text>profile</Text>
            }
        }


        const App = StackNavigator({
            Main:{screen:MainComponent},
            Profile:{screen:ProfileComponent}
        });

        class NavigationTest extends Component{

            render(){

                return <App/>
            }
        }

        export default NavigationTest
        //React Navigation的路由写法使其非常容易扩展导航逻辑，或者整合到redux中。由于路由可以嵌套使用，因而开发者可以根据不同页面编写不同
        //的导航逻辑且彼此互不影响。

        //React Navigation中的视图是原生组件，同时用到了运行在原生线程上的Animated动画库，因此性能表现十分流畅。此外其动画形式和手势都非常便于
        //定制。

        》其文档 https://reactnavigation.org/docs/intro/
            》介绍
                React Navigation源自于React Native社区，基于js的可扩展且易于使用的导航解决方案。
                React Navigation是来自于Facebook ，Expo和React社区的开发者之间的合作结果：它取代并改进了生态系统中的多个导航库，包括
                Ex-Navigation,React Native的Navigator和NavigationExperimental组件。
            》快速入门
                》安装
                    npm: npm install --save react-navigation
                    yarn:yarn add react-navigation
                》注意
                    要开始使用React Navigation，必须创建一个导航器。React Navigation带有三个默认的导航器。
                    StackNavigator -- 为您的应用程序在每个**新屏幕顶部**的屏幕之间的切换
                    TabNavigator -- 用于设置多个选项卡的屏幕
                    DrawerNavigator -- 用于设置带抽屉导航的屏幕
                》创建一个StackNavigator
                    StackNavigator是最常见的导航形式。
                    案例：
                       import React from 'react'
                       import {View,Text,Button} from 'react-native'
                       import {StackNavigator} from 'react-navigation'

                       /**
                        * 创建每屏视图
                        */
                       const HomeScreen = ({navigation}) => (
                           <View style={{flex:1,alignItems:'center',justifyContent:'center'}}>
                               <Text>Home Screen</Text>
                               {/*从主屏幕导航到详细信息屏幕*/}
                               {/*当你使用导航器注册一个组件时，组件会添加一个道具。这个道具驱动我们如何在不同的屏幕之间移动。navigation.navigate*/}
                               <Button
                                   onPress={ () => navigation.navigate('Detail')}
                                   title="Go to detail"
                               />
                           </View>
                       );

                       const DetailScreen = () => (
                           <View style={{flex:1,alignItems:'center',justifyContent:'center'}}>
                               <Text>Details Screen</Text>
                           </View>
                       );

                       //创建StackNavigator
                       const RootNavigator = StackNavigator({
                           //为每屏添加试图组件
                           Home:{
                               screen:HomeScreen,
                               //添加导航标题
                               navigationOptions:{
                                   headerTitle:'home'
                               }
                           },
                           Detail:{
                               screen:DetailScreen,
                               navigationOptions:{
                                   headerTitle:'Detail'
                               }
                           }
                       });

                       export default RootNavigator
                》创建一个TabNavigator
                    //添加图标 npm install react-native-vector-icons 或yarn add react-native-vector-icons
                    import React from 'react'
                    import {View,Text} from 'react-native'
                    import {TabNavigator} from 'react-navigation'
                    import Ionicons from 'react-native-vector-icons/Ionicons'

                    const HomeScreen = () => (
                        <View style={ {flex:1,alignItems:'center',justifyContent:'center'} }>
                            <Text>Home Screen</Text>
                        </View>
                    );

                    const ProfileScreen = () => (
                        <View style={ {flex:1,alignItems:'center',justifyContent:'center'} }>
                            <Text>Profile Screen</Text>
                        </View>
                    );

                    //创建TabNavigator
                    const RootTabs = TabNavigator({
                        Home:{
                            screen:HomeScreen,
                            navigationOptions:{
                                tabBarLabel:'Home',
                                //添加图标
                                tabBarIcon: ({tintColor,focused}) => (
                                    <Ionicons name={ focused ? 'ios-home' : 'ios-home-outline'} size={26} style={{color:tintColor}}/>
                                )
                            }
                        },
                        Profile:{
                            screen:ProfileScreen,
                            navigationOptions:{
                                tabBarLabel:'Profile',
                                tabBarIcon:({tintColor,focused}) => (
                                    <Ionicons
                                        name={focused ? 'ios-person' : 'ios-person-outline'}
                                        size={26}
                                        style={{color:tintColor}}
                                    />
                                )
                            }
                        }
                    });

                    export default RootTabs
                》DrawerNavigator
                    import React from 'react'
                    import {DrawerNavigator} from 'react-navigation'
                    import {View,Text,Button} from 'react-native'
                    import Ionicons from 'react-native-vector-icons/Ionicons'

                    const HomeScreen = ({navigation}) => (
                        <View style={{flex:1,alignItems:'center',justifyContent:'center'}}>
                            <Text>Home Screen</Text>
                            {/*要打开抽屉，可以从屏幕左边缘向右滑动，也可以用代码实现*/}
                            <Button title="Open Drawer" onPress={() => navigation.navigate('DrawerToggle')}/>
                        </View>
                    );

                    const ProfileScreen = () => (
                        <View style={{flex:1,alignItems:'center',justifyContent:'center'}}>
                            <Text>Profile Screen</Text>
                        </View>
                    );


                    //创建
                    const RootDrawer = DrawerNavigator({
                        Home:{
                            screen:HomeScreen,
                            navigationOptions:{
                                drawerLabel:'主页',
                                drawerIcon: ({tintColor,focused}) => (<Ionicons name={focused ? 'ios-home' : 'ios-home-outline'} size={20} style={{color:tintColor}}/>)
                            }
                        },
                        Profile:{
                            screen:ProfileScreen,
                            navigationOptions:{
                                drawerLabel:'个人',
                                drawerIcon: ({tintColor,focused}) => (<Ionicons name={focused ? 'ios-person' : 'ios-person-outline'} size={20} style={{color:tintColor}}/>)
                            }
                        }
                    });

                    export default RootDrawer
            》Hello Mobile导航
                》设置和安装
                    react-native init SimpleApp
                    cd SimpleApp
                    npm install --save react-navigation
                    react-native run-android || react-native run-ios

                    或
                    create-react-native-app SimpleApp
                    cd SimpleApp
                    npm install --save react-navigation
                    npm start
                》StackNavigation

                》传递参数
                    navigate除了导航功能指定目标外，我们还可以将传递的参数放入其中。
                    onPress={() => navigate('Chat', { user: 'Lucy' })}

                》案例
                    import React from 'react'
                    import {Text,View,Button} from 'react-native'
                    import {StackNavigator} from 'react-navigation'

                    class HomeScreen extends React.Component{
                        static navigationOptions = {
                            title:'Welcome'
                        }

                        render(){
                            const {navigate} = this.props.navigation;

                            return (

                                <View>
                                    <Text>Hello,Navigation!</Text>
                                    {/*传递参数*/}
                                    <Button title="Chat with Lucy" onPress={ () => navigate('Chat',{user:'Lucy'})}/>
                                </View>
                            )
                        }
                    }

                    class ChatScreen extends React.Component{
                        static navigationOptions = {
                            title:'Chat with Lucy'
                        }

                        render(){
                            //获取参数
                            const {params} = this.props.navigation.state;

                            return <View>
                                <Text>Chat with {params.user}</Text>
                            </View>
                        }
                    }

                    export default SimpleApp = StackNavigator({
                        Home:{
                            screen:HomeScreen
                        },
                        Chat:{
                            screen:ChatScreen
                        }
                    });
            》嵌套导航
                在移动应用中常见的是组合各种各样的导航。React Navigation中的路由和导航器是可组合的。这使得可以为应用定义复杂的导航结构。
                //NestNavigationTest -- children component
                import React ,{Component} from 'react'
                import {TabNavigator} from 'react-navigation'
                import {Text,View,Button} from 'react-native'

                class RecentChatsScreen extends Component{

                    render(){
                        const {params} = this.props.navigation.state;

                        return (
                            <View>
                                <Text>List of recent chats,from {params ? params.user : 'default'}</Text>
                                <Button title="Chat with Lucy" onPress={ () => this.props.navigation.navigate('Chat',{user:'Lucy'})}/>
                            </View>
                        );
                    }
                }

                class AllContactsScreen extends Component{

                    render(){
                        return (
                            <View>
                                <Text>List of all contacts</Text>
                                <Button title="to Recent" onPress={ () => this.props.navigation.navigate('Recent',{user:'all'})}/>
                            </View>
                        )
                    }
                }

                const MainScreenNavigator = TabNavigator({
                    Recent:{screen:RecentChatsScreen},
                    All:{screen:AllContactsScreen}
                });

                export default MainScreenNavigator

                //HelloNavigation -- parent component
                import React from 'react'
                import {Text,View,Button} from 'react-native'
                import {StackNavigator} from 'react-navigation'
                import NestNavigationTest from '../NestNavigationTest'

                class HomeScreen extends React.Component{
                    static navigationOptions = {
                        title:'Welcome'
                    }

                    render(){
                        const {navigate} = this.props.navigation;

                        return (

                            //避免导航器无法显示  给容器使用flex:1
                            <View style={{flex:1}}>
                                <Text>Hello,Navigation!</Text>
                                {/*传递参数*/}
                                <Button title="Chat with Lucy" onPress={ () => navigate('Chat',{user:'Lucy'})}/>

                                {/*在组件中嵌套导航器*/}
                                <NestNavigationTest navigation={this.props.navigation}/>
                            </View>
                        )
                    }
                }

                /**
                 * 在组件中嵌套导航器
                 *
                 * 为了把NestNavigationTest的导航链接到导航树上，我们需要把NestNavigationTest的router给HomeScreen的router。
                 * 这使得HomeScreen“导航感知”，即告诉父导航器将导航对象传递下去。由于HomeScreen的router被子组件NestNavigationTest的
                 * router覆盖，这个子组件将接受navigation props。
                 */
                HomeScreen.router = NestNavigationTest.router;

                class ChatScreen extends React.Component{
                    static navigationOptions = {
                        title:'Chat with Lucy'
                    }

                    render(){
                        //获取参数
                        const {params} = this.props.navigation.state;

                        return (
                            <View>
                                <Text>Chat with {params.user}</Text>
                            </View>
                        );
                    }
                }

                const SimpleApp = StackNavigator({
                    Home:{
                        screen:HomeScreen
                    },
                    Chat:{
                        screen:ChatScreen
                    }
                });

                //嵌套导航 -- 将导航器嵌套在屏幕中 该导航器内容将沾满整个屏幕 使用navigate切换视图
                const NestNavigation = StackNavigator({
                    Home:{
                        screen:NestNavigationTest,
                        navigationOptions:{
                            title:'My Chats'
                        }
                    },
                    Chat:{screen:ChatScreen}
                });

                /**
                 * 嵌套导航器 -- 在组件中嵌套导航器
                 *
                 * 有时候需要嵌套包装在组件中的导航器。该导航器只占有屏幕的一部分的情况下非常有用
                 *
                 * 为了将子导航器链接到导航树中，需要父导航器的属性navigation
                 */
                const NestNavigationComponent = StackNavigator({
                    Home:{
                        screen:HomeScreen
                    },
                    Chat:{screen:ChatScreen}
                });
                export default NestNavigationComponent
            》配置 Headers
                配置header仅适用于StackNavigator。

                》设置header title
                    class ChatScreen extends React.Component{
                        static navigationOptions = ({navigation}) => ({
                            title:'Chat with ${navigation.state.params.user}'
                        })
                    }
                》添加一个右边按钮
                    header的导航选项是允许我们添加一个自定义的右按钮的
                    static navigationOptions = {
                        headerRight:<Button title='Info'/>
                    }
                    //导航选项能够被navigation prop定义。
                    //根据route的params的不同来渲染不同的button，并且当button 被点击时执行navigation.setParams。
                    state navigationOptions = ({navigation}) => {
                        const {state,setParams} = navigation;
                        const isInfo = state.params.mode === 'info';
                        const {user} = state.params;

                        return {
                            title: isInfo ? `${user}'s Contact Info'` : `Chat with ${user}`,
                            headerRight:(
                                <Button title={isInfo ? 'Done' : `${user}'s info'`}
                                    onPress = { () => setParams({mode:isInfo ? 'none' : 'info'})}
                                />
                            )
                        }
                    }
                    //现在header就可以和路由state交互了
                》header和屏幕组件的交互
                    有时候，header需要访问屏幕组件的函数或state属性。
                    class EditInfoScreen extends React.Component{
                        static navigationOptions = ({navigation}) => {
                            const {params = {}} = navigation.state;
                            let headerRight = (
                                <Button
                                    title = 'Save'
                                    onPress = {params.handleSave ? params.handleSave : () => null}
                                />
                            );

                            if(params.isSaving) headerRight = <ActivityIndicator/>;

                            return {headerRight}
                        }

                        state={
                            nickname:'Lucy jacuzzi'
                        }

                        _handleSave = () => {
                            this.props.navigation.setParams({isSaving:true});

                            saveInfo().then( () => {
                                this.props.navigation.setParams(isSaving:false);
                            });
                        }

                        componentDidMount(){
                            this.props.navigation.setParams({handleSave:this._handleSave});
                        }

                        render(){
                            return <TextInput
                                onChangeText = {(nickname) => this.setState({nickname})}
                                placeholder={'Nickname'}
                                value={this.state.nickname}
                            />
                        }
                    }
                    //注意，由于param handleSave仅仅在组件挂载时设置，它不是立即可用的。因此handleSave被默认为空的函数从而避免组件
                    //渲染的闪烁。

                    作为一个可替代setParams的方案。你可以考虑使用state状态管理库如：Mobx或Redux。当导航到一个屏幕时，传递一个对象，
                    该对象包含要呈现的屏幕所需的数据，以及您可能想要调用的函数修改数据、发出网络请求等等。这样，您的屏幕组件和静态
                    的navbarOptions块都可以访问该对象。当遵循此方法时，请确保考虑深层链接，在只将javascript原语作为导航道具传递到屏
                    幕的情况下，这是最有效的。如果需要进行深度链接，您可以使用更高阶组件(HOC)将原语转换为屏幕组件所期望的对象。
            》Navigators
                Navigators允许你定义应用的导航结构，并且它还允许渲染可配置的相同元素，如：headers以及tab bars。
                其实，navigators只是普通的React 组件。
                》内置的Navigators
                    react-navigation包含了以下函数从而来帮你创建navigators：
                    》StackNavigator
                        一次渲染一个屏并提供屏幕切换之间的过渡。当一个新屏幕被打开时，它被放置在栈顶。
                    》TabNavigator
                        渲染一个标签栏，让用户在多个屏幕之间切换
                    》DrawerNavigator
                        提供一个从屏幕左侧滑动的抽屉。
                》用Navigators渲染屏幕
                    这个navigators渲染应用的屏幕仅仅是React组件。
                    要了解怎样创建屏幕需要学习：
                    》屏幕的navigation prop -- 允许屏幕分发导航操作 如：打开应用的其他屏
                    》屏幕的navigationOptions -- 自定义navigator的呈现 如：header的title tab的label。
                》在顶层组件调用 Navigate
                    如果你想使用同一级别的navigator，你可以使用ref属性声明。
                    import {NavigationActions} from 'react-navigation'
                    const AppNavigator = StackNavigator(SomeAppRouteConfigs);
                    class App extends React.Component{
                        someEvent(){
                            this.navigator && this.navigator.dispatch(
                                NavigationActions.navigate({routeName:someRouteName});
                            );
                        }

                        render(){
                            <AppNavigator ref={ nav => {this.navigator = nav}}/>
                        }
                    }
                    //注意：这个解决方案只能用在顶级导航器上。
                》navigation 容器
                    当navigation prop缺失时，内置的navigators能够自动的成为顶级navigators。这个功能提供了一个透明的navigation 容器，这就是
                    顶级navigation prop的来源。

                    当渲染一个包含navigators的组件时，navigation prop时可选的。当它缺失时，这个容器自动管理自己的navigation state，处理url、
                    外部链接和android 返回键等。

                    为了达到上面效果，这个内置navigators有上面功能。因为它们使用了createNavigationContainer。通常navigators需要一个navigation
                    prop才能运行。

                    顶级navigators接受下列属性：
                    onNavigationStateChange(prevState, newState, action);
                    这个函数在navigator state 改变时被调用。默认情况下会在控制台打印state的改变。
                    uriPrefix -- 应用的url前缀可能会被处理，这将在深层次的链接中用来提取router。
            》StackNavigator
                提供了一个方式使得应用从一个屏到新屏的过渡，新屏将被放置在栈顶。
                默认情况下StackNavigator被配置为iOS和android是相似的。在iOS中新屏从屏幕右侧滑入，android从底部进入屏幕。
                在iOS中StackNavigator也可以配置成新屏从底部滑入。

                案例：
                class MyHomeScreen extends React.Component{
                    static navigationOptions = {
                        title:'Home'
                    }

                    render(){
                        return (
                            <Button
                                onPress={ ()=> this.props.navigation.navigate('Profile',{name:'Lucy'})}
                                title="Go to Lucy's profile"
                            />
                        );
                    }
                }

                const ModalStack = StackNavigator({
                    Home:{
                        screen:MyHomeScreen
                    },
                    Profile:{
                        path:'people/:name',
                        screen:MyProfileScreen
                    }
                });


                》API解析
                    StackNavigator(RouteConfigs,StackNavigatorConfig);
                    》RouteConfigs
                        这个路由配置对象是从route的name 到 route的配置的一个映射，这将告诉navigator怎样呈现这个route。
                        {
                            //为每个可以导航到的screen，创建如下一样的入口。
                            Profile:{
                                screen:ProfileScreen,//ProfileScreen是React组件，这将是该屏的主要内容，当该组件被StackNavigator加载后，它将得到navigation prop。
                                path:'people/:name',//可选的 当深度链接或利用react-navigation在web应用中时，该属性被使用 。 可以提取route的action以及params。
                                navigationOptions:({navigation}) => ({//可选的 会覆盖屏幕本身的 navigationOptions
                                  title:`${navigation.state.params.name}'s Profile'`,
                                })
                            }
                        }
                    》StackNavigatorConfig
                        {
                            //router 选项
                            initialRouteName,//设置stack中的默认screen，必须是RouteConfigs的一个key
                            initialRouteParams,//初始化route的参数
                            navigationOptions,//所有屏幕的默认navigation options
                            paths,//覆盖RouteConfigs中设置的path的映射

                            //视觉 选项
                            mode,//定义渲染和过渡的样式 card(利用标准的iOS和android的屏幕过渡 默认值) modal(让屏幕从底部滑动，这是一个常见的iOS模式。只在iOS上运行，对Android无效。)
                            headerMode,//指定怎样渲染header ，其值如下：
                                》float 在屏幕更改时渲染保留在顶部的单个header和动画。这是iOS上的常见模式
                                》screen 每个屏幕都有一个header，header与屏幕一起淡入淡出。这是Android上的常见模式
                                》none 没有header将被渲染
                            cardStyle,//使用这个属性来覆盖或扩展stack中单个卡片的默认样式
                            transitionConfig:function(transitionProps,prevTransitionProps,isModal){//值为一个函数，并返回一个合并了默认屏过渡类型的对象
                                //transitionProps -- 新屏的过渡props
                                //prevTransitionProps -- 旧屏的过渡prop
                                //isModal -- Boolean  指定屏幕是否为modal
                            },
                            onTransitionStart，//当卡片过渡动画开始时调用的函数
                            onTransitionEnd//当卡片过渡动画结束时调用的函数
                        }
                    》navigationOptions属性
                        {
                            title,//String (StackNavigator中的headerTitle,TabNavigator中的tabBarLabel，DrawerNavigator中的drawerLabel中的备用)
                            header,//React Element 或 接受HeaderProps参数的函数，该函数返回React Element，用于显示header，如果需要隐藏header则设置为null
                            headerTitle,//String,React Element或React组件使用这个header，其默认值为title值。当一个组件被使用，它将接受allowFontScaling、style、children props，这个title字符串通过children传递
                            headerTitleAllowFontScaling,//headerTitle是否被缩放 默认true
                            headerBackTitle,//iOS上后退按钮的title字符串，如果为null表示不可用。默认为上一个屏幕的headerTitle
                            headerTruncatedBackTitle,//当headerBackTitle不适合于当前屏幕时的返回按钮的title字符串。默认'Back'
                            headerRight,//显示在header右边的React Element
                            headerLeft,//显示在header左边的React Element或组件 当一个组件被使用时，它将接收一些props 如：onPress title titleStyle等
                            headerStyle,//header的样式对象
                            headerTitleStyle,//title组件的样式对象
                            headerBackTitleStyle，//返回title的样式对象
                            headerTintColor,//header的颜色
                            headerPressColorAndroid,//点击header的颜色 仅仅android>=5.0支持
                            gesturesEnabled，//是否可以使用手势来消除此屏幕。在iOS上默认为true，在Android上为false。
                            gestureResponseDistance：{//手势识别的距离
                                horizontal： number - 水平方向的距离。默认为25。
                                vertical：number - 垂直方向的距离。默认为135
                            }，
                            gestureDirection ，//String 重置关闭手势的方向 default -- 正常的行为 inverted-- 从右到左滑动
                        }
                    》Navigator Props
                        通过StackNavigator(...)的方式创建的navigator组件有如下属性：
                        》screenProps -- 将额外的参数传递给子屏幕 如：
                            const SomeStack = StackNavigator({...});

                            <SomeStack screenProps={
                                //这个属性将被传递到screen组件中
                            }/>
            》TabNavigator
                利用TabRouter可以更容易的设置有多个选项卡的屏。

                class MyHomeScreen extends React.Component{
                    static navigationOptions = {
                        tabBarLabel:'Home',
                        tabBarIcon:({tintColor}) => (
                            <Image
                                source={ require('./chats-icon.png')}
                                style={[styles.icon,{tintColor:tintColor}]}
                            />
                        )
                    }

                    render(){

                        return (
                            <Button
                                onPress = { () => this.props.navigation.navigate('Notifications') }
                                title='Go to notifications'
                            />
                        );
                    }
                }

                class MyNotificationsScreen extends React.Component{
                    static navigationOptions = {
                        tabBarLabel:'Notifications',
                        tabBarIcon:({tintColor}) => (
                            <Image
                                source={require('./notif-icon.png')}
                                style={[styles.icon,{tintColor:tintColor}]}
                            />
                        )
                    }

                    render(){
                        return (
                            <Button
                                onPress = { ()=> this.props.navigation.goBack()}
                                title='Go back home'
                            />
                        );
                    }
                }

                const styles = StyleSheet.create({
                    icon:{
                        width:26,
                        height:26,
                    }
                });

                const MyApp = TabNavigator({
                    Home:{
                        screen:MyHomeScreen
                    },
                    Notifications:{
                        screen:MyNotificationsScreen
                    }
                },{
                    tabBarPosition:'top',
                    animationEnabled:true,
                    tabBarOptions:{
                        activeTintColor:'#e91e63'
                    }
                });

                》API 解析
                    TabNavigator(RouteConfigs,TabNavigatorConfig);
                    》RouteConfigs
                        其配置和StackNavigator Route configs 一样

                        》navigationOptions 配置属性：
                            {
                                title//headerTitle 与tabBarLabel的备用字段
                                tabBarVisible//是否显示tab bar  默认为true
                                swipeEnabled//是否启用tabs之间的滑动，不设置则使用TabNavigatorConfig的选项值
                                tabBarIcon //添加图标 React Element 或接受focused(boolean) tintColor(string)参数的函数 返回一个React Node
                                tabBarLabel //String || React Element || ({focused:boolean,tintColor:string}) => { return React.Node } 如不设置即undefined 则使用title的值
                                tabBarOnPress:function({previousScene,scene,jumpToIndex }){// onPress事件回调函数
                                    //previousScene:{route, index} 离开的屏
                                    //scene: { route, index }
                                    //jumpToIndex -- 函数 执行导航的函数
                                }
                            }
                    》TabNavigatorConfig
                        {
                            tabBarComponent，//tabBar使用的组件 iOS默认 TabBarBottom ，android默认 TabBarTop
                            tabBarPosition,//tabBar的位置 其值'top' ,'bottom'
                            swipeEnabled，//是否允许tabs 屏幕之间的滑动
                            animationEnabled，//是否启用动画 在tabs切换时
                            configureTransition，//其值是一个函数 接收currentTransitionProps  和 nextTransitionProps参数，返回一个配置对象用于描述tabs之间的动画
                            initialLayout:{//避免延时帧
                                    width,
                                    height
                            },
                            tabBarOptions:{//配置tab bar
                                //为TabBarBottom组件(默认是iOS上的tab bar)的配置如下
                                activeTintColor,//激活tab是 Label和icon的颜色
                                activeBackgroundColor，//激活tab的背景颜色
                                inactiveTintColor，//未激活的tab的 Label和icon的颜色
                                inactiveBackgroundColor，//未激活tab的背景颜色
                                showLabel，//是否显示label  默认true
                                style，//tab bar的样式对象
                                labelStyle，//tab label的样式对象
                                tabStyle,//tab的样式对象
                                allowFontScaling，//label 字体是否能够缩放  默认true

                                //为TabBarTop(android上的tab bar)组件的配置
                                activeTintColor//tab激活的label和icon颜色
                                inactiveTintColor//tab未激活的label icon颜色
                                showIcon//是否显示icon 默认false
                                showLabel //是否显示label 默认true
                                upperCaseLabel//是否让label转成大写  默认true
                                pressColor //按下时的波纹颜色 Android >= 5.0 only
                                pressOpacity //按下时波纹透明度 iOS and Android < 5.0 only
                                scrollEnabled //是否可以滚动tab
                                tabStyle //tab的样式对象
                                indicatorStyle //tab 下面line的样式对象
                                labelStyle //label样式对象
                                iconStyle //tab icon的样式对象
                                style //tab bar样式对象
                                allowFontScaling //是否允许label 字体缩放
                            },
                            initialRouteName，//需要首次加载的tab  其值routeName
                            order，//tabs的顺序， 其值是routeName的数组
                            paths，//为路径配置提供一个routeName映射，它覆盖了在routeConfigs中设置的路径
                            backBehavior，//后退按钮是否会导致标签切换到初始tab，如果是设置为initialRoute(默认值)，否则设置为'none'
                        }
                    》navigator props
                        被TabNavigator创建的navigator组件有如下属性：
                        screenProps -- 传递给子屏幕的额外属性和navigation 选项

                        const TabNav = TabNavigator({});
                        <TabNav screenProps={}/>
            》DrawerNavigator
                使用DrawerNavigator可以更容易创建抽屉导航。

                class MyHomeScreen extends React.Component{
                    static navigationOptions = {
                        drawerLabel:'Home',
                        drawerIcon:({tintColor}) => (
                            <Image source={require('./chats-icon.png')} style={[styles.icon,{tintColor}]}/>
                        )
                    }

                    render(){
                        return (
                            <Button
                                onPress={ () => this.props.navigation.navigate('Notifications')}
                                title='Go to notifications'
                            />
                        );
                    }
                }

                class MyNotificationsScreen extends React.Component{
                    static navigationOptions = {
                        drawerLabel:'Notifications',
                        drawerIcon:({tintColor}) => (
                            <Image source={require('./notif-icon.png')} style={[styles.icon,{tintColor}]}/>
                        )
                    }

                    render(){
                        return (
                            <Button onPress={() => this.props.navigation.goBack()} title='Go back home'/>
                        );
                    }
                }

                const styles = StyleSheet.create({
                    icon:{
                        width:24,
                        height:24
                    }
                });

                const MyApp = DrawerNavigator({
                    Home:{
                        screen:MyHomeScreen
                    },
                    Notifications:{
                        screen:MyNotificationsScreen
                    }
                });

                //打开抽屉卡片
                this.props.navigation.navigate('DrawerOpen');
                //关闭抽屉卡片
                this.props.navigation.navigate('DrawerClose');
                //切换抽屉卡片
                this.props.navigation.navigate('DrawerToggle');

                》API
                    DrawerNavigator(RouteConfig,DrawerNavigatorConfig);

                    》RouteConfigs
                        和StackNavigator一样的

                        》navigationOptions属性
                            title -- headerTitle 和 drawerLabel的备用属性
                            drawerLabel -- String 、 React Element 或 一个接收({focused:boolean,tintColor:string})参数的函数，该函数返回React.Node。当是undefined时，使用title字段。
                            drawerIcon -- React Element 或 一个接收({focused:boolean,tintColor:string})参数的函数，该函数返回React.Node。
                            drawerLockMode -- 指定抽屉的锁定模式。这也可以通过在顶级路由器上使用screenProps.drawerLockMode动态更新。
                                        》unlocked (默认值) 抽屉会响应（打开/关闭）触摸手势。
                                        》locked-closed 抽屉会保持关闭，不会对手势做出反应。
                                        》locked-open 抽屉会保持打开状态，不会对手势做出反应。抽屉可能仍然以编程方式打开和关闭（openDrawer/ closeDrawer）。
                    》DrawerNavigatorConfig
                        {
                            drawerWidth //抽屉的宽度 数值或返回数值的函数
                            drawerPosition//抽屉的位置 默认left 其值left right
                            contentComponent //抽屉的渲染内容组件。如 导航items。该组件接收navigation prop 默认是DrawerItems组件
                            contentOptions:{//配置抽屉内容
                                //针对DrawerItems 的抽屉条目的配置
                                items //routes数组
                                activeItemKey //激活route的key
                                activeTintColor //激活label 和 icon的颜色
                                activeBackgroundColor //激活label的背景颜色
                                inactiveTintColor //未激活项 label icon的颜色
                                inactiveBackgroundColor //未激活项 的背景颜色
                                onItemPress(route)//点击item的执行函数
                                itemsContainerStyle //内容容器的样式对象
                                itemStyle //条目的样式对象
                                labelStyle //label的样式对象
                                iconContainerStyle //图标容器View的样式对象
                            }
                            useNativeAnimations //是否启用原生动画 默认true
                            drawerBackgroundColor //抽屉的背景颜色  默认是white
                            initialRouteName //初始化routeName
                            order //导航条目的顺序  routeNames组成的数组
                            paths //它将覆盖routeConfigs中设置的path
                            backBehavior //返回按钮的行为 initialRoute(默认值) -- 回到初始页面 none -- 退出应用程序
                        }
                    》contentComponent -- 自定义抽屉内容的属性
                        这个抽屉的默认组件(DrawerItems)是可滚动的，并且只包含了RouteConfigs中路由的链接。您可以轻松地覆盖默认组件，
                        在抽屉中添加页眉、页脚或其他内容。默认情况下，抽屉是可滚动的，支持iPhone X安全区。如果您自定义内容，
                        请确保将内容包装在一个SafeAreaView中:

                        import {DrawerItems,SafeAreaView} from 'react-navigation'
                        const CustomDrawerContentComponent = (props) => (
                          <ScrollView>
                            <SafeAreaView style={styles.container} forceInset={{ top: 'always', horizontal: 'never' }}>
                              <DrawerItems {...props} />
                            </SafeAreaView>
                          </ScrollView>
                        );

                        const styles = StyleSheet.create({
                          container: {
                            flex: 1,
                          },
                        });
                    》Navigator Props
                        通过DrawerNavigator创建的navigator 组件有下面属性：
                        screenProps -- 将额外的选项传递给子屏

                        const DrawerNav = DrawerNavigator({
                            //config
                        });

                        <DrawerNav screenProps={}/>

                    》嵌套的DrawerNavigation
                        请注意，如果您嵌套DrawerNavigation，则抽屉会显示在父导航的下方。
            》navigation prop
                》应用的每一个屏都将接收一个navigation的属性，它包含下面属性：
                    》navigate(routeName,params,action) 链接到其他屏
                        》routeName --已经注册过的router 名称 String
                        》params -- 传递到目标屏的参数    Object
                        》action -- 需要在child 屏幕中运行的action

                        class HomeScreen extends React.Component{
                            render(){
                                const {navigate} = this.props.navigation;

                                return (
                                    <View>
                                        <Button onPress={ () => navigate('Profile',{name:'Brent'})} title='跳转'/>
                                    </View>
                                )
                            }
                        }

                    》state  当前屏的routes
                        通过this.props.navigation.state可以访问屏幕的路线。它包含下列属性：
                        {
                            routeName:'profile',//router 名称
                            key:'main0',//用于排序路由得唯一标识
                            params:{hello:'world'}//当前屏幕的参数对象
                        }

                        class ProfileScreen extends React.Component{
                            render(){
                                const {state} = this.props.navigation;
                                return (
                                    <Text>Name:{state.params.name}</Text>
                                );
                            }
                        }
                    》setParams  改变route的params
                        setParams允许改变route的params。

                        class ProfileScreen extends React.Component{
                            render(){
                                const {setParams} = this.props.navigation;

                                return (
                                    <Button onPress={()=> setParams({name:'Lucy'})} title="Set title name to 'Lucy'"/>
                                );
                            }
                        }

                    》goBack 返回到上一个屏
                        可选参数：提供一个key，指定要返回的route的起始屏幕。默认返回上一次的屏(不填key 即起始屏幕是当前屏幕 返回当前屏幕的上一个屏幕)。
                        如：navigation.goBack(SCREEN_KEY_B) // will go to screen A FROM screen B

                        class HomeScreen extends React.Component{
                            render(){
                                const {goBack} = this.props.navigation;

                                return (
                                      <View>
                                        <Button
                                          onPress={() => goBack()}
                                          title="Go back from this HomeScreen"
                                        />
                                        <Button
                                          onPress={() => goBack(null)}
                                          title="Go back anywhere"
                                        />
                                        <Button
                                          onPress={() => goBack('screen-123')}
                                          title="Go back from screen-123"
                                        />
                                      </View>
                                     )
                            }
                        }

                    》dispatch   向router发送一个action

                        利用dispatch 发送任何navigation action给router。其他屏幕能够调用action。
                        注意：如果你想dispatch react-navigation actions,你需要使用该库自己提供的action creators。

                        import {NavigationActions} from 'react-navigation'
                        const navigateAction = NavigationActions.navigate({
                            routerName:'Profile',
                            params:{},

                            //navigate能够嵌套navigate action ，它将在子router中运行
                            action:NavigationActions.navigate({routeName:'SubProfileRoute'});
                        });
                        this.props.navigation.dispatch(navigateAction);


                    注意：navigation属性被分发到每一个导航组件，包括navigator本身。navigation可能没有navigate goBack等帮助函数，仅仅只有state
                    和dispatch。为了navigation可以使用navigate，你需要使用dispatch一个action creator。
            》Navigation Actions
                所有的navigation actions返回一个对象，它能够通过navigation.dispatch()分发给router。
                注意：如果你想dispatch react-navigation actions，你应该使用本库的 action creator 。

                这些actions支持下面属性：
                    Navigate -- 导航到其他的route
                        这个navigate将以navigate操作的结果更新当前state。

                        import {NavigationActions} from 'react-navigation'
                        const navigateAction = NavigationActions.navigate({
                            routeName:'Profile',//String 必须的 在应用程序的路由器中某处注册的目的地routeName
                            params:{},//Object 可选的 route参数
                            //Object 可选的 (高级)子操作在子路由器中运行，如果屏幕是导航器。该文档中描述的任何一个操作都可以设置为子操作
                            action:NavigationActions.navigate({routeName:'SubProfileRoute'})
                        });
                        this.props.navigation.dispatch(navigateAction);

                    Reset -- 用一个新的state替换当前state
                        reset action 将用多个actions的执行结果，替换整个navigation state。
                        支持如下属性:
                        》index Number 必须的  navigation state中routes 中激活路由的索引
                        》actions Array 必须的 navigation Actions的数组
                        》key String or null 可选的 如果设置 被给的key的navigator将被重置，如果设置null root navigator将被重置。

                        import {NavigationActions} from 'react-navigation'
                        const resetAction = NavigationActions.reset({
                            index:0,
                            actions:[NavigationActions.navigate({ routeName: 'Profile'})]
                        });
                        this.props.navigation.dispatch(resetAction);

                        //使用index参数
                        这个index参数，用于指定当前激活的route。
                        如：有一个基础导航栈(Profile和Settings)。为了重置state到激活屏幕Settings，但是栈定时Profile，即index为1。
                        import { NavigationActions } from 'react-navigation'

                        const resetAction = NavigationActions.reset({
                          index: 1,
                          actions: [
                            NavigationActions.navigate({ routeName: 'Profile'}),
                            NavigationActions.navigate({ routeName: 'Settings'})
                          ]
                        })
                        this.props.navigation.dispatch(resetAction)

                    Back -- 返回前一个state
                        返回上一个屏幕并关闭当前屏幕。back action有一个可选参数。
                        》key String or null 可选 如果设置，将从当前key位置返回上一个屏幕。如果null，将返回到任何位置。

                            import {NavigationActions} from 'react-navigation'
                            const backAction= NavigationAction.back({
                                key:'Profile'
                            });
                            this.props.navigation.dispatch(backAction);

                    Set Params -- 为route设置参数
                        当dispatch setParams action时，这个router将产生一个新的state，去改变key指定的route的params。
                        》params Object 必须的，新的params被合并到现有的路由params中
                        》key String 必须的 需要设置新params的route key。
                        import { NavigationActions } from 'react-navigation'

                        const setParamsAction = NavigationActions.setParams({
                          params: { title: 'Hello' },
                          key: 'screen-123',
                        })
                        this.props.navigation.dispatch(setParamsAction)

                    Init -- 如果state是undefined 它将初始化state。
                    这个action creator定义了toString()来返回action type。这将是很有用的对于redux库。
            》navigation options
                每个屏幕可以配置几个方面，说明它如何在父导航器中呈现。

                两种方式指定每一个option：
                》静态配置 -- 每个导航选项都可以直接分配
                    class MyScreen extends React.Component{
                        static navigationOptions = {
                            title:'Great'
                        }
                    }
                》动态配置
                    这个options可以是接收props参数的函数，该函数返回一个navigation options对象。它将覆盖route-defined和navigator-defined的
                    navigationOptions。
                        》navigation 对象
                        》screenProps 从navigator组件传递的prop
                        》navigationOptions 默认和以前的options

                        class Profile extends React.Component{
                            static navigationOptions = ({navigation,screenProps,navigationOptions}) =>({
                                title: navigation.state.params.name + "'s Profile!",
                                headerRight: <Button color={screenProps.tintColor} {...} />,
                            })
                        }
                        //screenProps在渲染时被传入，如果上面组件在SimpleApp navigator 下，那么screenProps.tintColor将取到值
                        <SimpleApp
                          screenProps={{tintColor: 'blue'}}/>


                》通用的navigation options
                    title属性在每个navigator之间都是通用的。它用来设置屏幕的title string。
                    class MyScreen extends React.Component{
                        static navigationOptions = {
                            title:'Great'
                        }
                    }
                    title属性和其他仅仅用于navigator view的属性是不同的，它可以用作浏览器和APP的title。

                》默认 navigation options
                    定义navigationOptions 在screen上是非常常见的。但是有时候也定义navigationOptions 在navigator。
                    TabNavigator({},{
                        navigationOptions: {
                            headerTintColor: 'blue',
                        }
                    });
                》navigation options选项
                    参考：
                        drawer navigator
                        stack navigator
                        tab navigator
            》自定义Navigators
                navigator是具有路由功能的 任何React组件。
                //下面是一个基本案例，他使用router API使得激活组件渲染。
                class MyNavigator extends React.Component{
                    static router = MyRouter;
                    render(){

                        const {state,dispatch} = this.props.navigation;
                        const {routes,index} = state;
                        //根据state获取组件
                        const Component = MyRouter.getComponentForState(state);
                        //获取激活子路由的状态
                        let childNavigation = {dispatch,state:routes[index]};
                        childNavigation = addNavigationHelpers(childNavigation);

                        //返回组件
                        return <Component navigation={childNavigation}/>
                    }

                }

                》Navigation prop
                    navigator传递的 navigation prop仅仅包括 state 和 dispatch。这是navigator的当前state和发送action 请求的事件通道。

                    所有的navigators都是受控制的组件：他们总是显示props.navigation.state对应的组件，并且通过props.navigation.dispatch
                    发送action来改变state。

                    navigators可以通过自定义路由来为父navigators定义行为。如：一个navigator是可以通过router.getStateForAction返回null
                    来阻止导航的激活，或者navigator能够自定义URL来覆盖router.getActionForPathAndParams 和 router.getStateForAction生成
                    的相关路由信息。

                》navigation state
                    这个navigation state被传入navigator's prop.navigation.state。
                    //state结构如下
                    {
                        index:1,//标识路由数组中激活的route
                        routes:[
                            {
                                routeName:'MyRouteName',//路由名称  用于关联组件
                                key:'myroute-123',//该route的唯一标识，用于routes数组中的排序
                                ...customRouteData,//routes的数据 包括params
                            },
                            ...moreRoutes
                        ]
                    }
                》navigation dispatchers
                    一个navigator能够dispatch actions，如：'Go back'；
                    如果dispatcher的返回值： 成功 -- 返回true 失败 -- 返回false
                》建立自定义导航的API
                    为了帮助开发者实现自定义navigators，React Navigation提供了下面工具：
                    》createNavigator
                        该方法将router和navigation view以标准的方式组合在一起。
                        const MyApp = createNavigator(MyRouter)(MyView);
                        等同于
                        const MyApp = ({navigation}) => (
                             <MyView router={MyRouter} navigation={navigation} />
                        );
                        MyApp.router = MyRouter;
                    》addNavigationHelpers
                        添加navigation的所有功能属性。
                    》createNavigationContainer
                        如果你想让你的导航器作为顶级组件可用,(没有导航 prop支持传递),
                        您可以使用createNavigationContainer。当导航prop丢失时，这个实用程序
                        将使您的导航器充当顶级导航器。它将管理应用程序状态，并与应用程序级的导航功能集成，
                        比如处理传入和传出链接，以及Android back按钮行为。
                》Redux集成
                    》redux 集成概述
                        》为了使用redux管理你的导航state，你可以传递navigation prop到navigator。
                        》一旦传递了自己的navigation prop，默认的navigation prop将被销毁。所以navigation默认所带有的属性也需要手动传入。
                        》这个state将由reducer分配，并且dispatch将使用redux默认的dispatch。因此你能够通过this.props.navigation.dispatch(action)
                        dispatch正常的redux action。reducer将更新navigation state当dispatch action时。这个新的navigation state将被分发给navigator.
                    》redux 集成详情
                        使用redux，应用state被reducer定义。没有navigation router都有一个reducer，调用getStateForAction。

                        import {addNavigationHelpers } from 'react-navigation'
                        const AppNavigator = StackNavigator(AppRouteConfigs);
                        const initialState = AppNavigator.router.getStateForAction(AppNavigator.router.getActionForPathAndParams('Login'));

                        const navReducer = (state = initialState,action) =>{
                            const nextState = AppNavigator.router.getStateForAction(action,state);

                            return nextState || state;
                        }

                        const appReducer = combineReducers({
                            nav:navReducer
                        });

                        class App extends React.Component{
                            render(){
                                return (
                                    <AppNavigator
                                        navigation={addNavigationHelpers({
                                            dispatch:this.props.dispatch,
                                            state:this.props.nav
                                        })}
                                    />
                                );
                            }
                        }

                        const mapStateToProps = state => ({nav:state.nav});

                        const AppWithNavigationState = connect(mapStateToProps)(App);

                        const store = createStore(appReducer);

                        class Root extends React.Component{
                            render(){
                                return (
                                      <Provider store={store}>
                                        <AppWithNavigationState />
                                      </Provider>
                                );
                            }
                        }
                        //上面操作之后，navigation state将被存储在redux store中，可以使用redux dispatch来操作
                        //navigation actions。

                        注意：当navigator被赋予navigation prop，它将放弃其内部state的维护，这意味着你需要持久的维护state来处理深层次的链接。
                        如：android的back botton。

                        当导航器嵌套时，navigation state将自动从一个navigator 传递到另外一个navigator。为了child navigator能够接受到父navigator
                        state，它应该被定义为一个screen。
                        如：
                        const AppNavigator = StackNavigator({
                            Home:{screen:MyTabNavigator }
                        });
                        //一旦使用connect 处理AppNavigator之后，MyTabNavigator将自动接收navigation state作为navigation prop。
                    》案例 https://github.com/react-navigation/react-navigation/tree/master/examples/ReduxExample

                    》处理android 上的回退按钮
                        通过使用下面的代码片段，您的导航组件将会注意到后退按钮的操作，并将正确地与您的堆栈交互。这在Android上非常有用。
                        import React from 'react';
                        import {BackHandler} from 'react-native'
                        import {addNavigationHelper,NavigationActions} from 'react-navigation'

                        class AppNavigation = TabNavigator({
                            Home:{screen:HomeScreen},
                            Settings:{screen:SettingScreen}
                        });

                        class ReduxNavigation extends React.Component{
                            componentDidMount(){
                                BackHandler.addEventListener("hardwareBackPress", this.onBackPress);
                            }

                            componentWillUnmount() {
                                BackHandler.removeEventListener("hardwareBackPress", this.onBackPress);
                            }

                            onBackPress = () => {
                                const {dispatch,nav} = this.props;

                                if(nav.index === 0){
                                    return false;
                                }

                                dispatch(NavigationActions.back());
                                return true;
                            }

                            render() {
                                const { dispatch, nav } = this.props;
                                const navigation = addNavigationHelpers({
                                  dispatch,
                                  state: nav
                                });

                                return <AppNavigation navigation={navigation} />;
                              }
                        }
                》Web集成
                    react navigation routers工作在web上，允许使用native app共享navigation逻辑。当前绑定在react-navigation上的视图
                    只工作在react native,但是在未来可能改变，如：https://github.com/lelandrichardson/react-primitives
                》深度链接
                    在应用中处理外部的URL。

                    》参数
                        //以前版本
                        const SimpleApp = StackNavigator({
                          Home: { screen: HomeScreen },
                          Chat: { screen: ChatScreen },
                        });
                        //希望chat/Taylor链接到Chat屏幕，Taylor是一个user参数，配置如下：
                        const SimpleApp = StackNavigator({
                            Home:{screen:HomeScreen},
                            Chat:{
                                screen:ChatScreen,
                                path:'chat/:user'
                            }
                        });
                    》URL 前缀
                        //通过提取app传入URL来配置navigation container。

                         const SimpleApp = StackNavigator({...});
                         //在Android上，URI前缀通常除了scheme之外还包含一个主机名。
                         const prefix = Platform.OS === 'android' ? 'mychat://mychat/' : 'mychat://'
                         const MainApp = () => <SimpleApp uriPrefix={prefix}/>
                    》android
                        为了配置android的外部链接，你可以在manifest中配置一个新的intent。
                        即在android/app/src/main/AndroidManifest.xml 的mainActivity entry中添加新的intent-filter类型的View
                        <intent-filter>
                            <action android:name="android.intent.action.VIEW" />
                            <category android:name="android.intent.category.DEFAULT" />
                            <category android:name="android.intent.category.BROWSABLE" />
                            <data android:scheme="mychat"
                                  android:host="mychat" />
                        </intent-filter>

                        //重启应用
                        react-native run-android
                        //需要测试android中的intent 处理，需要运行下面命令
                        adb shell am start -W -a android.intent.action.VIEW -d "mychat://mychat/chat/Taylor" com.simpleapp(包名 -- com.simpleapp)

                        这样就可以通过浏览器来打开应用了。
                    》iOS
                        配置基于mychat:// url scheme 打开iOS App。
                        在ios/myReactNative/AppDelegate.m中
                            //头部添加这个
                            #import <React/RCTLinkingManager.h>

                            //在 `@end`前面添加这个:
                            - (BOOL)application:(UIApplication *)application openURL:(NSURL *)url
                              sourceApplication:(NSString *)sourceApplication annotation:(id)annotation
                            {
                              return [RCTLinkingManager application:application openURL:url
                                                  sourceApplication:sourceApplication annotation:annotation];
                            }
                        //在xcode中打开项目SimpleApp/ios/SimpleApp.xcodeproj，选择Info按钮，设置Url types ，并添加identifier 和scheme 为mychat。

                        //重启服务
                        react-native run-ios
                        //测试url在模拟器上使用下面命令
                        xcrun simctl openurl booted mychat://chat/Taylor
                        //测试url在真实设备，打开浏览器 测试mychat://chat/Taylor链接即可
                》屏幕跟踪与分析
                    //下面展示screen 追踪并发送到google analytics，这种方式适用于任何移动端 分析SDK。

                    》screen 追踪
                        当使用内置的navigation container时，我们可以使用onNavigationStateChange 追踪屏幕。

                        import { GoogleAnalyticsTracker } from 'react-native-google-analytics-bridge'
                        const tracker = new GoogleAnalyticsTracker(GA_TRACKING_ID);

                        //获取当前screen 从navigation state
                        function getCurrentRouteName(navigationState){
                            if(!navigationState) return null;

                            const route = navigationState.routes[navigationState.index];
                            if(route.routes) return getCurrentRouteName(route);
                            else return route.routeName;
                        }

                        const AppNavigator = StackNavigator(AppRouteConfigs);
                        export default () => (
                            <AppNavigator
                                onNavigationStateChange = ({prevState,currentState}) => {
                                    const currentScreen = getCurrentRouteName(currentState);
                                    const prevScreen = getCurrentRouteName(prevState);

                                    if(prevScreen !== currentScreen){
                                        tracker.trackScreenView(currentScreen);
                                    }
                                }
                            />
                        );
                    》redux中的screen 追踪
                        当使用Redux时，我们可以编写一个Redux中间件来跟踪屏幕。为此，我们将使用上面的getCurrentRouteName。
                        import {NavigationActions} from 'react-navigation'
                        import {GoogleAnalyticsTracker } from 'react-native-google-analytics-bridge'
                        const tracker = new GoogleAnalyticsTracker(GA_TRACKING_ID);

                        const screenTracking = ({getState}) => next => action => {
                            if(action.type !== NavigationActions.NAVIGATE && action.type !== NavigationActions.BACK){
                                return next(action);
                            }

                            const currentScreen = getCurrentRouteName(getState().navigation);
                            const result = next(action);
                            const nextScreen = getCurrentRouteName(getState().navigation);

                            if(nextScreen !== currentScreen) tracker.trackScreenView(nextScreen);

                            return result;
                        };
                        export default screenTracking;

                        //在redux store创建时使用上面中间件
                        const store = createStore(
                          combineReducers({
                            navigation: navigationReducer,
                            ...
                          }),
                          applyMiddleware(
                            screenTracking,
                            ...
                            ),
                        );
                》Routers
                    routers 定义组件的 navigation state，它们允许开发者定义path并处理actions。

                    》内置routers
                        》StackRouter
                        》TabRouter
                    》使用Routers
                        要手动设置navigator，需要放置一个静态的router在组件上。
                        class MyNavigator extends React.Component{
                            static router = StackRouter(routes,config);
                        }
                        //现在您可以将该组件用作另一个导航器中的屏幕，而MyNavigator的导航逻辑将由这个StackRouter定义。
                    》自定义navigation actions
                        要覆盖navigation行为，您可以覆盖getStateForAction中的navigation state逻辑，并手动操作routes和index。
                        const MyApp = StackNavigator({
                            Home:{screen:Home},
                            Profile:{screen:Profile}
                        },{
                          initialRouteName:'Home'
                        });

                        const defaultGetStateForAction = MyApp.router.getStateForAction;
                        MyApp.router.getStateForAction = (action,state) => {
                            if(state && action.type === 'PushTwoProfiles'){
                                const routes = [
                                    ...state.routes,
                                    {key: 'A', routeName: 'Profile', params: { name: action.name1 }},
                                    {key: 'B', routeName: 'Profile', params: { name: action.name2 }},
                                ]

                                return {
                                    ...state,
                                    routes,
                                    index:routes.length -1
                                }
                            }
                            return defaultGetStateForAction(action,state);
                        }
                    》阻止导航actions
                        有时候你可能想阻止一些导航操作，这取决于你的route。
                        import {NavigationActions} from 'react-navigation'

                        const MyStackRouter = StackRouter({
                            Home:{screen:Home},
                            Profile:{screen:Profile}
                        },{
                            initialRouteName:'Home'
                        });

                        const defaultGetStateForAction = MyStackRouter.router.getStateForAction;
                        MyStackRouter.router.getStateForAction = (action,state) => {
                            if(state && action.type === NavigationActions.BACK && state.routes[state.index].params.isEditing){
                                //返回null actions将被阻止
                                return null;
                            }

                            return defaultGetStateForAction(action,state);
                        }
                    》处理自定义URL
                        也许你的app有一个独特的URL，内置的routers不能够处理它，你能够扩展这个router getActionForPathAndParams。

                        import {NavigationActions} from 'react-navigation'
                        const MyApp = StackNavigator({
                            Home:{screen:Home},
                            Profile:{screen:Profile}
                        },{
                            initialRouteName:"Home"
                        });
                        const previousGetActionForPathAndParams = MyApp.router.getActionForPathAndParams;
                        Object.assign(MyApp.router,{
                            getActionForPathAndParams(patch,params){
                                if (
                                      path === 'my/custom/path' &&
                                      params.magic === 'yes'
                                    ) {
                                      // returns a profile navigate action for /my/custom/path?magic=yes
                                      return NavigationActions.navigate({
                                        routeName: 'Profile',
                                        action: NavigationActions.navigate({
                                          // This child action will get passed to the child router
                                          // ProfileScreen.router.getStateForAction to get the child
                                          // navigation state.
                                          routeName: 'Friends',
                                        }),
                                      });
                                    }
                                    return previousGetActionForPathAndParams(path, params);
                            }
                        });
                》自定义Router API
                    你可以创建自己的router，它包含下面函数：
                    const MyRouter = {
                          getStateForAction: (action, state) => ({}),
                          getActionForPathAndParams: (path, params) => null,
                          getPathAndParamsForState: (state) => null,
                          getComponentForState: (state) => MyScreen,
                          getComponentForRouteName: (routeName) => MyScreen,
                    }
                    //现在 你能够创建一个navigator 通过上面router
                    class MyNavigator extends React.Component{
                        static router = MyRouter;

                        render(){
                            ...
                        }
                    }

                    》getStateForAction(action,state)
                        根据给定的action，定义navigation state。当action被给props.navigation.dispatch或react-navigation的辅助函数被调用如
                        navigation.navigate时，这个getStateForAction将被调用。

                        //通常，这应该返回一个导航状态，具有以下表单。
                        {
                            index:1,//当前激活路由得索引
                            routes:[
                                {
                                    routeName:'MyRouteName',
                                    key:'myroute-123'//routes数组中的唯一标识
                                    ...randomRouteData
                                },
                                ...moreRoutes
                            ]
                        }
                        //如果这个router action在外部处理，或者是想在不改变navigation state的情况下，return null即可
                    》getComponentForRouteName(routeName)
                        根据给定的route name 返回 child component 或 navigator。
                    》getComponentForState(state)
                        根据深层的navigation state返回一个激活的component。
                    》getActionForPathAndParams(path,params)
                        返回一个可选的navigation action，该action在用户导航到这个path和提供可选的params时使用。
                    》getPathAndParamsForState(state)
                        返回可以放入URL的路径和params，以将用户链接回应用程序中的相同位置.
                    》getScreenOptions(navigation,screenProps)
                        用于检索当前navigation options，必须提供当前的navigation prop 和其他可选的props。
                        》navigation
                            这是屏幕将使用的navigation prop，其中状态表示屏幕的路由/状态。Dispatch将在该屏幕的上下文中触发操作。
                        》screenProps
                            navigation options可能需要使用的其他props
                        》navigationOptions
                            上一个设置的options(默认的或上一个配置的)

                        //获取配置的标题
                        // First, prepare a navigation prop for your child, or re-use one if already available.
                        const screenNavigation = addNavigationHelpers({
                          // In this case we use navigation.state.index because we want the title for the active route.
                          state: navigation.state.routes[navigation.state.index],
                          dispatch: navigation.dispatch,
                        });
                        const options = this.props.router.getScreenOptions(screenNavigation, {});
                        const title = options.title;
                》StackRouter
                    管理逻辑navigation stack，包括 push、pop、handle path来创建一个深度的stack。

                     const MyApp = StackRouter({
                        Home:{screen:Home},
                        Profile:{screen:Profile}
                     },{
                        initialRouteName:'Home'
                     });

                    》RouteConfig
                        const MyApp = StackRouter({
                            //RouteConfig
                            Home:{
                                screen:Home,
                                path:''
                            },
                            Profile:{
                                screen:Profile,
                                path:'profile/:name'
                            },
                            Settings:{
                                //这可以方便地延迟需要屏幕。注意：不能配置child navigator 利用getScreen,因为router不可用
                                //Navigators必须使用 'screen : MyNavigator'形式配置
                                getScreen:() => require('Setting').default,
                                path:'settings'
                            }
                        });
                        //配置中的每一项都可能有以下内容:
                        》path 指定在stack中的path和params
                        》screen 指定屏幕组件或child navigator
                        》getScreen 为屏幕组件设置一个延迟的getter  不适用于navigators
                    》StackConfig
                        需要传递到stack router的配置选项：
                        initialRouteName--初始化route name
                        initialRouteParams -- 初始化route的默认参数
                        paths -- 提供routeName到path配置的映射，该映射覆盖了routeConfigs中设置的路径。
                    》支持的Actions
                        这个stack router可能响应下面navigation actions。如果可能，这个路由器通常会将操作处理委托给子路由器。
                        Navigate -- 导航到一个新屏幕
                        Back  --  返回
                        Reset  -- 重置navigation state
                        SetParams -- 设置params。
                》TabRouter
                        管理应用中的一组tabs，处理tabs的跳转，以及返回按钮的处理。
                        const MyApp = TabRouter({
                            Home:{screen:HomeScreen},
                            Settings:{screen:SettingsSreen}
                        },{
                            initialRouteName:'Home'
                        });

                        》RouteConfig
                            const MyApp = TabRouter({//routeConfig
                                Home:{
                                    screen:HomeScreen,
                                    path:'main'
                                },
                                Settings:{
                                    //延时处理tab require
                                    getScreen: () => require('./SettingsScreen').default,
                                    path:'settings'
                                }
                            });
                            //每个项有如下配置：
                            path:指定每个tab的path
                            screen:指定屏幕组件或child navigator
                            getScreen:设置延时获取屏幕组件  不适用于child navigators

                        》tab router config
                            initialRouteName // 初始化的route name
                            order //routeNames 的Array 定义tabs顺序
                            paths //提供一个routeName 的path 映射，将覆盖routeConfigs中的paths
                            backBehavior//点击返回按钮的行为 'initialRoute'(默认值)  'none'
                        》支持actions
                            Navigate -- 跳转链接的action
                            Back  -- 返回action
                            SetParams  -- 改变当前route的params
                》Views
                    navigation view是带有router和navigation prop的展示组件，能够显示多个屏幕，如：被navigation.state指定的。

                    navigation views是被控制的React component，它可以显示当前的navigation state。他们管理屏幕、动画和手势的切换。它们还提供了持久的导航视图，如标签栏和标题

                    》内置的Views
                        》CardStack -- 提供适合于任何平台的堆栈
                            Card -- 从卡片堆中拿出一张卡片，用手势表示。
                            Header -- 卡片堆栈的头部视图。
                        》Tabs -- 一个可配置的tab switcher/pager。
                        》Drawer -- 一个从左边滑出的抽屉的视图。
                    》Transitioner
                        Transitioner在转换过程中管理动画，并可用于构建完全自定义的导航视图。它在CardStack视图中使用。
                》Transitioner
                    transitioner是一个react组件，它帮助管理复杂动画的过渡。它管理动画的时间，并在输入和离开时跟踪各种屏幕，
                    但它不知道任何东西看起来是什么样子，因为渲染完全是由开发人员决定的。在覆盖层下，过渡器被用来实现CardStack，
                    因此是StackNavigator。

                    tansitioner最实用的是把它当作当前current navigation state中的props，当routes 时从navigation state离开时，
                    transitioner将给这些routes赋予过渡，即使他们已经离开了导航状态，也要把它们留在屏幕上。

                    》案例
                        class MyNavView extends Component{

                            render(){
                                return  (
                                    <Transitioner
                                        configureTransition={this._configureTransition}
                                        navigation={this.props.navigation}
                                        render={this._render}
                                        onTransitionStart={this.onTransitionStart}
                                        onTransitionEnd={this.onTransitionEnd}
                                    />
                                );
                            }
                        }
                    》属性详解
                        》configureTransition  -- Function
                            这个函数在Transitioner.componentWillReceiveProps调用。
                            这个函数允许自定义动画参数如：duration，这个函数的返回值将被传入一个定时函数，默认作为Animated.timing()的配置。

                            _configureTransition(transitionProps, prevTransitionProps) {
                              return {
                                // 持续时间 default: 250
                                duration: 500,
                                //  default: Easing.inOut(Easing.ease)
                                easing: Easing.bounce,
                              }
                            }
                            //注意：duration和easing只有当定时函数是Animated.timing时才适用，我们还可以使用不同的定时函数及其相应的配置
                            如:
                            _configureTransition(transitionProps, prevTransitionProps) {
                              return {
                                // A timing function, default: Animated.timing.
                                timing: Animated.spring,
                                // Some parameters relevant to Animated.spring
                                friction: 1,
                                tension: 0.5,
                              }
                            }

                            //流程定义
                            configureTransition:(
                                //当前NavigationTransitionProps被创建从当前导航state和props https://github.com/react-navigation/react-navigation/blob/master/src/TypeDefinition.js#L273
                                transitionProps: NavigationTransitionProps,
                                //上一个NavigationTransitionProps被创建 从上一个的state和props https://github.com/react-navigation/react-navigation/blob/master/src/TypeDefinition.js#L273
                                prevTransitionProps: ?NavigationTransitionProps,
                            ) => NavigationTransitionSpec ;//返回一个类型NavigationTransitionSpec的对象，它将被输入一个动画的定时功能作为它的配置 https://github.com/react-navigation/react-navigation/blob/master/src/TypeDefinition.js#L316
                        》navigation
                            一个对象，包含navigation state和routes以及激活route的index，同时还有dispatch和其他处理action的函数。
                            如：{
                                 // Index refers to the active child route in the routes array.
                                index: 1,
                                routes: [
                                  { key: 'DF2FGWGAS-12', routeName: 'ContactHome' },
                                  { key: 'DF2FGWGAS-13', routeName: 'ContactDetail', params: { personId: 123 } }
                                ]
                              }

                            //定义 https://github.com/react-navigation/react-navigation/blob/master/src/TypeDefinition.js#L32
                            export type NavigationState = {
                                index:number,
                                routes:Array<NavigationRoute>
                            }
                        》render Function
                            从Transitioner.render()调用，这个函数的执行实际是从Transitioner委托的，在这个函数中，我们能够接受到
                            transitionProps 和prevTransitionProps 参数来渲染屏幕，创建动画，处理手势。

                            transitionProps和prevTransitionProps有几个重要的属性： https://github.com/react-navigation/react-navigation/blob/master/src/TypeDefinition.js#L273
                            》scenes: Array<NavigationScene> -- 所有可用的屏幕
                            》position: NavigationAnimatedValue -- 导航状态的累进索引
                            》progress: NavigationAnimatedValue -- 当导航状态从一个转换到另一个时，代表转换进程的值。它的数值范围从0到1

                            》案例
                                transitionProps.scenes是一系列可用的scenes，它取决于实现者，或者决定如何在屏幕上显示它们。例如，我们可以将场景渲染成一堆卡片，例如：
                                    _render(transitionProps, prevTransitionProps) {
                                      const scenes = transitionProps.scenes.map(scene => this._renderScene(transitionProps, scene));
                                      return (
                                        <View style={styles.stack}>
                                          {scenes}
                                        </View>
                                      );
                                    }
                                然后我们可以使用动画。以动画过渡。为了创建必要的动画样式属性，例如不透明度，我们可以插入与过渡道具一起的位置和进度值:
                                    _renderScene(transitionProps, scene) {//http://www.reactnativediary.com/2016/12/20/navigation-experimental-custom-transition-1.html
                                      const { position } = transitionProps;
                                      const { index } = scene;
                                      const opacity = position.interpolate({
                                        inputRange: [index-1, index, index+1],
                                        outputRange: [0, 1, 0],
                                      });
                                      // The prop `router` is populated when we call `createNavigator`.
                                      const Scene = this.props.router.getComponent(scene.route.routeName);
                                      return (
                                        <Animated.View style={{ opacity }}>
                                          { Scene }
                                        </Animated.View>
                                      )
                                    }
                            》定义
                                render: (transitionProps: NavigationTransitionProps, prevTransitionProps: ?NavigationTransitionProps) => React.Node
                            》参数
                                transitionProps -- 当前NavigationTransitionProps从当前state创建和props https://github.com/react-navigation/react-navigation/blob/master/src/TypeDefinition.js#L273
                                prevTransitionProps -- 前面NavigationTransitionProps以前创建的state和props https://github.com/react-navigation/react-navigation/blob/master/src/TypeDefinition.js#L273
                            》返回值
                                一个ReactElement 它将被用来渲染的过渡组件
                        》onTransitionStart  Function
                            当动画开始时执行的函数
                            》定义
                                onTransitionStart: (transitionProps: NavigationTransitionProps, prevTransitionProps: ?NavigationTransitionProps) => (Promise | void),
                            》参数
                                transitionProps
                                prevTransitionProps
                            》返回值
                                Promise可以延时过渡动画的开始，或者不会立即开始动画
                        》onTransitionEnd Function
                            动画完成时调用
                            》定义
                                onTransitionEnd: () => void
                                //无参数，无返回值
                》withNavigation
                    withNavigation时一个高阶组件，它将navigation props传递给被包裹的组件。它是很有用的当你不能传递navigation给组件时，
                    或者你不想传递比较深的子组件时。

                    import { Button } 'react-native';
                    import { withNavigation } from 'react-navigation';

                    const MyComponent = ({ to, navigation }) => (
                        <Button title={`navigate to ${to}`} onPress={() => navigation.navigate(to)} />
                    );

                    const MyComponentWithNavigation = withNavigation(MyComponent);


                    // or use decorators:

                    @withNavigation
                    export default class MainScreen extends Component {
                      ...
                    }
    》如果你只针对iOS平台开发，那么可以考虑适应NavigatorIOS。它是基于 UINavigationController封装的。
        <NavigatorIOS
            initialRoute={
                {
                    component:MyScene,
                    title:'My Initial Scene',
                    passProps:{myProp:'foo'}
                }
            }
        />
        用法类似Navigator，NavigatorIOS也使用路由对象来描述场景，但有些重要的区别。其中要渲染的组件在路由对象的component字段中指定，
        要给目标组件传递的参数则写在passProps中。被渲染的component都会自动接受一个名为navigator的属性，你可以直接调用this.props.navigator的push和pop方法。

        由于NavigatorIOS使用的是原生的UIKit导航，所以它会自动渲染一个带有返回按钮和标题的导航栏。

        import React, { Component, PropTypes } from 'react';
        import { NavigatorIOS, Text, TouchableHighlight, View } from 'react-native';

        export default class NavigatorIOSApp extends Component {
          render() {
            return (
              <NavigatorIOS
                initialRoute={{
                  component: MyScene,
                  title: 'My Initial Scene',
                }}
                style={{flex: 1}}
              />
            )
          }
        }

        class MyScene extends Component {
          static propTypes = {
            title: PropTypes.string.isRequired,
            navigator: PropTypes.object.isRequired,
          }

          constructor(props, context) {
            super(props, context);
            this._onForward = this._onForward.bind(this);
          }

          _onForward() {
            this.props.navigator.push({
              title: 'Scene ' + nextIndex,
            });
          }

          render() {
            return (
              <View>
                <Text>Current Scene: { this.props.title }</Text>
                <TouchableHighlight onPress={this._onForward}>
                  <Text>Tap me to load the next scene</Text>
                </TouchableHighlight>
              </View>
            )
          }
        }
15.颜色
    支持的颜色格式：
        '#f0f' -- #rgb
        '#f0fc' -- #rgba
        '#ff00ff' -- #rrggbb
        '#ff00ff00' -- #rrggbbaa
        'rgb(255,255,255)'
        'rgba(255,255,255,1)'
        'hsl(360,100%,100%)'
        'hsla(360,100%,100%,1)'
        'transparent'
        'red'
        0xff00ff00 -- 0xrrggbbaa
16.图片
    》静态图片资源
        从.14版本开始，React native 提供了一个统一的方式来管理iOS和Android应用中的图片。要往app中添加一个静态资源，只需把图片文件放在代码文件
        夹中，然后像下面这样去引用它。
            <Image source={require('./my-icon.png')}/>
        图片文件的查找会和js模块的查找方式一样。在上面的这个例子中，是那个组件引用来这个图片，Packager就会去这个组件所在的文件夹下查找
        my-icon.png。并且如果你my-icon.ios.png和my-icon.android.png，Packager就会根据平台而选择不同的文件。

        你还可以使用@2x,@3x这样的文件名后缀，来为不同的屏幕精度提供图片，如下面这样的代码结构：
            img
                check@2x.png check@3x.png
            button.js
        并且在button.js中有这样的代码：<Image source={require('./img/check.png')} />
        Packager会打包所有的图片，并且依据屏幕精度提供对应的资源，譬如说，iPhone 5s会使用check@2x.png,而Nexus 5会使用check@3x.png。如果没有图片
        恰好满足屏幕分辨率，则会自动选中最接近的一个图片。

        注意：如果你添加图片的时候packager正则运行，可能需要重启packager以便能正确引入新添加的图片。

        这样会带来很多好处：
            》iOS和Android一致的文件系统
            》图片和js代码处在相同的文件夹，这样组件就可以包含自己所用的图片而不用单独去设置
            》不需要全局命名，不用担心图片名字的冲突问题了
            》只有实际被用到(即被require)的图片才会被打包到你的app。
            》现在在开发期间，增加和修改图片不需要重新编译了，只要和修改js代码一样刷新你的模拟器就可以了。
            》与访问网络图片相比，Packager可以得知图片大小了，不需要再代码里面在声明一遍尺寸。
            》现在通过npm来分发组件或库可以包含图片了

        注意：为了使新的图片资源机制正常工作，require中的图片名字必须是一个静态字符串(不能使用变量 因为require是在编译时期执行，而非运行时期执行！)
            <Image source={require('./my-icon.png')}/>//正确

            //错误
            var icon = this.props.active ? 'my-icon-active' : 'my-icon-inactive';
            <Image source={require('./' + icon + '.png')} />

            //正确
            var icon = this.props.active ? require('./my-icon-active.png') : require('./my-icon-inactive.png');
            <Image source={icon} />
            //注意：通过这种方式引用的图片资源包含图片的尺寸信息，如果你需要动态缩放图片(如：通过flex)，你可能必须
            //手动在style属性设置{width:undefined,height:undefined}
    》静态非图片资源
        上面描述的require语法也可以用来静态地加载你项目中的声音、视频或文档文件。大多数常见的文件类型都支持，包括
        .mp3, .wav, .mp4, .mov, .htm 和 .pdf等。

        注意：视频必须指定尺寸而不能使用flex样式，因为我们目前还不能从非图片资源中获取到尺寸信息，对于直接链接到Xcode
        或android资源文件夹的视频，则不会有这个限制。
    》使用混合App的图片资源
        如果你在编写一个混合App(一部分UI使用React Native,而另一部分使用平台原生代码)，也可以使用已经打包到App中的图片资源
        (以拖拽的方式放置在Xcode的asset类目录中，或者放置在Android的drawable目录里)，注意此时只使用文件名，不带路径也不带后缀。
        <Image source={{uri: 'app_icon'}} style={{width: 40, height: 40}} />

        对于放置在Android的assets目录中的图片，还可以使用asset:/前缀来引用：
         <Image source={{uri: 'asset:/app_icon.png'}} style={{width: 40, height: 40}} />

         注意：这一做法并没有任何安全检查，你需要自己确保图片在应用中确实存在，而且还需要指定尺寸。
    》网络图片
        很多要在App中显示的图片并不能再编译的时候获得，又或者有时候需要动态载入来减少打包后的二进制文件的大小。
        这些时候，与静态资源不同的是，**你需要手动指定图片的尺寸**，同时建议使用https以满足iOS App transport security(https://segmentfault.com/a/1190000002933776)的要求。

        //正确
        <Image source={ {uri:'https://facebook.github.io/react/img/logo_og.png'} } style={{width:400,height:400}}/>
        //错误
        <Image source={{uri:'https://facebook.github.io/react/img/logo_og.png'}}/>

        》网络图片的请求参数
            可以在Image组件的source属性中指定一些请求参数
            <Image
                source={
                    {
                        uri:'https://facebook.github.io/react/img/logo_og.png'
                        method: 'POST',
                        headers: {
                          Pragma: 'no-cache'
                        },
                        body: 'Your Body goes here'
                    }
                }
                style={{width:400,height:400}}
            />
    》缓存控制 仅iOS
        在某些情况下，你可能仅仅想展示一张已经在本地缓存的图片，如：一个低分辨率的占位符，直到高分辨率的图片可用。在其他情况下你不关心图片
        是否是过时，并愿意显示过时的图片，以节省带宽，缓存资源属性给你控制网络层和缓存交互的方式。
        default：使用原生平台默认策略。
        reload：URL的数据将从原始地址加载。不使用现有的缓存数据。
        force-cache：现有的缓存数据将用于满足请求，忽略其期限或到期日。如果缓存中没有对应请求的数据，则从原始地址加载。
        only-if-cached：现有的缓存数据将用于满足请求，忽略其期限或到期日。如果缓存中没有对应请求的数据，则不尝试从原始地址加载，并且认为请求是失败的。

        <Image source={{uri: 'https://facebook.github.io/react/img/logo_og.png', cache: 'only-if-cached'}}
               style={{width: 400, height: 400}} />
    》本地文件系统中的图片
        参考相册（CameraRoll）这个例子来看如何使用在Images.xcassets以外的本地资源。 https://reactnative.cn/docs/0.49/cameraroll.html

        最合适的相册图片：
        iOS会为同一张图片在相册中保存多个不同尺寸的副本。为了性能考虑，从这些副本中挑出最合适的尺寸显得尤为重要。对于一处200x200大小的
        缩略图，显然不应该选择最高质量的3264x2448大小的图片。如果恰好有匹配的尺寸，那么React Native会自动为你选好。如果没有，则会选择
        最接近的尺寸进行缩放，但也至少缩放到比所需尺寸大出50%，以使图片看起来仍然足够清晰。这一切过程都是自动完成的，所以你不用操心自己
        去完成这些繁琐且易错的代码。
    》为什么不在所有情况下都自动指定尺寸？
        在浏览器中，如果不给图片指定尺寸，那么浏览器会首选渲染一个0x0大小的元素占位，然后下载图片，在下载完成后再基于正确的尺寸来渲染图片。
        这样做的最大问题是UI会在图片加载的过程中上下跳动，使得用户体验非常糟糕。

        在React native中避免了这个行为，如此一来开发者就需要做更多的工作来提前知晓远程图片的尺寸，但我们相信这样可以带来更好的用户体验，然而
        从已经打包好的应用资源文件中读取图片(使用require('image!x'))则无需指定尺寸，因为他们在加载时就知道了尺寸。
        如引用require('image!logo')的实际输出结果可能是：
        {"__packager_asset":true,"isStatic":true,"path":"/Users/react/HelloWorld/iOS/Images.xcassets/react.imageset/logo.png","uri":"logo","width":591,"height":573}
    》资源属性是一个对象
        在React Native中，另一个值得提的是把src属性改为了source属性，而且并不接受字符串，正确的值是一个带有uri属性的对象
        <Image source={{uri: 'something.jpg'}} />
        深层次的考虑：这样可以是我们在对象中添加一些元数据，如使用require('./my-icon.png')，那么我们就会在其中添加真实的文件路径以及
        尺寸等信息。此外也考虑未来的扩展，比如我们可能会加入精灵图（sprites）的支持：在输出{uri: ...}的基础上，我们可以进一步输出裁切信息
        {uri: ..., crop: {left: 10, top: 50, width: 20, height: 40}}，这样理论上就可以在现有的代码中无缝支持精灵图的切分。
    》背景图片组件 ImageBackground
        <ImageBackground source={...}>
            <Text>Inside</Text>
        </ImageBackground>
    》iOS边框圆角的注意事项
        请注意下列表边框圆角样式目前在iOS的图片组件上还不支持。
        borderTopLeftRadius
        borderTopRightRadius
        borderBottomLeftRadius
        borderBottomRightRadius
    》在主线程外解码图片
        图片解码有可能会需要超过一帧的时间。在web上这是页面掉帧的一大因素，因为解码是在主线程中完成的。
        然而在React Native中，图片解码则是在另一线程中完成的。在实际开发中，一般对图片还没下载完成时的
        场景都做了处理（添加loading等），而图片解码时显示的占位符只占用几帧时间，并不需要你改动代码去额外处理。
17.处理触摸事件
        》可点击的组件
            在需要捕获用户点击操作时，可以使用'Touchable'开头的一系列组件，这些组件通过onPress属性接受一个点击事件的处理函数。
            当一个点击操作开始并且终止于本组件时(即在本组件上按下手指并且抬起手指时也没有移开组件外)，此函数会被调用。

            class MyButton extends Component{
                _onPressButton(){
                    console.log('You tapped the button!');
                }

                render(){
                    return(
                        <TouchableHighlight onPress={this._onPressButton}>
                            <Text>Button</Text>
                        <TouchableHighlight/>
                    );
                }
            }
            可点击的组件需要给用户提供视觉反馈，如：是那个组件正在响应用户的操作，以及当用户抬起手指后会发生什么，用户也应该可以通过把
            手指移到一边来取消点击操作。
            具体使用那种组件，取决于希望给用户带来什么样的视觉反馈：
            》一般来说，你可以使用TouchableHighlight来制作按钮或链接，注意此组件的背景会在用户手指按下时变暗。
            》在android上还可以使用TouchableNativeFeedback，它会在用户手指按下时形成类似墨水涟漪的视觉效果
            》TouchableOpacity会在用户手指按下时降低按钮的透明度，而不会改变背景的颜色。
            》如果你想在处理点击事件的同时不显示任何视觉反馈，则需要使用TouchableWithoutFeedback
        》长按
            某些场景中你可能需要检测用户是否进行了长按操作，可以在上面列出的任意组件中使用onLongPress属性来实现。
        》在列表中上下滑动和在视图上左右滑动
            可滚动的列表是移动应用中一种常见的模式。用户会在列表中或快或慢的各种滑动，ScrollView组件可以满足这一需求。
            ScrollView可以在垂直或水平方向滚动，还可以配置pagingEnabled属性来让用户整屏滑动，此外水平方向的滑动还可以使用
            android上的ViewPagerAndroid组件。

            ListView则是一种特殊的ScrollView，用于显示比较长的垂直列表，它还可以显示分区块的头部和尾部，类似于iOS上的UITableView控件。
        》双指缩放
            如果在ScrollView中只放置一个组件，则可以用户实现缩放操作。设置maximumZoomScale和minimumZoomScale属性即可以使用户能够缩放其中的内容。

18.动画
    React Native提供了两个互补的动画系统：用于全局的布局动画LayoutAnimation和用户创建更精细的交互控制的动画Animated。

    》Animated
        Animated库使得开发者可以非常容易地实现各种各样的动画和交互方式，并且具备极高的性能。Animated旨在以声明的形式来定义动画的输入和输出。
        在其中建立一个可配置的变化函数，然后使用简单的start/stop方式来控制动画按顺序执行。Animated仅封装了四个可以动画化的组件:View Text Image
        和ScrollView,不过你可以使用Animated.createAnimatedComponent()来封装你自己的组件。

        //淡入动画的效果视图
        import React,{Component} from 'react'
        import {Animated,Text} from 'react-native'

        /**
         * 淡入动画效果
         */
        class FadeInView extends Component{

            constructor(props){
                super(props);
                this.state = {
                    fadeAnim:new Animated.Value(0)//透明度初始值为0
                }
            }

            componentDidMount(){
                Animated.timing(//随时间变化而执行的动画类型
                    this.state.fadeAnim,{
                        toValue:1//透明度最终值
                    }
                ).start();//开始执行动画

            }

            render(){
                return(
                    <Animated.View //可动画的视图组件
                        style={{...this.props.style,
                            opacity:this.state.fadeAnim //将透明度指定为动画变量值
                        }}>
                        {this.props.children}
                    </Animated.View>
                );

            }
        }

        /**
         * 然后就可以在组件中像使用View那样去使用FadeInView组件
         */
        class FadeInTest extends Component{

            render(){
                return (
                    <FadeInView style={{width: 250, height: 50, backgroundColor: 'powderblue'}}>
                        <Text style={{fontSize: 28, textAlign: 'center', margin: 10}}>Fading in</Text>
                    </FadeInView>
                );
            }
        }

        export default FadeInTest

        》配置动画
            动画拥有非常灵活的配置项，自定义的或预定义easing函数、延迟、持续时间、衰减系数、spring常量，以及更多的可以根据动画的类型进行调整。

            Animated提供了多种动画类型，其中最常见的是Animated.timing()。它支持使用各种预定义的缓变函数中的一个来对一个值进行动画化，或者您
            可以使用自己的。在动画中通常使用缓动函数来表示物体的逐渐加速和减速。
            在默认情况下，timing将使用一个easeInOut曲线，它将逐渐加速到全速，并通过逐渐减速到停止来结束。您可以通过传递一个easing参数来指定一个
            不同的easing函数。还支持自定义duration持续时间，甚至在动画开始之前的延迟delay。
            如：
                Animated.timing(this.state.xPosition,{
                    toValue:100,
                    easing:Easing.back,
                    duration:2000
                }).start();

        》组合动画
            多个动画可以通过parallel(同时执行)、sequence(顺序执行)、stagger和delay来组合使用。它们中的每一个都接受一个要执行的动画数组，
            并且自动在适当的时候调用start/stop。
            Animated.sequence([//首先执行decay动画，结束后同时执行spring和twirl动画
                Animated.decay(position,{//滑行一段距离后停止
                    velocity: {x: gestureState.vx, y: gestureState.vy}, // 根据用户的手势设置速度
                    deceleration: 0.997,
                }),
                 Animated.parallel([          // 在decay之后并行执行：
                    Animated.spring(position, {
                      toValue: {x: 0, y: 0}    // 返回到起始点开始
                    }),
                    Animated.timing(twirl, {   // 同时开始旋转
                      toValue: 360,
                    }),
                  ]),
            ]).start();//执行这一整套动画序列
            //默认情况下，如果任何一个动画被停止或中断了，组内所有其他的动画也会被停止，Parallel有一个stopTogether属性，如果设置为false，可以禁用自动停止。
        》合成动画值
            你可以使用加减乘除以及取余等运算来把两个动画值合成为一个新的动画值。
            const a = Animated.Value(1);
            const b = Animated.divide(1, a);

            Animated.spring(a, {
              toValue: 2,
            }).start();
        》插值
            Animated API还有一个很强大的部分就是interpolate插值函数，它可以接受一个输入区间，然后将其映射到另一个的输出区间。
            //一个简单的从0-1区间到0-100区间的映射示例：
                value.interpolate({
                  inputRange: [0, 1],
                  outputRange: [0, 100],
                });

            interpolate还支持定义多个区间段落，常用来定义静止区间等。举个例子，要让输入在接近-300时取相反值，然后在输入接近-100时到达0，
            然后在输入接近0时又回到1，接着一直到输入到100的过程中逐步回到0，最后形成一个始终为0的静止区间，对于任何大于100的输入都返回0。
            具体写法如下：
                value.interpolate({
                  inputRange: [-300, -100, 0, 100, 101],
                  outputRange: [300,    0, 1,   0,   0],
                });

            //interpolate还支持到字符串的映射，从而可以实现颜色以及带有单位的值得动画变换。例如你可以像下面这样实现的一个旋转动画：
                value.interpolate({
                    inputRange: [0, 360],
                    outputRange: ['0deg', '360deg']
                });

            interpolation还支持任意的渐变函数，其中有很多已经在Easing类中定义了，包括二次、指数、贝塞尔等曲线以及step、bounce等方法。
            interpolation还支持限制输出区间outputRange。你可以通过设置extrapolate、extrapolateLeft或extrapolateRight属性来限制输出区间。
            默认值是extend（允许超出），不过你可以使用clamp选项来阻止输出值超过outputRange。
        》跟踪动态值
            动画中所设置的值还可以通过跟踪别的值得到，你只要把toValue设置成另一个动态值而不是一个普通数字就行了。比如我们可以用弹跳动画来实现聊天头像的
            闪动，又比如通过timing设置duration:0来实现快速的跟随。它们还可以使用插值来进行组合：
                Animated.spring(follower, {toValue: leader}).start();
                Animated.timing(opacity, {
                  toValue: pan.x.interpolate({
                    inputRange: [0, 300],
                    outputRange: [1, 0],
                  }),
                }).start();
            //ValueXY是一个方便的处理2D交互的办法，譬如旋转或拖拽。他是一个简单的包含了两个Animated.Value实例的包装，然后提供了一系列的辅助函数，
            //使得ValueXY在许多时候可以替代Value来使用。比如上面的代码片段中，leader和follower可以同时为valueXY类型，这样x y的值都会被跟踪。
        》输入事件
            Animated.event是Animated API中与输入有关的部分，允许手势或其他事件直接绑定到动态值上，它通过一个结构化的映射语法来完成，使得复杂事件对象中
            的值可以被正确的解开。第一层是一个数组，允许同时映射多个值，然后数组的每个元素是一个嵌套对象。
            在下面例子中，你可以发现scrollX被映射到了event.nativeEvent.contentOffset.x(event通常是回调函数的第一个参数)，并且pan.x和pan.y分别映射到
            gestureState.dx和gestureState.dy(gestureState是传递给PanResponder回调函数的第二个参数)。

            onScroll={
                Animated.event([{nativeEvent:{contentOffset:{x:scrollX}}}])//scrollX = e.nativeEvent.contentOffset.x
            }

            onPanResponderMove = {
                Animated.event([null,//忽略原生事件
                {dx:pan.x,dy:pan.y}//从gestureState中解析出dx dy
                ])
            }

            》响应当前的动画值
                你可能会注意到这里没有一个明显得方法来在动画的过程中读取当前的值 -- 这是出于优化的角度考虑，有些值只有在原生代码运行阶段中才知道。
                如果你需要在js中响应当前的值，有两种方式：
                》spring.stopAnimation(callback)会停止动画并且把最终的值作为参数传递给回调函数callback——这在处理手势动画的时候非常有用。
                》spring.addListener(callback) 会在动画的执行过程中持续异步调用callback回调函数，提供一个最近的值作为参数。这在用于触发状态切换的时候非常有用，
                譬如当用户拖拽一个东西靠近的时候弹出一个新的气泡选项。不过这个状态切换可能并不会十分灵敏，因为它不像许多连续手势操作（如旋转）那样在60fps下运行。
        》使用原生动画驱动
            Animated的API是可序列化的 -- 即可转化为字符串表达以便通信或存储
            通过启用原生驱动，我们在启动动画前就把其所有配置信息都发送到原生端，利用原生代码在UI线程执行动画，而不用每一帧都在两端间来回沟通。
            如此一来动画一开始就完全脱离了js线程隐藏此时即便js线程被卡住，也不会影响到动画了。

            在动画中启用原生驱动，只需要在开始动画之前，在动画配置中加一行useNativeDriver: true即可
            Animated.timing(this.state.animatedValue, {
              toValue: 1,
              duration: 500,
              useNativeDriver: true, // <-- 加上这一行
            }).start();
            注意：动画值在不同的驱动方式之间是不能兼容的，因此如果你在某个动画中启用了原生驱动，那么所有和此动画依赖相同的动画值得其他动画也必须启用原生驱动。

            原生驱动还可以在Animated.event中使用。这对于跟随滚动位置的动画特别有用，因为没有本机驱动程序，动画将始终在手势后面运行一个框架，
            这是由于react native的异步特性。
            <Animated.ScrollView // <-- 使用Animated ScrollView wrapper
              scrollEventThrottle={1} // <-- 设为1以确保滚动事件的触发频率足够密集
              onScroll={Animated.event(
                [{ nativeEvent: { contentOffset: { y: this.state.animatedValue } } }],
                { useNativeDriver: true } // <-- 加上这一行
              )}
            >
              {content}
            </Animated.ScrollView>
    》LayoutAnimation -- https://github.com/facebook/react-native/blob/master/Libraries/LayoutAnimation/LayoutAnimation.js
        LayoutAnimation允许你在全局范围内创建和更新动画，这些动画会在下一次渲染或布局周期运行。它常用来更新flexbox布局，因为他可以无需测量或计算特定属性就能
        直接产生动画。尤其是当布局变化可能影响到父节点(如：查看更多 -- 展开动画即增加父节点的尺寸又会将位于本行之下的所有行向下推动)时，如果不使用LayoutAnimation,
        可能就需要显示声明组件的坐标，才能使得所有受影响的组件能够同步运行动画。

        注意：尽管LayoutAnimation非常强大且有用，但它对动画本身的控制没有Animated或其他动画库那样方便，所以如果你使用LayoutAnimation无法实现一个效果，那可能还是要考虑其他方案。

        另外如果要在Android上适应LayoutAnimation，那么目前还需要再UIManager中启用：
        UIManager.setLayoutAnimationEnabledExperimental && UIManager.setLayoutAnimationEnabledExperimental(true);

        import React from 'react'
        import {NativeModules,LayoutAnimation,Text,TouchableOpacity,StyleSheet,View} from 'react-native'

        //android需要启动
        const {UIManager} = NativeModules;
        UIManager.setLayoutAnimationEnabledExperimental && UIManager.setLayoutAnimationEnabledExperimental(true);

        export default class App extends React.Component{
            state = {
                w:100,
                h:100
            }

            _onPress = () =>{
                //更新动画
                LayoutAnimation.spring();
                this.setState({w: this.state.w + 15, h: this.state.h + 15})
            }

            render(){

                return(
                    <View style={styles.container}>
                        <View style={[styles.box,{width:this.state.w,height:this.state.h}]}/>
                        <TouchableOpacity onPress={this._onPress}>
                            <View style={styles.button}>
                                <Text style={styles.buttonText}>点我啊！</Text>
                            </View>
                        </TouchableOpacity>
                    </View>
                );
            }
        }

        const styles = StyleSheet.create({
            container:{
                flex:1,
                alignItems:'center',
                justifyContent:'center'
            },
            box:{
                width:200,
                height:200,
                backgroundColor:'red'
            },
            button:{
                backgroundColor:'black',
                paddingHorizontal:20,
                paddingVertical:15,
                marginTop:15
            },
            buttonText:{
                color:'#fff',
                fontWeight:'bold'
            }
        });
    》其他注意事项
        》requestAnimationFrame
            requestAnimationFrame是一个对浏览器标准API的兼容实现，它接受一个函数作为唯一的参数，并在下一次重绘之前调用此函数。一些基于
            js的动画库高度依赖于这个API，通常你不必直接调用它 -- 那些动画库会替你管理好帧的更新。
        》setNativeProps
            正如直接操作文档所说，setNativeProps方法可以使我们直接修改原生视图的组件的属性，而不需要使用setState来重新渲染整个组件树。
            如果我们要更新组件有一个非常深的内嵌结构，并且没有使用shouldComponentUpdate来优化，那么使用setNativeProps就将大有裨益。

            如果你发现你的动画丢帧（低于60帧每秒），可以尝试使用setNativeProps或者shouldComponentUpdate来优化它们。Or you could run
            the animations on the UI thread rather than the JavaScript thread with the useNativeDriver option(http://facebook.github.io/react-native/blog/2017/02/14/using-native-driver-for-animated.html)。你还可以考虑将部分计算
            工作放在动画完成之后进行，这时可以使用InteractionManager。你还可以使用应用内的开发者菜单中的“FPS Monitor”工具来监控应用的
            帧率。
19.无障碍功能
    iOS和Android原生app的无障碍功能(accessibility);
    accessibility -- 即为残障人士提供便利。iOS和android都提供了便于残障人士无障碍使用App的API。此外，两个平台都提供了整套的辅助技术，如：都针对
    视力受损人士的读屏软件(iOS的VoiceOver和Android的TalkBack)。同样地，在React Native中我们也封装了对应的API使开发者能够在APP中集成无障碍功能。

    注意：iOS和Android在具体方法上会有所区别，因此React Native的实现也会因平台而异。

    》使App能够无障碍使用

        》无障碍功能属性
            accessible(iOS,Android),设置为true表示当前视图是一个无障碍元素。无障碍元素会将其所有子组件视为一整个可以选中的组件，默认情况下
            所有可点击组件(Touchable系列组件)都是无障碍元素。

            在Android上，React Native视图的'accessible={true}'属性会被转义为原生视图对应的'focusable={true}'属性。
                <View accessible={true}>
                  <Text>text one</Text>
                  <Text >text two</Text>
                </View>
                //上面例子中，当父视图开启无障碍属性后，我们就无法单独选中'text one'和'text two'而只能选中整个父视图

            》无障碍标签accessibilityLabel(iOS,Android)
                当一个视图启用无障碍属性后，最后再加上一个accessibilityLabel，这样可以让使用VoiceOver的人们清楚地知道自己选中了什么。
                VoiceOver会读出选中元素的无障碍标签。

                设定accessibilityLabel属性并赋予一个字符串内容即可在视图中启用无障碍标签：
                    <TouchableOpacity accessible={true} accessibilityLabel={'Tap me!'} onPress={this._onPress}>
                      <View style={styles.button}>
                        <Text style={styles.buttonText}>Press me!</Text>
                      </View>
                    </TouchableOpacity>
                    //如果不在TouchableOpacity上设置无障碍标签，那么其默认值就会是"Press me!"（即Text子组件的文本值）。
                    //此时无障碍标签是通过自动取所有Text子节点的值，然后用空格连起来生成。
            》无障碍元素特性accessibilityTraits(iOS)
                无障碍元素特性可以使VoiceOver的用户知道自己选中了的是什么类型的元素，是文本标签还是按钮？accessibilityTraits回答了这个问题。
                设定accessibilityTraits属性并赋予以下一个或多个(以数组的形式)特性字符串即可启用无障碍元素特性：
                    none 无特性元素。
                    button 具有按钮特性。
                    link 具有链接特性。
                    header 作为内容区域的头部（比如导航栏的标题）。
                    search 用作搜索框的文本框。
                    image 具有图片特性。可以和按钮或链接等连用。
                    selected 元素被选中时使用。比如表格中被选中的一行或是segmented control中被选中的一个按钮。
                    plays 在元素被点击后播放音效时使用。
                    key 元素作为虚拟键盘的一个键使用。
                    text 具有不可修改的文本的特性。
                    summary 在App冷启动（指完全退出后台后再进入）时提供当前的简要总结信息的元素。比如当天气应用冷启动时，显示当前天气情况的元素就会被标记为summary。
                    disabled 在元素被禁用，不接受用户输入时使用。
                    frequentUpdates 有些元素会频繁更新其标签或值，但我们又不希望太频繁地接受到通知，那么就使用这一特性标记。这一特性标记会使无障碍功能的客户端隔一段时间后再去检查变化（避免频繁打扰用户）。秒表就是个典型的例子。
                    startsMedia 在元素启动一个多媒体会话时使用（比如播放电影或是录音），此时不应该被VoiceOver这样的辅助技术打断。
                    adjustable 元素具有可调整的特性（比如一个滑块）。
                    allowsDirectInteraction 在元素可以接受VoiceOver用户的直接触摸交互时使用（比如展示钢琴键盘的视图）。
                    pageTurn 用于通知VoiceOver当前页面已经阅读完毕，可以滚动到下一个页面了。
            》无障碍元素的点击事件onAccessibilityTap(iOS)
                使用这个属性来绑定一个自定义的事件处理函数，这个函数会在当用户双击某个已经选中的无障碍元素时调用
            》MagicTap 双指双击事件onMagicTap(iOS)
                使用这一属性来绑定一个自定义的事件处理函数，这一函数会在当用户执行"magic tap"操作（即使用两个指头来双击）时调用。
                magic tap的事件处理函数应该做与当前组件相关性最高的操作，比如在电话应用中，magic tap的操作就应该接通电话，或是挂断已经接通的电话。
                如果当前选中的元素并没有onMagicTap函数，则系统会自动遍历视图层，直到找到一个可以响应此操作的。
            》无障碍组件类型accessibilityComponentType(Android)
                在某些情况下，我们也希望告知用户他选中的组件的类型(如是按钮)。如果我们使用的是原生按钮，这个行为会自动进行，但既然我们主要使用js
                则还需要为android的TalkBack技术提供更多信息，要实现这一点，就必须为所有UI组件提供accessibilityComponentType属性，如可以指定：button，radiobutton_checked以及radiobutton_unchecked等值。
                <TouchableWithoutFeedback accessibilityComponentType=”button”
                  onPress={this._onPress}>
                  <View style={styles.button}>
                    <Text style={styles.buttonText}>Press me!</Text>
                  </View>
                </TouchableWithoutFeedback>
                //TouchableWithoutFeedback在TalkBack中被声明为一个原生按钮
            》无障碍的动态区域accessibilityLiveRegion (Android)
                组件发生动态变化时，我们希望TalkBack能够提醒用户，这一行为可以通过设置accessibilityLiveRegion属性来实现。具体值可以设置为
                none、polite以及assertive。
                》none 辅助服务不应该提醒用户当前视图的变化。
                》polite 辅助服务应该提醒用户当前视图的变化。
                》assertive 辅助服务应该立即打断当前的语音会话，提醒用户当前视图的变化。

                <TouchableWithoutFeedback onPress={this._addOne}>
                  <View style={styles.embedded}>
                    <Text>Click me</Text>
                  </View>
                </TouchableWithoutFeedback>
                <Text accessibilityLiveRegion="polite">
                  Clicked {this.state.count} times
                </Text>
                //上面这个例子中，_addOne方法会改变state.count这个变量。那么只要用户点击了 TouchableWithoutFeedback，
                //TalkBack就会读出Text组件中的值，因为它设置了accessibilityLiveRegion=”polite”属性。
            》无障碍功能优先级importantForAccessibility (Android)
                如果有两个UI组件同时层叠覆盖在父视图上，那么默认的无障碍功能的焦点位置就可能难以预料。importantForAccessibility属性解决了
                这个问题，它可以控制某个视图是否触发无障碍功能事件，以及是否将其报告给辅助服务，具体值可以为 auto  yes  no 和no-hide-descendants(最后一个值会强制辅助服务忽略当前组件及其所有子组件)
                <View style={styles.container}>
                  <View style={{position: 'absolute', left: 10, top: 10, right: 10, height: 100,
                    backgroundColor: 'green'}} importantForAccessibility=”yes”>
                    <Text> First layout </Text>
                  </View>
                  <View style={{position: 'absolute', left: 10, top: 10, right: 10, height: 100,
                    backgroundColor: 'yellow'}} importantForAccessibility=”no-hide-descendant”>
                    <Text> Second layout </Text>
                  </View>
                </View>
                //上面这个例子里，第二个View的组件对于TalkBack和其他一些辅助服务来说是完全不可见的。
                //这样我们就可以轻易地把两个视图覆盖到同一个父容器上，而不用担心影响TalkBack服务。
            》发送无障碍功能的相关事件(android)
                有时候需要在UI组件上主动触发一个无障碍功能的事件(如：当某个自定义的视图出现在屏幕上或某个自定义的单选框被选中)。为此
                Native UIManager模块提供了一个sendAccessibilityEvent方法，它接受两个参数：view标签和事件类型。
                _onPress: function() {
                  this.state.radioButton = this.state.radioButton === “radiobutton_checked” ?
                  “radiobutton_unchecked” : “radiobutton_checked”;
                  if (this.state.radioButton === “radiobutton_checked”) {
                    RCTUIManager.sendAccessibilityEvent(
                      React.findNodeHandle(this),
                      RCTUIManager.AccessibilityEventTypes.typeViewClicked);
                  }
                }

                <CustomRadioButton
                  accessibleComponentType={this.state.radioButton}
                  onPress={this._onPress}/>
                //在上面这个例子里我们创建了一个自定义的单选框（CustomRadioButton），
                //并且使其具有了和原生单选框一样的无障碍功能。具体来说，也就是TalkBack可以正确地通知用户当前选项的变更了。
            》测试VoiceOver(iOS)
                要开启VoiceOver功能，先打开iOS设备的设置选项。点击'通用',然后是'辅助选项'，你会看到很多为残疾人群使用手机减少障碍的工具。
                如：更大的字体、更高的对比度以及VoiceOver。

                在“视觉”菜单下点击VoiceOver，将开关置为打开状态即可启用。

                在辅助选项的最底部，有一个“辅助选项快捷键”，开启之后可以通过点击三次Home按钮来快速关闭或打开VoiceOver工具。
20.定时器
    定时器是一个应用中非常重要的部分，React Native实现了和浏览器一致的定时器Timer。

    》setTimeout, clearTimeout
    》setInterval, clearInterval
    》setImmediate, clearImmediate
    》requestAnimationFrame, cancelAnimationFrame

    requestAnimationFrame(fn)和setTimeout(fn,0)不同，前者会在每帧刷新之后执行一次，而后者则会尽可能快的执行(在iPhone5s上有可能每秒1000次以上)。

    setImmediate则会在当js执行块结束的时候执行，就在将要发送批量响应数据到原生之前。注意如果你在setImmediate的回调函数中又执行了setImmediate，它
    会紧接着立刻执行，而不会再调用之前等待原生代码。

    Promise的实现就是使用了setImmediate来执行异步调用的。

    》InteractionManager
        原生应用感觉如此流畅的一个重要原因就是在互动和动画的过程中避免繁重的操作。在React Native里，我们目前受到限制，因为我们只有一个js
        执行线程。不过你可以用InteractionManager来确保在执行繁重工作之前所有的交互和动画都已经处理完毕。

        //应用可以通过一下代码来安排一个任务，使其在交互结束之后执行：
        InteractionManager.runAfterInteractions(() => {
           // ...需要长时间同步执行的任务...
        });

        //和前面几个任务安排方法对比一下
        》requestAnimationFrame()；//用来执行在一段时间内控制视图动画的代码
        》setImmediate/setTimeout/setInterval //在稍后执行代码，注意这有可能会延迟当前正在进行的动画
        》runAfterInteractions//在稍后执行代码，不会延迟当前进行的动画
        触摸处理系统会把一个或多个进行中的触摸操作认定为交互，并且会将runAfterInteractions()的回调函数延迟执行，直到所有的触摸操作都结束或取消了。

        InteractionManager还允许应用注册动画，在动画开始创建一个交互句柄，然后再结束的时候清除它。
        var handle = InteractionManager.createInteractionHandle();
        // 执行动画... (`runAfterInteractions`中的任务现在开始排队等候)

        // 在动画完成之后
        InteractionManager.clearInteractionHandle(handle);
        // 在所有句柄都清除之后，现在开始依序执行队列中的任务
    》务必在卸载组件前清除定时器
        发现很多React Native应用中发生致命错误(闪退)是与计时器有关的。具体来说，是在某个组件被卸载之后，计时器仍然运行。要
        解决这个问题，只需要在卸载组件的时候 及时清除定时器：
        import React,{
          Component
        } from 'react';

        export default class Hello extends Component {
          componentDidMount() {
            this.timer = setTimeout(
              () => { console.log('把一个定时器的引用挂在this上'); },
              500
            );
          }
          componentWillUnmount() {

            // 如果存在this.timer，则使用clearTimeout清空。
            // 如果你使用多个timer，那么用多个变量，或者用个数组来保存引用，然后逐个clear
            this.timer && clearTimeout(this.timer);
          }
        };
21.直接操作
    有时候我们需要直接改动组件并触发局部的刷新，但不使用state或props。比如在浏览器中使用React库，有时候会需要直接修改一个DOM节点，而在手机
    APP中操作View时也会碰到同样的情况。在React Native中，setNativeProps就是等价于直接操作DOM节点的方法。

    》什么时候使用setNativeProps》
        在不得不频繁刷新而又遇到了性能瓶颈的时候。直接操作组件并不是应该经常使用的工具，一般来说只有用来创建连续的动画。同时避免渲染组件结构
        和同步太多视图变化所带来的大量开销。setNativeProps是一个简单粗暴的方法，它直接在底层DOM、UIView等。而不是React组件中记录state，这样会
        使得代码逻辑难以理清，所以在使用这个方法之前请尽量先尝试使用setState和shouldComponentUpdate方法来解决问题。

    》setNativeProps 与 TouchableOpacity
        TouchableOpacity这个组件就是在内部使用了setNativeProps方法来更新其子组件的透明度：
            setOpacityTo: function(value) {
              // Redacted: animation related code
              this.refs[CHILD_REF].setNativeProps({
                opacity: value
              });
            },
        由此我们可以写下面代码：子组件可以响应点击事件，更改自己的透明度。而子组件自身并不需要处理这件事，也不需要再实现中做任何修改。
            <TouchableOpacity onPress = {this._handlePress}>
                <View style={styles.button}>
                    <Text>Press me!</Text>
                </View>
            </TouchableOpacity>
        如果不使用setNativeProps这个方法来实现这需求，那么一种可能的办法是把透明度保存到state中，然后再onPress事件触发时更新这个值：
            getInitialState(){
                return {myButtonOpacity:1}
            }

            render(){
                return (
                    <TouchableOpacity
                        onPress={ () => this.setState({myButtonOpacity:.5})}
                        onPressOut={ () => this.setState({myButtonOpacity:1})}
                    >
                        <View style={[styles.button,{opacity:this.state.myButtonOpacity}]}>
                            <Text>Press me!</Text>
                        </View>
                    </TouchableOpacity>
                );
            }
            比起之前的例子，这一做法会消耗大量的计算 —— 每一次透明值变更的时候React都要重新渲染组件结构，
            即便视图的其他属性和子组件并没有变化。一般来说这一开销也不足为虑，但当执行连续的动画以及响应用
            户手势的时候，只有正确地优化组件才能提高动画的流畅度。
    》复合组件与setNativeProps
        复合组件并不是单纯的由一个原生视图构成，所以你不能对其直接使用setNativeProps，如下面案例：
        var MyButton = React.createClass({
            render(){
                return (
                    <View>
                        <Text>{this.props.label}</Text>
                    </View>
                );
            }
        });

        var App = React.createClass({
            render(){
                return (
                    <TouchableOpacity>
                        <MyButton label='Press me!'/>
                    </TouchableOpacity>
                );
            }
        });
        //上面例子报错：Touchable child must either be native or forward setNativeProps to a native component，这是因为MyButton
        并非直接由原生视图构成，而我们只能给原生视图设置透明值。你可以尝试这样去理解：如果你通过React.createClass方法自定义了一个组件，
        直接给它设置样式prop是不会生效的，你得把样式props层层向下传递给子组件，直到子组件是一个能够直接定义样式的原生组件。同理，我们
        也需要把setNativeProps传递给由原生组件封装的子组件。

        》将setNativeProps传递给子组件
            具体要做的就是在我们自定义组件中在封装一个setNativeProps方法，其内容为对合适的子组件调用真正的setNativeProps方法，并传递要设置
            的参数。
            var MyButton = React.createClass({
                setNativeProps(nativeProps){
                    this._root.setNativeProps(nativeProps);
                },

                render(){
                    return (
                        <View ref={ component => this._root = component} {...this.props}>
                            <Text>{this.props.label}</Text>
                        </View>
                    );
                }
            });

    》避免和render方法的冲突
        如果要更新一个由render方法来维护的属性，则可能会碰到 一些出人意料的bug。因为每次组件重新渲染都可能引起属性变化，这样一来之前
        通过setNativeProps所设定的值就被完全忽略和覆盖掉了。
    》setNativeProps与shouldComponentUpdate
        通过巧妙运用 shouldComponentUpdate方法，可以避免重新渲染那些实际没有变化的子组件所带来的额外开销，此时使用setState的性能已经可
        以与setNativeProps相媲美了。
22.调式
    》访问App内的开发菜单
        你可以通过摇晃设备或是选择iOS模拟器的Hardware菜单中的Shake Gesture选项来打开开发菜单。另外如果是在iOS模拟器中运行
        还可以按下command+d ，android模拟器 command + M快捷键。(windows上可能是F1或F2)。

        注意：在发布版本中 开发者菜单会被关闭。
    》刷新js
        传统的原生应用开发中，每次修改都需要重新编译，但在RN中你只需要刷新一下js代码就能立刻看到变化。
        具体的操作：在开菜单中点击reload选项。也可以在iOS模拟器中按下command + r,android模拟器上对应的
        则按两下r(注意：某些RN版本可能在windows中reload无效，请等待官方修复)。

        注意：如果在iOS模拟器中按下 command+r 没有变化，则注意检查hardware菜单中，keyboard选项下的 connect hardware keyboard是否被选中。
    》自动刷新
        选着开发菜单中的Enable Live Reload可以开启自动刷新，这样可以节省开发时间。

        更神奇的是，你还可以保持应用的当前运行状态，修改后的js文件会自动注入进来。要实现这个特性只需要开启开发菜单中的Hot Reloading选项。
        某些情况下hot reload并不能顺序实施，如果碰到任何界面刷新上的问题，可以尝试手动完全刷新。

        但有时候必须要重新编译应用才能使修改生效：
        》增加了新的资源(比如给iOS的Images.xcassets或是Andorid的res/drawable文件夹添加了图片)
        》更改了任何的原生代码（objective-c/swift/java）
    》应用内的错误与警告提示(红屏和黄屏)
        红屏或黄屏提示都只会在开发版本中显示，正式的离线包中是不会显示的。

        》红屏错误
            应用内的报错会以全屏红色显示在应用中(调式模式下)，我们称为红屏(red box)报错,你可以使用console.error()来手动触发
            红屏错误。
        》黄屏警告
            应用内的警告会以全屏黄色显示在应用中(调式模式下)，我们称为黄屏(yellow box)报错。点击警告可以查看详情或忽略掉。
            和红屏报错类似，你可以使用console.warn()来手动触发黄屏警告。在默认情况下，开发模式中启用了黄屏警告，可以通过
            以下代码关闭：
            console.disableYellowBox = true;
            console.warn('YellowBox is disabled.');

            //你也可以通过代码屏蔽指定的警告，像下面这样调用ignoreWarnings方法，参数为一个数组：
            YellowBox.ignoreWarnings(['Warning: ']);//数组中的字符串就是要屏蔽的警告的开头的内容。

        注意：红屏和黄屏在发布版本中都是自动禁用的。
    》访问控制台日志
        在运行RN应用时，可以在终端中运行如下命令来查看控制台的日志：
        react-native log-ios
        react-native log-android

        此外，也可以在iOS模拟器的菜单中选择debug --》open system log来查看。
        如果是android应用，无论是运行在模拟器还是真机上，都可以通过在终端命令行运行 adb logcat *:S ReactNative:V ReactNativeJS:V命令来查看。
    》Chrome开发者工具
        在开发者菜单中选择 debug js remotely 选项，即可以开始在chrome中调试js代码。点击这个选项的同时会自动打开调式页面http://localhost:8081/debugger-ui。
        在chrome的菜单中选择 tools + developer tools可以打开开发者工具，也可以通过键盘快捷键来打开(mac上是command + option + I，windows上是
        ctrl + shift + i 或f12)。打开有异常时暂停(pause on caught exception)选项，能够获得更好的开发体验。

        注意：chrome中并不能直接看到app的用户界面，而只能提供console的输出，以及在sources项中断点调式js脚本。
    》react developer tools
        使用react native 0.43或更高的版本，您可以使用独立版本的React Developer工具来调试React组件层次结构。要使用它，请在全局环境中安装“react-devtools”包。
        npm install -g react-devtools

        注意：react-devtools依赖于electron，而electron需要到国外服务器下载二进制包，所以国内用户这一步很可能卡住。此时请在环境变量中添加
        electron专用的国内镜像源ELECTRON_MIRROR="https://npm.taobao.org/mirrors/electron/"，然后再尝试安装react-devtools。

        //安装完成后再命令行中执行react-devtools即可启动此工具：
        react-devtools
        //它应该在几秒之内链接到你的模拟器

        注意：如果你避免全局安装react-devtools,你可以添加react-devtools作为一个项目的依赖：
        yarn add --dev react-devtools//安装
        yarn react-devtools//运行
        或
        npm install --save-dev react-devtools
        在package.json中scripts添加："react-devtools": "react-devtools"
        npm run react-devtools//运行

        》和react native inspector集成
            你可以打开app developer menu并且选择 show inspector。它会弹出一个模态框，让你选择ui element并且查看它的相关信息。

            》show inspector
                当react-devtools是运行时，inspector会进入一个特殊的模式，并使用devTools作为主ui。在此模式下，在模拟器中单击
                某个东西将会在DevTools中打开相关的组件。

                你能够选择 hide inspector来退出这个模式。
    》使用chrome开发者工具来在设备上调试
        对于iOS真机来说，需要打开 RCTWebSocketExecutor.m文件,然后将其中的localhost改为你电脑的IP地址，最后启用开发者菜单中的debug js remotely选项。

        对于android 5.0+ 设备(包括模拟器)来说，将设备通过USB链接到电脑上后，可以使用adb命令行工具来设定从设备到电脑的端口转发：
        adb reverse tcp:8081 tcp:8081
        如果设备android版本在5.0以下，则可以在开发者菜单中选择'Dev Settings - Debug server host for device',然后再其中填入电脑的ip地址:端口。

        注意：如果在chrome调式时遇到一些问题，那么有可能是某些chrome的插件引起的，试着禁用所有的插件，然后逐个启用，以确定是否某个插件影响到了调试。
    》使用自定义的js调试器来调试
        如果想用其他的js调试器来替代chrome，可以设置一个名为REACT_DEBUGGER的环境变量，其值为启动自定义调试器的命令。调试的流程依然是从开发者菜单
        中的debug js remotely选项开始。
        被指定的调试器需要知道项目所在的目录(可以一次传递多个目录参数，以空格隔开)。例如，如果你设定了REACT_DEBUGGER="node /某个路径/launchDebugger.js
        --port 2345 --type ReactNative"，那么启动调试器的命令就应该是node /某个路径/launchDebugger.js --port 2345 --type ReactNative /某个路径/你的RN项目目录。

        注意：以这种方式执行的调试器最好是一个短进程的(short-lived processes)，同时最好也不要超过200k的文字输出。
    》在Android上使用Stetho来调试
        在android/app/build.gradle文件中添加：
        compile 'com.facebook.stetho:stetho:1.3.1'
        compile 'com.facebook.stetho:stetho-okhttp3:1.3.1'

        在android/app/src/main/java/com/{yourAppName}/MainApplication.java文件中添加：
        import com.facebook.react.modules.network.ReactCookieJarContainer;
        import com.facebook.stetho.Stetho;
        import okhttp3.OkHttpClient;
        import com.facebook.react.modules.network.OkHttpClientProvider;
        import com.facebook.stetho.okhttp3.StethoInterceptor;
        import java.util.concurrent.TimeUnit;

        在android/app/src/main/java/com/{yourAppName}/MainApplication.java文件中添加：
        public void onCreate() {
              super.onCreate();

              Stetho.initializeWithDefaults(this);
              OkHttpClient client = new OkHttpClient.Builder()
              .connectTimeout(0, TimeUnit.MILLISECONDS)
              .readTimeout(0, TimeUnit.MILLISECONDS)
              .writeTimeout(0, TimeUnit.MILLISECONDS)
              .cookieJar(new ReactCookieJarContainer())
              .addNetworkInterceptor(new StethoInterceptor())
              .build();
              OkHttpClientProvider.replaceOkHttpClient(client);
        }

        运行react-native run-android

        打开一个新的chrome选项卡，在地址栏中输入 chrome://inspect并回车，在页面中选择 Inspect device(标有Powered
        by stetho字样)
    》调试原生代码
        在和原生代码打交道时(如：编写原生模块)，可以直接从android studio或xcode中启动应用，并利用这些IDE的内置功能来调试(如设置断点)。
        这一方面和开发原生应用并无二至。
    》性能监测
        你可以在开发者菜单中选择Pref Monitor选项以开启一个悬浮层，其中会显示应用的当前帧数。

23.自动化测试

24.js环境
    在使用React Native时，你的js代码将会运行在两个不同的环境上：

    在iOS、Android的模拟器或真机上，React Native使用的是JavaScriptCore，也就是Safari所使用的js引擎。但是在iOS上JavaScriptCore
    并灭有使用及时编译技术(JIT),因为在iOS中应用无权拥有可写可执行的内存页(因而无法动态生成代码)。
    在使用chrome调试时，所有js代码都运行在chrome中，并通过WebSocket与原生代码通信，此时的运行环境是V8引擎。

    虽然两个环境非常类似，但开发者还是可能碰到一些不一致的地方。未来我们很可能会尝试一些其他的js引擎，所以尽量避免使用依赖于
    特定环境的代码。

    》js语法的转换器
        语法转换器可以使编写代码的过程更加享受，因为开发者可以借助转换器直接使用新的js语法标准而无需等待js解释器的支持。

        React Native从.5之后开始已经内置了Babel转换器，可以查看Babel文档来了解它可以转换的语法。
        目前React Native默认开启的语法转换特性：
        》ES5
            保留关键字 promise.catch(function(){})
        》ES6
            箭头函数 Arrow functions ：() => {}
            块级作用于 Block scoping ：let a = 'hi'
            数组的扩展运算 Call spread ：Math.max(...array)
            类class ：class C extends React.Component { render() { return <View />; } }
            常量Constants : const answer = 42;
            解构Destructuring：var {isActive, style} = this.props;
            for...of：for (var num of [1, 2, 3]) {}
            模块Modules:import React, { Component } from 'react';
            动态属性键Computed Properties:var key = 'abc'; var obj = {[key]: 10};
            对象方法的简写 Object consise method:var obj = { method() { return 10; } };
            对象属性的简写Object short notaion:var name = 'vjeux'; var obj = { name };
            参数的扩展运算rest params :function(type, ...args) { }
            字符串模板template literals:var who = 'world'; var str = `Hello ${who}`;
        》ES7
            对象的扩展运算Object Spread：var extended = { ...obj, a: 10 };
            参数列表末尾允许放置逗号Function trailing comma:function f(a, b, c,) { }
            Async函数: async function doStuffAsync() { const foo = await doOtherStuffAsync(); }
        》其他特性
            JSX: <View style={{color: 'red'}} />
            Flow: function foo(x: ?number): string {}//facebook自己推出的
    》接口兼容 Polyfills
        许多标准功能也都在支持的js运行环境上做了兼容支持。
        》浏览器
            console.{log, warn, error, info, trace, table}
            CommonJS require
            XMLHttpRequest, fetch
            {set, clear}{Timeout, Interval, Immediate}, {request, cancel}AnimationFrame
            navigator.geolocation
        》ES6
            Object.assign
            String.prototype.{startsWith, endsWith, repeat, includes}
            Array.from
            Array.prototype.{find, findIndex}
        》ES7
            Object.{entries, values}
        》其他特性
            __DEV__

25.性能
    使用React Native替代基于webView的框架来开发app的理由，就是为了使App可以达到每秒60帧(足够流畅)，并且能有类似原生app的外观和手感。
    因此我们尽可能的优化React Native，使开发者能集中精力处理app的业务逻辑而不是费心考虑性能。

    》关于 帧
        老一辈人常常把电影称为“移动的画”，是因为视频中逼真的动态效果其实是一种幻觉，这种幻觉是由一组静态的图片以一个稳定的速度
        快速变化所产生的。我们把这组图片中的每一张图片叫做一帧，而每秒钟显示的帧数直接的影响了视频（或者说用户界面）的流畅度和真
        实感。iOS设备提供了每秒60的帧率，这就留给了开发者和UI系统大约16.67ms来完成生成一张静态图片（帧）所需要的所有工作。如果在
        这分派的16.67ms之内没有能够完成这些工作，就会引发‘丢帧’的后果，使界面表现的不够流畅。

        下面要讲的事情可能更为复杂：请先调出你应用的开发菜单，打开Show FPS Monitor. 你会注意到有两个不同的帧率.
    》js帧率
        对大多数React Native应用来说，业务逻辑是运行在JavaScript线程上的。这是React应用所在的线程，也是发生API调用，以及处理触摸事件等操作
        的线程。更新数据到原生支持的视图是批量进行的，并且在事件循环每进行一次的时候被发送到原生端，这一步通常会在一帧时间结束之前处理完（
        如果一切顺利的话）。如果JavaScript线程有一帧没有及时响应，就被认为发生了一次丢帧。 例如，你在一个复杂应用的根组件上调用了this.setState，
        从而导致一次开销很大的子组件树的重绘，可想而知，这可能会花费200ms也就是整整12帧的丢失。此时，任何由JavaScript控制的动画都会卡住。只要卡
        顿超过100ms，用户就会明显的感觉到。

        这种情况经常发生在Navigator的切换过程中：当你push一个新的路由时，JavaScript需要绘制新场景所需的所有组件，以发送正确的命令给原生端去
        创建视图。由于切换是由JavaScript线程所控制，因此经常会占用若干帧的时间，引起一些卡顿。有的时候，组件会在componentDidMount函数中做一
        些额外的事情，这甚至可能会导致页面切换过程中多达一秒的卡顿。

        另一个例子是触摸事件的响应：如果你正在JavaScript线程处理一个跨越多个帧的工作，你可能会注意到TouchableOpacity的响应被延迟了。这是因
        为JavaScript线程太忙了，不能够处理主线程发送过来的原始触摸事件。结果TouchableOpacity就不能及时响应这些事件并命令主线程的页面去调整
        透明度了。
    》主线程即UI线程帧率
        很多人会注意到，NavigatorIOS的性能要比Navigator好的多。原因就是它的切换动画是完全在主线程上执行的，因此不会被JavaScript线程上的掉帧所影响。

        同样，当JavaScript线程卡住的时候，你仍然可以欢快的上下滚动ScrollView，因为ScrollView运行在主线程之上（尽管滚动事件会被分发到JS线程，
        但是接收这些事件对于滚动这个动作来说并不必要）。
    》性能问题的常见原因
        》console.log语句
            在运行打好了离线包的应用时，控制台的打印语句可能会极大的拖累js线程。注意有些第三方调试库也可能包含控制台打印语句，如：redux-logger,
            所以在发布应用前务必仔细检查，确保全部移除。

            这里有个小技巧在发布时屏蔽掉所有的console.*调用。React Native中有个全局变量__DEV__用于指示当前运行环境是否是开发环境。我们可以据此在
            正式环境中替换掉原系统原先的console实现。
                if (!__DEV__) {
                  global.console = {
                    info: () => {},
                    log: () => {},
                    warn: () => {},
                    debug: () => {},
                    error: () => {},
                  };
                }
            //这样在打包发布时，所有的控制台语句就会被自动替换为空函数，而在调式时它们仍然会被正常调用。

            还有个babel插件可以帮你移除所有的console.*调用，首先需要使用yarn add --dev babel-plugin-transform-remove-console来安装，
            然后再项目根目录下编译(或新建)一个名为.babelrc的文件，在其中加入：
                {
                  "env": {
                    "production": {
                      "plugins": ["transform-remove-console"]
                    }
                  }
                }
                //这样在打包发布时，所有的控制台语句就会被自动移除，而在调试时它们仍然会被正常调用。
        》开发模式 dev = true
            JavaScript线程的性能在开发模式下是很糟糕的。这是不可避免的，因为有许多工作需要在运行的时候去做，
            譬如使你获得良好的警告和错误信息，又比如验证属性类型（propTypes）以及产生各种其他的警告。
        》缓慢的导航器Navigator切换
            如之前说，Navigator的动画是由JavaScript线程所控制的。想象一下“从右边推入”这个场景的切换：
            每一帧中，新的场景从右向左移动，从屏幕右边缘开始（不妨认为是320单位宽的的x轴偏移），最终移动
            到x轴偏移为0的屏幕位置。切换过程中的每一帧，JavaScript线程都需要发送一个新的x轴偏移量给主线程。
            如果JavaScript线程卡住了，它就无法处理这项事情，因而这一帧就无法更新，动画就被卡住了。

            长远的解决方法，其中一部分是要允许基于JavaScript的动画从主线程分离。同样是上面的例子，我们可
            以在切换动画开始的时候计算出一个列表，其中包含所有的新的场景需要的x轴偏移量，然后一次发送到主
            线程以某种优化的方式执行。由于JavaScript线程已经从更新x轴偏移量给主线程这个职责中解脱了出来，
            因此JavaScript线程中的掉帧就不是什么大问题了 —— 用户将基本上不会意识到这个问题，因为用户的
            注意力会被流畅的切换动作所吸引。

            新的React Navigation库的一大目标就是为了解决这个问题。React Navigation中的视图是原生组件，同时
            用到了运行在原生线程上的Animated动画库，因而性能表现十分流畅。
        》ListView初始化渲染太慢以及列表过长时滚动性能太差
            这是一个频繁出现的问题。因为iOS配备了UITableView，通过重用底层的UIViews实现了非常高性能的体验（相比之下ListView的性能没有那么好）。
            用React Native实现相同效果的工作仍正在进行中，但是在此之前，我们有一些可用的方法来稍加改进性能以满足我们的需求。
            》initialListSize
                这个属性定义了首次渲染中绘制的行数。如果我们关注于快速的显示出页面，可以设置initialListSize为1，然后会发现其他行在接下来的帧
                中被快速绘制到屏幕上，而每帧所显示的行数由pageSize所决定。
            》pageSize
                在初始渲染也就是initialListSize被使用之后，ListView将利用pageSize来决定每一帧所渲染的行数。默认为1 -- 但是如果你的页面很小
                而且渲染的开销不大的话，你会希望这个值更大一些，稍加调整，你会发现它所起到的作用。
            》scrollRenderAheadDistance
                在将要进入屏幕区域之前的某个位置，开始绘制一行，距离按像素计算。
                如果我们有一个2000个元素的列表，并且立刻全部渲染出来的话，无论是内存还是计算资源都会显得很匮乏，还很可能导致非常可怕的阻塞。
                因此该属性允许我们来指定一个超出视野范围之外所需要渲染的行数。
            》removeClippedSubviews
                当这一选项设置为true时，超出屏幕的子视图(同时overflow的值为hidden)会从它们的原生父视图中移除。这个属性可以在列表很长的时候提高滚动
                的性能。默认为false(.14版本后默认为true)。

                这是一个应用在长列表上极其重要的优化。Android上，overflow值总是hidden的，所以你不必担心没有设置它。而在iOS上，你需要确保在行容器
                上设置了overflow: hidden。
        》我的组件渲染太慢，我不需要立即显示全部
            这在初始浏览ListView时很常见，适当的使用它时获得稳定性性能的关键，就像之前所提到的，它可以提供一些手段在不同帧中来分开渲染页面，
            稍加改进就可以满足你的需求。此外要记住的是ListView也可以横向滚动。
        》在重绘一个几乎没有什么变化的页面时，JS帧率严重降低
            如果你正在使用一个ListView，你必须提供一个rowHasChanged函数，它通过快速的算出某一行是否需要重绘，来减少很多不必要的工作。
            如果你使用了不可变的数据结构，这项工作就只需检查其引用是否相等。

            同样的，你可以实现shouldComponentUpdate函数来指明在什么样的确切条件下，你希望这个组件得到重绘。如果你编写的是纯粹的组件
            （返回值完全由props和state所决定），你可以利用PureComponent来为你做这个工作。再强调一次，不可变的数据结构在提速方面非常
            有用 —— 当你不得不对一个长列表对象做一个深度的比较，它会使重绘你的整个组件更加快速，而且代码量更少。
        》由于在js线程中同时做了很多事情，导致js线程掉帧
            导航切换极慢是该问题的常见表现，在其他情形下，这种问题也可能会出现。使用InteractionManager是一个好的方法。但是如果在动画中为了
            用户体验的开销而延迟其他工作并不太能接受，那么你可以考虑一下使用LayoutAnimation。

            Animated的接口一般会在JavaScript线程中计算出所需要的每一个关键帧，而LayoutAnimation则利用了Core Animation，使动画不会被JS线程
            和主线程的掉帧所影响。

            注意：LayoutAnimation只工作在 一次性 的动画上('静态'动画) -- 如果动画可能会被中途取消，你还是需要使用Animated。
        》在屏幕上移动视图(滚动，切换，旋转)时，UI线程掉帧
            当具有透明背景的文本位于一张图片上时，或者在每帧重绘视图时需要用到透明合成的任何其他情况下，这种现象尤为明显。
            设置shouldRasterizeIOS或者renderToHardwareTextureAndroid属性可以显著改善这一现象。 注意不要过度使用该特性，否
            则你的内存使用量将会飞涨。在使用时，要评估你的性能和内存使用情况。如果你没有需要移动这个视图的需求，请关闭这一属性。
        》使用动画改变图片的尺寸时，UI线程掉帧
            在iOS上，每次调整Image组件的宽度或者高度，都需要重新裁剪和缩放原始图片。这个操作开销会非常大，尤其是大的图片。比起直
            接修改尺寸，更好的方案是使用transform: [{scale}]的样式属性来改变尺寸。比如当你点击一个图片，要将它放大到全屏的时候，就
            可以使用这个属性。
        》Touchable系列组件不能很好的响应
            有些时候，如果我们有一项操作与点击事件所带来的透明度改变或高亮效果发生在同一帧中，那么有可能在onPress函数结束之前我们都看不到
            这些效果。比如在onPress执行了一个setState的操作，这个操作需要大量计算工作并且导致了掉帧。对此的一个解决方案是将onPress处理函
            数中的操作封装到requestAnimationFrame中：
            handleOnPress() {
              // 谨记在使用requestAnimationFrame、setTimeout以及setInterval时
              // 要使用TimerMixin（其作用是在组件unmount时，清除所有定时器）
              this.requestAnimationFrame(() => {
                this.doExpensiveAction();
              });
            }
        》分析
            你可以利用内置的分析器来同时获取JavaScript线程和主线程中代码执行情况的详细信息。
            对于iOS来说，Instruments是一个宝贵的工具库，Android的话，你可以使用systrace，参见调试Android UI性能
26.升级
    时刻将React Native更新到最新的版本，可以获得更多API、视图、开发者工具以及其他有用的东西(注：官方开发任务繁重，人手紧缺，几乎不会对旧版本提供维护支持
    所以即便更新可能带来一些兼容上的变更，但建议开发者还是尽一切可能第一时间更新)。由于一个完整的React Native项目是由android项目 iOS项目和js项目组成的，
    且打包在一个npm包中，所以升级可能会有一些麻烦。我们会尽量简化这个流程。你在项目目录下使用react-native -v命令查看当前的版本。以下是目前所需的升级步骤：

    》基于Git的自动合并更新
        注意：现在你不需要运行npm install去下载新版本的React Native了，按照下面的步骤即可自动进行更新。

        》安装Git
            你需要安装Git，但这并不要求你自己使用Git去管理项目，只是我们的更新过程会使用到Git，安装Git后把git路径添加到PATH变量中。
        》安装react-native-git-upgrade工具模块
            npm install -g react-native-git-upgrade

            react-native-git-upgrade提供了豪华的一条龙自动合并更新流程，主要包含两个服务：
            》首先它会利用Git工具计算新旧版本文件间的差异并生成补丁
            》然后再用户的项目文件上应用补丁
        》运行更新命令
            react-native-git-upgrade //这样会直接把react native升级到最新版本

            react-native-git-upgrade X.Y.Z //这样会把react native升级到指定的x.y.z版本

            //升级过程会如丝般顺滑。当然在少数情况下，取决于具体的版本和你修改的程度，Git的合并算法也可能遭遇失败产生一些冲突，需要你人工介入。
        》解决冲突
            文件中的冲突会以分割线隔开，并清楚的标记出处，如下面：
            13B07F951A680F5B00A75B9A /* Release */ = {
              isa = XCBuildConfiguration;
              buildSettings = {
                ASSETCATALOG_COMPILER_APPICON_NAME = AppIcon;
            <<<<<<< ours
                CODE_SIGN_IDENTITY = "iPhone Developer";
                FRAMEWORK_SEARCH_PATHS = (
                  "$(inherited)",
                  "$(PROJECT_DIR)/HockeySDK.embeddedframework",
                  "$(PROJECT_DIR)/HockeySDK-iOS/HockeySDK.embeddedframework",
                );
            =======
                CURRENT_PROJECT_VERSION = 1;
            >>>>>>> theirs
                HEADER_SEARCH_PATHS = (
                  "$(inherited)",
                  /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include,
                  "$(SRCROOT)/../node_modules/react-native/React/**",
                  "$(SRCROOT)/../node_modules/react-native-code-push/ios/CodePush/**",
                );
                //ours表示自己的代码，theirs表示react native的官方代码。然后你可以根据实际的情况判断，选择某一方晋级，另一方出局。
    》老式升级方案
        》更新react-native的node依赖包
            去https://www.npmjs.com/package/react-native查看react-native的npm包的最新版本或使用npm info react-native命令查看。

            打开项目目录下的package.json文件，然后再dependencies模块下找到react-native，将当前版本号改到最新，然后再命令行中运行：
            npm install //如果提示权限错误就再命令前面加sudo

            注意：从0.24版本开始，react-native还需要额外安装react模块，且对react的版本有严格要求，高于或低于某个范围都不可以。本文
            无法在这里列出所有react native和对应的react模块版本要求，只能提醒读者先尝试执行npm install，然后注意观察安装过程中的报
            错信息，例如require react@某.某.某版本, but none was installed，然后根据这样的提示，执行npm install react@某.某.某版本
             --save。
        》升级项目模版文件
            新版本的npm包通常还会包含一些动态生成的文件，这些文件是在运行react-native init创建新项目时生成的，如iOS和Android的项目
            文件。为了使老项目的项目文件也能得到更新(不重新init)，你需要在命令行中运行：
            react-native upgrade
            这一命令会检查最新的项目模版，然后进行如下操作：
            如果是新添加的文件，则直接创建。
            如果文件和当前版本的文件相同，则跳过。
            如果文件和当前版本的文件不同，则会提示你一些选项：查看两者的不同，选择保留你的版本或是用新的模板覆盖。你可以按下h键来查看所有可以使用的命令

            注意：如果你有修改原生代码，那么在使用upgrade升级前，先备份，在覆盖。覆盖完成后，使用比对工具找出差异，将你之前修改的代码逐步搬运到新文件中。
    》手动升级
        有时候react native的项目结构改动较大，此时还需要手动做一些修改，如从.13到.14或.28到.29版本。
        所以在升级时请阅读更新日志(http://bbs.reactnative.cn/category/1/%E5%85%AC%E5%91%8A)，以确定是否需要做一些额外的手动修改。
27.特定平台代码
    》在制作跨平台的App时，多半会碰到针对不同平台编写不同代码的需求。最直接的方案就是把组件放置到不同的文件夹下：
        /common/components/
        /android/components/
        /ios/components/
    》另一个选择是根据平台不同的组件的文件命令上加以区分如：
        BigButtonIOS.js
        BigButtonAndroid.js

    //但除此以外React Native提供了另外两种简单区分平台的方案。
    》特定平台扩展名
        React Native会检测某个文件是否具有.ios.和.android.的扩展名，然后根据当前运行的平台加载正确对应的文件。
        如：
        BigButton.ios.js
        BigButton.android.js

        //这样命名组件后你就可以在其他组件中直接引用，而不需关心当前运行的平台是那个。
        import BigButton from './components/BigButton';
        //React Native会根据运行平台的不同引入正确对应的组件
    》还有个实用的方法是Platform.select(),它可以以Platform.OS为key，从传入的对象中返回对应平台的值：
        import {Platform,StyleSheet} from 'react-native'
        var styles = StyleSheet.create({
            container:{
                flex:1,
                ...Platform.select({
                    ios:{
                        backgroundColor:'red'
                    },
                    android:{
                        backgroundColor:'blue'
                    }
                })
            }
        });
        //上面的代码会根据平台的不同返回不同的container样式——iOS上背景色为红色，而android为蓝色。

        这个方法可以接受任何合法类型的参数，因此你也可以直接用它针对不同平台返回不同的组件：
        var Component = Platform.select({
            ios: () => require('ComponentIOS'),
            android:() => require('ComponentAndroid')
        });

        <Component/>
    》平台模块
        React Native提供了一个检测当前运行平台的模块。如果组件只有一小部分代码需要依据平台定制，那么这个模块就可以派上用场。
        import {Platform,StyleSheet} from 'react-native'
        var styles = StyleSheet.create({
            height: (Platform.OS === 'ios') ? 200 : 100
        });
        //Platform.OS在iOS上会返回ios，而在Android设备或模拟器上则会返回android。

        》检测iOS版本
            在iOS上，Version属性是-[UIDevice systemVersion]的返回值，具体形式为一个表示当前系统版本的字符串。比如可能是"10.3"。
        》检测Android版本
            在Android上，Version属性是一个数字，表示Android的api level：
            import { Platform } from 'react-native';

            if(Platform.Version === 21){
              console.log('当前api level是21，即运行的是Android 5.0，代号Lolipop');
            }
28.手势响应系统
    触摸响应系统可以使组件在不关心父组件或子组件的前提下自行处理触摸交互，具体的实现在ResponderEventPlugin.js文件中，可以在源码中读到
    更多细节和文档。

    》最佳实践
        用户之所以会觉得web app和原生app在体验上有巨大的差异，触摸响应是一大关键因素。用户的每一个操作都应该具有下列属性：
        》反馈/高亮 -- 让用户看到他们到底按到了什么东西，以及松开手后会发生什么。
        》取消功能 -- 当用户正在触摸操作时，应该是可以通过把手指移开来终止操作。
        //这些特性使得用户在使用App时体验更好，因为它们可以让用户大胆试用，而不必担心点错了什么。
    》TouchableHighlight与Touchable系列组件
        响应系统用户起可能比较复杂，所以我们提供了一个抽象的Touchable实现，用来做'可触控'的组件。这一实现利用了响应系统，使得你
        可以简单的以声明的方式来配置触控处理。如果要做一个按钮或网页链接，那么使用TouchableHighlight就可以了。
    》响应者的生命周期
        一个View只要实现了正确的协商方法，就可以成为触摸事件的响应者。我们通过两个方法去'询问'一个View是否愿意成为响应者：
        》View.props.onStartShouldSetResponder: (evt) => true,用户在开始触摸的时候(手指刚刚接触屏幕的瞬间)是否愿意成为响应者
        》View.props.onMoveShouldSetResponder: (evt) => true,如果View不是响应者，那么在每个触摸点开始移动(没有停下也没有离开屏幕)
          时再询问一次是否愿意响应触摸交互

        如果View返回true，并开始尝试成为响应者，那么会触发下列事件之一：
        》View.props.onResponderGrant: (evt) => {} -- View现在要开始响应触摸事件了，这也是需要做高亮的时候，使得用户知道他到底点到了哪里。
        》View.props.onResponderReject: (evt) => {} -- 响应者现在 '另有其人'而且暂时不会放权，请另作安排。

        如果View已经开始响应触摸事件了，那么这些处理函数会被一一调用：
        》View.props.onResponderMove: (evt) => {} -- 用户正在屏幕上移动手指时(没有停下也没有离开屏幕)
        》View.props.onResponderRelease: (evt) => {} -- 触摸操作结束时触发，如：touchUp(手指抬起离开屏幕)。
        》View.props.onResponderTerminationRequest: (evt) => true -- 有其他组件请求接替响应者，当前的View是否放权 ？返回true的话则释放响应者权利。
        》View.props.onResponderTerminate: (evt) => {} -- 响应者权利已经交出，这可能是由其他View通过onResponderTerminationRequest请求的，也可能是由
          操作系统强制夺权(如：iOS上的控制中心或通知中心)。

        evt是一个合成事件，它包含以下结构：
            nativeEvent
                changedTouches - 在上一次事件之后，所有发生变化的触摸事件的数组集合（即上一次事件后，所有移动过的触摸点）
                identifier - 触摸点的ID
                locationX - 触摸点相对于父元素的横坐标
                locationY - 触摸点相对于父元素的纵坐标
                pageX - 触摸点相对于根元素的横坐标
                pageY - 触摸点相对于根元素的纵坐标
                target - 触摸点所在的元素ID
                timestamp - 触摸事件的时间戳，可用于移动速度的计算
                touches - 当前屏幕上的所有触摸点的集合
    》捕获ShouldSet事件处理
        onStartShouldSetResponder与onMoveShouldSetResponder是以冒泡的形式调用，即嵌套最深的节点最先调用。这意味着当多个View同时在
        *ShouldSetResponder中返回true时，最底层的View将优先夺权。在多数情况下这并没有什么问题，因为这样可以确保所有控件和按钮是可用的。

        但有些时候某个父View会希望能先成为响应者。我们可以利用捕获期来解决这一需求、响应系统在从最底层的组件开始冒泡之前，会首先执行一个
        捕获期，在此期间会触发on*ShouldSetResponderCapture系列事件，因此如果某个父View想要在触摸操作开始时阻止子组件成为响应者，那就应该处理
        onStartShouldSetResponderCapture事件并返回true的值。
        View.props.onStartShouldSetResponderCapture: (evt) => true,
        View.props.onMoveShouldSetResponderCapture: (evt) => true,

    》PanResponder

29.使用指南 iOS

30.使用指南 Android
  》原生模块
    有时候App需要访问平台API，但React Native可能还没有相应的模块包装；或者你需要复用一些java代码，而不是用js重新实现一遍；
    又或者你需要实现某些高性能的、多线程的代码，譬如图片处理、数据库、或者各种高级扩展等等。

    我们把React Native设计为可以在其基础上编写真正的原生代码，并且可以访问平台所有的能力。这是一个相对高级的特性，我们并不认为它
    应当在日常开发的过程中经常出现，但具备这样的能力是很重要的。如果React Native还不支持某个你需要的原生特性，你应当可以自己实现
    该特性的封装。

    》Toast模块
        本向导会用Toast(http://developer.android.com/reference/android/widget/Toast.html)作为例子。假设我们希望可以从js发起一个Toast消息
        --Android中的一种会在屏幕下方弹出、保持一段时间的消息通知。

        首先来创建一个原生模块。一个原生模块是一个继承了ReactContextBaseJavaModule的Java类，它可以实现一些js所需的功能。
        我们这里的目标是可以在js里写ToastExample.show('Awesome', ToastExample.SHORT);来调起一个Toast通知。
            package com.facebook.react.modules.toast;

            import android.widget.Toast;

            import com.facebook.react.bridge.NativeModule;
            import com.facebook.react.bridge.ReactApplicationContext;
            import com.facebook.react.bridge.ReactContext;
            import com.facebook.react.bridge.ReactContextBaseJavaModule;
            import com.facebook.react.bridge.ReactMethod;

            import java.util.Map;
            import java.util.HashMap;

            public class ToastModule extends ReactContextBaseJavaModule {

              private static final String DURATION_SHORT_KEY = "SHORT";
              private static final String DURATION_LONG_KEY = "LONG";

              public ToastModule(ReactApplicationContext reactContext) {
                super(reactContext);
              }
            }

        ReactContextBaseJavaModule要求派生类实现getName方法，这个函数用于返回一个字符串名字，这个名字在js端标记这个模块。
        这里我们把这个模块叫做ToastExample，这样就可以在js中通过React.NativeModule.ToastExample访问到这个模块。

        注意：RN已经内置了一个名为ToastAndroid的模块，所以在练习时请勿使用ToastAndroid的名字，否则运行时报错名字冲突。
         @Override
          public String getName() {
            return "ToastExample";
          }
        注意：模块名前面的RCT前缀会被自动移除。所以如果返回的字符串为'RCTToastExample',在js端依然可以通过
        React.NativeModules.ToastExample访问到这个模块。

        一个可选的方法getConstants返回了需要导出给js使用的常量。它并不一定需要实现，但在定义一些可以被js同步访问到的预定义
        的值时非常有用。
             @Override
              public Map<String, Object> getConstants() {
                final Map<String, Object> constants = new HashMap<>();
                constants.put(DURATION_SHORT_KEY, Toast.LENGTH_SHORT);
                constants.put(DURATION_LONG_KEY, Toast.LENGTH_LONG);
                return constants;
              }

        要导出一个方法给js使用，Java方法需要使用注解@ReactMethod。方法返回的类型必须为void。React Native的跨语言访问是异步进行的。所以要想给
        js返回一个值得唯一办法是使用回调函数或发送事件。
             @ReactMethod
              public void show(String message, int duration) {
                Toast.makeText(getReactApplicationContext(), message, duration).show();
              }
    》参数类型
        下面的参数类型在@ReactMethod注明的方法中，会被直接映射到它们对应的js类型。
        Boolean -> Bool
        Integer -> Number
        Double -> Number
        Float -> Number
        String -> String
        Callback -> function
        ReadableMap -> Object
        ReadableArray -> Array
    》注册模块
        在Java这边要做的最后一件事是注册这个模块。我们需要在应用的Package类的createNativeModules方法中添加这个模块。如果模块
        没有被注册 它也无法再js中被访问到。
            package com.facebook.react.modules.toast;

            import com.facebook.react.ReactPackage;
            import com.facebook.react.bridge.NativeModule;
            import com.facebook.react.bridge.ReactApplicationContext;
            import com.facebook.react.uimanager.ViewManager;

            import java.util.ArrayList;
            import java.util.Collections;
            import java.util.List;

            public class AnExampleReactPackage implements ReactPackage {

              @Override
              public List<ViewManager> createViewManagers(ReactApplicationContext reactContext) {
                return Collections.emptyList();
              }

              @Override
              public List<NativeModule> createNativeModules(
                                          ReactApplicationContext reactContext) {
                List<NativeModule> modules = new ArrayList<>();

                modules.add(new ToastModule(reactContext));

                return modules;
              }

        这个package需要在MainApplication.java文件的getPackages方法中提供。这个文件位于你的react-native应用文件夹的android目录中。
        具体路径android/app/src/main/java/com/your-app-name/MainApplication.java。
            protected List<ReactPackage> getPackages() {
                return Arrays.<ReactPackage>asList(
                        new MainReactPackage(),
                        new AnExampleReactPackage()); // <-- 添加这一行，类名替换成你的Package类的名字.
            }

        为了让你的功能从js端访问起来更为方便，通常我们都会把原生模块封装成一个js模块，这不是必须的。但省下了每次都从
        NativeModules中获取对应模块的步骤。这个js文件也可以用于添加一些其他js端实现的功能。
            import { NativeModules } from 'react-native';

            // 下一句中的ToastExample即对应上文
            // public String getName()中返回的字符串

            export default NativeModules.ToastExample;

        现在，在别处的js 代码中可以这样调用你的方法：
        import ToastExample from './ToastExample';
        ToastExample.show('Awesome', ToastExample.SHORT);

    》更多特性
        》回调函数
            原生模块还支持一种特殊的参数 -- 回调函数，它提供了一个函数来把返回值传回给js。
            public class UIManagerModule extends ReactContextBaseJavaModule {

            ...

              @ReactMethod
              public void measureLayout(
                  int tag,
                  int ancestorTag,
                  Callback errorCallback,
                  Callback successCallback) {
                try {
                  measureLayout(tag, ancestorTag, mMeasureBuffer);
                  float relativeX = PixelUtil.toDIPFromPixel(mMeasureBuffer[0]);
                  float relativeY = PixelUtil.toDIPFromPixel(mMeasureBuffer[1]);
                  float width = PixelUtil.toDIPFromPixel(mMeasureBuffer[2]);
                  float height = PixelUtil.toDIPFromPixel(mMeasureBuffer[3]);
                  successCallback.invoke(relativeX, relativeY, width, height);
                } catch (IllegalViewOperationException e) {
                  errorCallback.invoke(e.getMessage());
                }
              }

            ...

            这个函数可以在js里这样使用：
            UIManager.measureLayout(
              100,
              100,
              (msg) => {
                console.log(msg);
              },
              (x, y, width, height) => {
                console.log(x + ':' + y + ':' + width + ':' + height);
              }
            );
            原生模块通常只应调用回调函数一次。但是，它可以保持callback并在将来调用。
            请务必注意callback并非在对应的原生函数返回后立即执行 -- 注意跨语言通讯是异步的，这个执行过程会通过消息循环来进行。
        》Promises
            原生模块还可以使用promise来简化代码，搭配async/await语法则效果更佳。如果桥接原生方法的最后一个参数是一个Promise，
            则对应js的方法就会返回一个Promise对象。
            import com.facebook.react.bridge.Promise;

            public class UIManagerModule extends ReactContextBaseJavaModule {

            ...

              @ReactMethod
              public void measureLayout(
                  int tag,
                  int ancestorTag,
                  Promise promise) {
                try {
                  measureLayout(tag, ancestorTag, mMeasureBuffer);

                  WritableMap map = Arguments.createMap();

                  map.putDouble("relativeX", PixelUtil.toDIPFromPixel(mMeasureBuffer[0]));
                  map.putDouble("relativeY", PixelUtil.toDIPFromPixel(mMeasureBuffer[1]));
                  map.putDouble("width", PixelUtil.toDIPFromPixel(mMeasureBuffer[2]));
                  map.putDouble("height", PixelUtil.toDIPFromPixel(mMeasureBuffer[3]));

                  promise.resolve(map);
                } catch (IllegalViewOperationException e) {
                  promise.reject(e.getMessage());
                }
              }

            ...

            现在js端的方法会返回一个Promise。这样就可以声明async的异步函数 使用await关键字来调用，并等待其结果返回。
            虽然这样写看起来像同步操作，但实际仍然是异步的，并不会阻塞执行来等待。
            async function measureLayout() {
              try {
                var {
                  relativeX,
                  relativeY,
                  width,
                  height,
                } = await UIManager.measureLayout(100, 100);

                console.log(relativeX + ':' + relativeY + ':' + width + ':' + height);
              } catch (e) {
                console.error(e);
              }
            }

            measureLayout();
        》多线程
            原生模块不应对自己被调用时所处的线程做任何假设，当前的状况有可能会在将来的版本中改变。如果一个过程要阻塞执行
            一段时间，这个工作当分配到一个内部管理的工作线程中，然后从那边可以调用任意的回调函数。
            注意：通常用AsyncTask来完成这项工作。
        》发送事件到js
            原生模块可以在没有被调用的情况下往js发送事件通知。最简单的办法就是通过RCTDeviceEventEmitter，这可以通过
            ReactContext来获得对应的引用。
        》从startActivityForResult中获取结果
            如果你使用startActivityForResult调起了一个activity并想从其中获取返回结果，那么你需要监听onActivityResult事件。
            具体的做法是继承BaseActivityEventListener或实现ActivityEventListener。我们推荐前一种做法，因为它相对来说不太会
            受到API变更的影响，然后你需要在模块的构造器中注册这一监听事件。
            reactContext.addActivityEventListener(mActivityResultListener);
            //现在你可以通过重写下面的方法来实现对onActivityResult的监听：
            @Override
            public void onActivityResult(
              final Activity activity,
              final int requestCode,
              final int resultCode,
              final Intent intent) {
              // 在这里实现你自己的逻辑
            }

            //下面我们写一个简单的图片选择器来实践一下。这个图片选择器会把pickImage方法暴露给js，而这个方法在调用时就会把图片的路径
            //返回到js端
                public class ImagePickerModule extends ReactContextBaseJavaModule {

                  private static final int IMAGE_PICKER_REQUEST = 467081;
                  private static final String E_ACTIVITY_DOES_NOT_EXIST = "E_ACTIVITY_DOES_NOT_EXIST";
                  private static final String E_PICKER_CANCELLED = "E_PICKER_CANCELLED";
                  private static final String E_FAILED_TO_SHOW_PICKER = "E_FAILED_TO_SHOW_PICKER";
                  private static final String E_NO_IMAGE_DATA_FOUND = "E_NO_IMAGE_DATA_FOUND";

                  private Promise mPickerPromise;

                  private final ActivityEventListener mActivityEventListener = new BaseActivityEventListener() {

                    @Override
                    public void onActivityResult(Activity activity, int requestCode, int resultCode, Intent intent) {
                      if (requestCode == IMAGE_PICKER_REQUEST) {
                        if (mPickerPromise != null) {
                          if (resultCode == Activity.RESULT_CANCELED) {
                            mPickerPromise.reject(E_PICKER_CANCELLED, "Image picker was cancelled");
                          } else if (resultCode == Activity.RESULT_OK) {
                            Uri uri = intent.getData();

                            if (uri == null) {
                              mPickerPromise.reject(E_NO_IMAGE_DATA_FOUND, "No image data found");
                            } else {
                              mPickerPromise.resolve(uri.toString());
                            }
                          }

                          mPickerPromise = null;
                        }
                      }
                    }
                  };

                  public ImagePickerModule(ReactApplicationContext reactContext) {
                    super(reactContext);

                    // Add the listener for `onActivityResult`
                    reactContext.addActivityEventListener(mActivityEventListener);
                  }

                  @Override
                  public String getName() {
                    return "ImagePickerModule";
                  }

                  @ReactMethod
                  public void pickImage(final Promise promise) {
                    Activity currentActivity = getCurrentActivity();

                    if (currentActivity == null) {
                      promise.reject(E_ACTIVITY_DOES_NOT_EXIST, "Activity doesn't exist");
                      return;
                    }

                    // Store the promise to resolve/reject when picker returns data
                    mPickerPromise = promise;

                    try {
                      final Intent galleryIntent = new Intent(Intent.ACTION_PICK);

                      galleryIntent.setType("image/*");

                      final Intent chooserIntent = Intent.createChooser(galleryIntent, "Pick an image");

                      currentActivity.startActivityForResult(chooserIntent, IMAGE_PICKER_REQUEST);
                    } catch (Exception e) {
                      mPickerPromise.reject(E_FAILED_TO_SHOW_PICKER, e);
                      mPickerPromise = null;
                    }
                  }
                }
            //为了让你的功能从js端访问起来更为方便，通常我们都会把原生模块封装成一个js模块。这不是必须的，但省下了每次都从
            //NativeModules中获取对应的模块的步骤，这个js文件也可以用于添加一些其他js端实现的功能。
                import { NativeModules } from 'react-native';

                export default NativeModules.ImagePickerModule;
            //现在在别处js代码中可以这样调用你的方法
                import ImagePickerModule from './ImagePickerModule';
                ImagePickerModule.pickImage()
                                .then((msg) => {
                                    //此处为成功之后回调的信息（指的是：uri.toString() 的值 ）
                                    alert(msg);
                                 })
                               .catch((err) => {
                                   //此处为失败之后回调的信息
                                    alert(err);
                                });
        》监听生命周期事件
            监听activity的生命周期事件(如：onResume onPause等等)和我们在前面实现ActivityEventListener的做法类似。模块必须实现
            LifecycleEventListener，然后需要在构造器中注册一个监听函数：
                reactContext.addLifecycleEventListener(this);
            现在可以通过实现下列方法来监听activity的生命周期事件了：
                @Override
                public void onHostResume() {
                    // Activity `onResume`
                }

                @Override
                public void onHostPause() {
                    // Activity `onPause`
                }

                @Override
                public void onHostDestroy() {
                    // Activity `onDestroy`
                }
 》原生UI组件
    在React Native应用程序中封装和植入已有的组件非常简单。和原生模块向导一样，本向导也是一个相对高级的向导，本向导会引导你如何
    构建一个原生UI组件。带领你了解React Native核心库中ImageView组件的具体实现。

    》ImageView示例
        为了让js中可以使用ImageView，需要做哪些准备工作？
        原生视图需要被一个ViewManager的派生类(或更常见的SimpleViewManger的派生类)创建和管理。一个SimpleViewManager可以用
        于这个场景，是因为它能够包含更多公共属性，譬如背景颜色、透明度、Flexbox布局等等。

        这些子类本质上都是单例——React Native只会为每个管理器创建一个实例。它们创建原生的视图并提供给NativeViewHierarchyManager。
        NativeViewHierarchyManager则会反过来委托它们在需要的时候去设置和更新视图的属性。ViewManager还会代理视图的所有委托，并给js
        发回对应的事件。

        提供原生视图很简单：
            》创建一个ViewManager的子类
                在这个例子里我们创建一个视图管理类ReactImageManager，它继承自SimpleViewManager<ReactImageView>。ReactImageView是这个视图
                管理类所管理的对象类型，这应当是一个自定义的原生视图。getName方法返回的名字会用于在js端引用这个原生视图类型。
                public class ReactImageManager extends SimpleViewManager<ReactImageView>{
                    public static final String REACT_CLASS = "RCTImageView";

                    @Override
                    public String getName(){
                        return REACT_CLASS;
                    }
                }

            》实现createViewInstance的方法
                视图在createViewInstance中创建，且应当把自己初始化为默认的状态，所有属性的设置都通过后续的updateView来进行。
                @Override
                public ReactImageView createViewInstance(ThemedReactContext context){
                    return new ReactImageView(context,Fresco.newDraweeControllerBuilder(), mCallerContext);
                }
            》导出视图的属性设置器：使用@ReactProp或@reactPropGroup注解
                要导出给js使用的属性，需要申明带有@ReactProp或@ReactPropGroup注解的设置方法。方法的第一个参数是要修改属性的视图实例。



            》把这个视图管理类注册到应用程序包的createViewManagers里
            》实现js模块






31.组件

32.API

33.布局样式属性

34.阴影样式属性
















































