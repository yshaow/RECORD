 /********************D3*******************/
1.链接 https://d3js.org/
    》安装
        npm安装：npm install d3;
        CDN:
            <script src="https://d3js.org/d3.v4.js"></script>
            压缩版：
            <script src="https://d3js.org/d3.v4.min.js"></script>
            单独使用d3某个模块：如单独使用d3-selection
            <script src="https://d3js.org/d3-selection.v1.min.js"></script>
    》支持环境
            D3支持“现代”浏览器，也就是除IE8及以下的浏览器。D3针对Firefox，Chrome，Safari，Opera，IE9 +，Android和iOS进行
        测试，D3的一部分功能能在旧版的浏览器中运行，因为D3的核心功能对浏览器的要求比较低：JavaScript和 W3C DOM API。
        D3使用 Level 1级Selectors API，但是可以通过预先加载Sizzle来实现兼容。现代浏览器对SVG和CSS3 Transition 的支持比
        较好。所以D3不支持更低级别的浏览器。
            D3也可以运行在Node 和 Web workers中. 在Node环境中使用DOM的时候，必须要提供自己的DOM实现。推荐使用JSDOM，为了避免定义全局document，
        建议将DOM传递给d3.select或者将NodeList传递给d3.selectAll,如下：
            var d3 = require("d3"),
                jsdom = require("jsdom");
            var document = jsdom.jsdom(),
                svg = d3.select(document.body).append("svg");
    》本地开发
        由于浏览器的安全限制，不能直接读取本地文件。在本地开发的时候，必须要运行一个服务器环境而不是使用file://,
        推荐使用Nodejs的http-server，安装方法:
        npm install -g http-server
        运行：http-server &
        然后会在当前目录启动一个 http://localhost:8080 的服务。
2.简介
        d3js是一个可以基于数据来操作文档的js库。可以帮助你使用html，css，SVG，canvas来展示数据。D3遵循现有的web标准，
    可以不需要其他任何框架独立运行在现代浏览器中，它结合强大的可视化组件来驱动DOM操作。
        D3可以将数据绑定到DOM上，然后根据数据来计算对应的DOM的属性值。如你可以根据一组数据生成一个表格，或者也可以生成
    一个可以过渡和交互的SVG图形。
        D3不是一个框架，因此也没有操作上的限制。没有框架的限制带来的好处就是你可以完全按照自己的意愿来表达数据，而不是
    受限于条条框框，非常灵活。D3的运行速度很快，支持大数据集和动态交互以及动画。
3.enter和exit操作
        数据绑定的时候可以出现DOM元素与数据元素**个数不匹配**的问题，那么enter和exit就是用来处理这个问题的。
    enter操作用来添加新的DOM元素，exit操作用来移除多余的DOM元素。
        如果数据元素多于DOM个数时用enter，如果数据元素少于DOM元素则用exit。
        在数据绑定时候存在三种情形：
            》数据元素个数多于DOM元素个数
                案例：如果文档中p标签的个数少于数组个数(6个)，则使用enter和append操作来补齐DOM元素
                d3.select('body')
                  .selectAll('p')
                  .data([1,2,3,4,5,6])
                  .enter().append('p')
                  .text(function(d){
                    return "I'm number"+ d +"!";
                  });
            》数据元素与DOM元素个数一样
                如果这种情况在使用data来绑定数据，相当于是更新了每个DOM元素所对应的数据，此时不需要加入新的节点
                也不需要删除多余的节点：
                var p = d3.select('body')
                          .selectAll('p')
                          .data([1,2,3,4,5,6])
                          .text(function(d){return d;});
            》数据元素个数少于DOM元素个数
                假设p的元素的个数多于6个，数据元素个数为6：
                var p = d3.select('body')
                          .selectAll('p')
                          .data([1,2,3,4,5,6])
                          .text(function(d){
                            return d;
                          });
                     p.exit().remove();//移除多余的元素
            》在实际应用中，不可能先去统计一下元素个数，因此这三种情形可以一起使用
                //情形2
                var p = d3.select('body')
                          .selectAll('p')
                          .data([1,2,3,4,5,6])
                          .text(function(d){return d;});
                //情形1
                p.enter().append('p').text(function(d){return d;});
                //情形3
                p.exit().remove();
4.D3不是一种新的表示
    D3不引入新的视觉表示方法，而是借助于现有的web元素 html css svg等。可以使用D3创建SVG元素，并使用外部样式表进行样式化。
    也可以使用复合过滤器效果，虚线和裁剪。这样在调试的时候可以方便的使用浏览器内置的调试工具来进行调试。
5.过渡
    D3支持动画效果，这种效果可以通过对样式属性的过渡实现。其补间插件支持多种方式，如线性、弹性等。
    此外D3内置的多种插件方式，比如数值类型，字符类型路径数据以及颜色等。
    比如对元素的背景颜色进行过滤：
        d3.select('body').transition().style('background-color',"black");
    此外还可以为一组元素设置不同的延迟：
        d3.selectAll('circle').transition()
          .duration(750)
          .delay(function(d,i){return i * 10;})
          .attr('r',function(d){return Math.sqrt( d * scale );});
  /***********************文档分析*************************/
  1.d3-array
     》d3.min(array[,accessor]);//返回给定array中的最小值。
            如果数组为空，则返回undefined。
            如果指定了accessor则相当于在计算最小值之前调用了array.map(accessor);
            //accessor 回调函数 function(value,index,array){}
            注意：
                与内置方法Math.min不同,d3.min忽略undefined, null and NaN 等值，在忽略缺失数据时有用.
                此外，元素使用自然排序而不是数值排序，比如["20","3"]会返回"20"，而[20,3]则返回3.
     》d3.max(array[,accessor]);//返回给定array的最大值
            如果数组为空，则返回undefined。
            如果指定了accessor则相当于在计算最小值之前调用了array.map(accessor)
            注意：
                与内置方法Math.max不同,d3.min忽略undefined, null and NaN 等值，在忽略缺失数据时有用.
                此外，元素使用自然排序而不是数值排序，比如["20","3"]会返回"3"，而[20,3]则返回20.
     》d3.extent(array[,accessor]);//根据指定的数组返回最小值和最大值 [min,max]
            如果数组为空则返回[undefined, undefined].
            如果指定了accessor，则相当于在计算极值之前调用了array.map(accessor).
     》d3.sum(array[,accessor]);//根据指定的array计算和
            如果数组为空则返回0.
            如果指定了accessor则相当于在求和之前调用了array.map(accessor). 这个方法会忽略undefined 和 NaN.
     》d3.mean(array[,accessor]);//根据指定的数组返回数组的均值
            如果数组为空则返回undefined.
            如果指定了accessor则相当于在计算之前调用了array.map(accessor). 这个方法会忽略undefined 和 NaN.
     》d3.median(array[,accessor]);//根据指定的数组使用R-7返回数组的中位数。
            如果数组为空则返回undefined.
            如果指定了accessor则相当于在计算之前调用了array.map(accessor). 这个方法会忽略undefined 和 NaN.
     》d3.quantile(array,p[,accessor]);//根据指定的数组返回p-分位数 p是[0,1]之间的小数
            例如中位数相当于 p = 0.5, 使用p = 0.25计算第一个四分位数, p = 0.75表示第三个四分位数. 这个方法也使用R-7 方法.
            如果指定了accessor则相当于在计算之前调用了array.map(accessor)。
     》d3.variance(array[,accessor]);//返回指定数组的总体方差的无偏估计
            如果数组中包含的元素个数小于2则返回undefined.
            如果指定了accessor则相当于在计算之前调用了array.map(accessor). 这个方法忽略了undefined 和 NaN .
     》d3.deviation(array[,accessor])//返回数组的标准差
            如果数组中包含的元素个数小于2则返回undefined.
            如果指定了accessor则相当于在计算之前调用了array.map(accessor). 这个方法忽略了undefined 和 NaN .
     》d3.scan(array[,comparator]);//对指定的数组进行线性扫描，根据指定的比较操作返回最终元素的索引//得到最大值或最小值的索引
            如果给定的数组不包含可比较的元素(比如比较操作返回NaN)则返回undefined,
            如果没有指定比较操作，则默认ascending.
            comparator：function(a,b){
                    return a - b;//获取最小值
                    return b - a;//获取最大值
            }
            //这个方法与min类似，但是这个方法是使用比较操作而不是访问器，并且这个方法返回的是索引而不是具体的值
     》d3.bisectLeft(array,x[,lo[,hi]]);//返回x在数组中应该被插入的位置，并保证数组的有序性。
            参数lo和hi被用来指定一个子集来限制插入的位置。默认情况下可能插入到数组中的任何位置.
            如果数组中已经存在x，则插入点的位置位于这个已经存在的元素之前(要考虑从左到右还是从右到左)。
            》d3.bisect(array, x[, lo[, hi]])
            》d3.bisectRight(array, x[, lo[, hi]])//从右向左计算的
     》d3.bisector(accessor | comparator);//使用指定的访问器或比较操作返回一个二等分对象
            var data = [
              {date: new Date(2011, 1, 1), value: 0.5},
              {date: new Date(2011, 2, 1), value: 0.6},
              {date: new Date(2011, 3, 1), value: 0.7},
              {date: new Date(2011, 4, 1), value: 0.8}
            ];
            //使用访问器造二等分线对象
            var bisectDate = d3.bisector(function(d) { return d.date; }).right;
            //等价于使用比较操作器造二等分线对象
            var bisectDate = d3.bisector(function(d, x) { return d.date - x; }).right;
            //注意：使用比较操作时，要将第二个参数设置为x，这里的x相当于要插入的值
            》然后使用类似于bisectDate(data, new Date(2011, 1, 2))的方法返回new Date(2011, 1, 2)
            在data中插入的索引，以保证插入之后依然有序。
            》bisector.left(array,x[,lo[,hi]]);//等价于bisectLeft，但是使用的是二等分法
            》bisector.right(array,x[,lo[,hi]]);//等价于bisectRight，但是使用的是二等分法
     》d3.ascending(a,b);
            如果a 小于 b则返回 -1 ,如果a 大于 b则返回1, 否则返回 0.
            这是自然数的一个比较操作，可以用于array.sort来进行升序排序，定义如下:
                function ascending(a, b) {
                  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
                }
     》d3.descending(a,b);
            如果a 小于 b则返回 1 ,如果a 大于 b则返回-1, 否则返回 0.
            这是自然数的一个比较操作，可以用于array.sort来进行降序排序，定义如下:
                function descending(a, b) {
                  return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
                }
     》d3.cross(a,b[,reducer]);//返回a b两个数组的笛卡尔乘积
            对于数组a中的每个元素i和数组b中的每个元素j，分别有序的调用传入reducer方法。
            reducer方法的参数分别为i和j。如果没有指定reducer则**默认为i和j创建一个二维数组**：
                即：reducer默认方式：
                    function reducer(i,j){
                        return [i,j];
                    }
     》d3.merge([arr1,arr2]);//将指定的数组合并为一个数组
            如：d3.merge([[1], [2, 3]])
     》d3.pairs(array);//将给定的数组的每个元素与它之前的一个元素结合为一对
            d3.pairs([1,2,3,4]);//return [[1,2],[2,3].[3,4]]
            //如果给定的数组中元素个数小于等于1，则返回空数组
     》d3.permute(array,indexes);//根据指定的索引次序对数组进行排序，返回排序后的新数组。
            d3.permute(['a','b','c'],[1,2,0])//['b','c','a'];
            //如果数组长度和索引长度不同，则会重复或忽略某些元素
            》这个方法也可以对对象进行操作，第一个参数为对象，第二个参数为属性列表，则会根据属性列表
              返回对应的值数组。
                var object = {yield: 27, variety: "Manchuria", year: 1931, site: "University Farm"},
                    fields = ["site", "variety", "yield"];
                d3.permute(object, fields); // returns ["University Farm", "Manchuria", 27]
     》d3.shuffle(array[,lo[,hi]]);//使用Fisher–Yates shuffle算法对数组进行随机重排.
     》d3.ticks(start,stop,count);//在start和stop之间计算出一个等间隔的、精确的刻度序列，count用于指定参考刻度个数。
                //由于小数可能不精确，需使用d3-format进行格式化
     》d3.tickStep(start,stop,count);//根据start和stop以及count返回刻度的间隔大小
     》d3.range([start,] stop [,step]);//根据start(如果指定)和stop以及step(如果指定)返回生成的序列。
                start默认0 step默认1.
                返回的序列不包含stop
                d3.range(0, 1, 0.2) // [0, 0.2, 0.4, 0.6000000000000001, 0.8]
     》d3.transpose(matrix);//使用zip操作进行矩阵转置
     》d3.zip(arrays...);//数组重合并
            d3.zip([1, 2], [3, 4]); // returns [[1, 3], [2, 4]]
     》Histograms 直方图可以将一些离散的样本统计映射到连续的空间，并且这种映射是非重叠的。直方图经常用来对一系列数值
            分布空间进行可视化。
            》d3.histogram() 使用默认的设置创建一个直方图生成器
            》histogram(data) 根据给定的数据样品计算对应的直方图。返回一个bins(纵向柱子)数组，
            每个bin都包含了与输入数据相关联的元素。bin的length属性表示这个bin里包含的元素个数，每个bin包含两个属性:
                x0 - bin的下界 (包含).
                x1 - bin的上界 (不包含,最后一个bin除外).
            》histogram.value([value]);
                //如果指定了value，则为直方图设置值访问器并返回直方图生成器。
                //如果vlaue没有指定，则返回当前的值访问器
            》histogram.domain([domain]);
                如果指定了domain则设置直方图的输入范围，这个值是一个[min,max]数组，表示直方图可取的最小值和最大值，
                如果生成数据某个元素的值超出这个范围，则忽略这个元素。
                例如，如果直方图与线性比例尺 x 结合使用时，则需要进行如下设置:
                    var histogram = d3.histogram()
                        .domain(x.domain())
                        .thresholds(x.ticks(20));
                    然后使用如下方法计算bins:
                    var bins = histogram(numbers);
                    domian访问器是被生成后的bins数组调用，而不是原始数据。
                    histogram.thresholds([count])
                    histogram.thresholds([thresholds])
                        如果指定了thresholds，则根据指定的数组或方法设置阈值生成器并返回直方图生成器。
                    默认的阈值是使用Sturges’ formula方法. 阈值是以数组的形式定义的，比如 [x0, x1, …].
                    任何比 x0 小的值被放置在第一个bin中。大于等于 x0 但是小于 x1 的被放置在第二个bin中;
                    以此类推. 最终直方图生成器 将包含 thresholds.length + 1 个 bins.
                        如果使用 count 来代替 thresholds, 则 domain 将被分割成 count 个 bins;
                    》以下方法一般不直接使用，而是传递给histogram.thresholds使用.
                        》d3.thresholdFreedmanDiaconis(values, min, max)
                            //根据Freedman–Diaconis rule方法计算bins; values 必须为数值类型.
                        》d3.thresholdScott(values, min, max)
                            //根据Scott’s normal reference rule方法计算bins; values 必须为数值类型.
                        》d3.thresholdSturges(values)//默认方式
                            //根据Sturges’ formula方法计算bins; values 必须为数值类型.
 /*********************************************/
 1.添加元素
    [selection].append('p');
        d3.select("body")//获取DOM
          .append("p")//添加元素
          .text("New paragraph!"); //添加文本
 2.数据绑定
    》D3可以处理的数据类型
        》js的数据类型
            如：数字 时间 字符串 布尔值 数组 对象
        》D3自定义的数据类型
            如：集合 Set  映射 Map  嵌套 Nest 以及各种颜色空间 RGB HSL L*a*b HSV对象等。

        最常用的是数组 JSON 特殊的有CSV GeoJSON数据等。
    》如何绑定 -- 选择元素 绑定数据 追加元素
        d3.selectAll('p')//查找p 没有存在将返回一个空的选择，这个选择为空，代表段落很快就会存在
          .data([1,2,3,4])//计数和分析我们的数据值
          .enter()//绑定数据和DOM元素 这个方法将数据传递到DOM中。如果数据值比相应的DOM元素多，就用enter()创建一个新元素的占位符。
          .append('p')
          .text('绑定数据')
 3.使用数据
        d3.selectAll('p')
          .data([1,2,3,4,5,6])
          .enter()
          .append('p')
          .text(function(d){//d表示当前值
            return "使用数据"+d;
          })
          .style('color',function(d){
            if(d>4){
                return 'red';
            }else{
                return 'blue';
            }
          })
 4.用层画条形图
        div.bar {
            display: inline-block;
            width: 20px;
            margin-right: 2px;//设置层之间间隔
            background-color: teal;
        }
        d3.selectAll('div')
          .data([1,2,3,4,5,6])
          .enter()
          .append('div')
          .attr('class','bar')//设置属性
          .style('height',function(d){//为每层设置特定的属性
            return d * 10 +"px";
          })
 5.生成测试数据
        》使用随机数值
            》使用原生js方式
                var dataset = [];
                for(var i = 0;i<25;i++){
                    dataset.push(Math.round(Math.random() * 30));
                }
            》D3方式
                var dataset = d3.range(25)//生成25个数字 对应数组[0-24],此处用作循环
                                .map(function(){
                                    return d3.format("d")(//四舍五入到整数
                                            d3.randomNormal(15,8)()//生成一个满足期望是15 方差是8的正态分布的随机数
                                    )
                                });
        》使用上面生成的data即可
 6.SVG
    SVG标签包含一些基本的构图元素，包括矩形 圆形 椭圆形 线条 文字和路径等
    SVG使用的是基于像素的坐标系统，其中浏览器的左上角是原点(0,0),x y的正方向分别是右 下
    》矩形
        x和y的指定左上角的坐标，width和height指定矩形的尺寸
        <rect x="0" y="0" width="500" height="50"/>
    》圆
        cx和cy指定圆心的坐标 r表示半径大小
        <circle cx='250' cy='25' r='25'/>
    》椭圆
        cx和cy指定圆心坐标，rx和ry分别指定横半轴 纵半轴长度
        <ellipse cx='250' cy='25' rx='100' ry='25'/>
    》线
        用x1和y1到指定线的一端的坐标，x2和y2指定的另一端的坐标。stroke(颜色值)指定描边让线是可见的
        <line x1='0' y1='0' x2='500' y2='50' stroke='black'/>
    》文本
        x和y指定文本的位置,并可以给文本设置样式
        <text x="250" y="25" font-family="sans-serif" font-size="25" fill='gray'>Easy-peasy</text>
    》SVG的样式
        SVG的默认样式没有描边，并且是黑色填充。
        属性              含义          可能值
        fill              填充          颜色值
        stroke            描边          颜色值
        stroke-width      描边宽度      数字通常以像素为单位
        opacity           不透明度      0完全透明 - 1完全不透明之间的数值
        font-family       字体          text标签特有 css字体
        font-size         字体大小      text标签特有 数字
        text-anchor       对齐方式      text标签特有 left center right
        其中颜色可以被指定为:
            命名的颜色 green
            十六进制值 #3388aa或#38A
            RGB值 RGB(10,150,20)
            RGB与Alpha透明 RGBA(10,150,20,0.5)
 7.D3绘制SVG
    //创建SVG
    var w = 500;
    var h = 50;
    var svg = d3.select('body')
                .append('svg')//添加SVG
                .attr('width',w)//设置宽高
                .attr('height',h)
    //数据驱动的SVG
    var dataset = [5,10,15,20,25];
    svg.selectAll('circle')
       .data(dataset)
       .enter()
       .append('circle')
       .attr('cx',function(d,i){//i 索引
            return i * 50 +25;
       })
       .attr('cy',h/2)
       .attr('r',function(d){
            return d;
       })
 8.D3的数据类型
    》变量
    》数组
    》对象
    》对象数组 //对应值为对象的数组
    》JSON
    》GeoJSON 是可以存储地理空间通常为经度纬度坐标点，形状(如线和多边形)和其他空间的Feature
        var geodata = {
            "type": "FeatureCollection",
            "features": [
                {
                    "type": "Feature",
                    "geometry": {
                        "type": "Point",
                        "coordinates": [ 150.1282427, -24.471803 ]
                    },
                    "properties": {
                        "type": "town"
                    }
                }
            ]
        };
 9.更自由的条形图
    》准备数据 绘制条形图的输入数只需要一个表示每个条数据量的数组就行
        var dataset = [ 5, 10, 13, 19, 21, 25, 22, 18, 15, 13,11, 12, 15, 20, 18, 17, 16, 18, 23, 25 ];
    》创建SVG元素
        var w = 500;
        var h = 100;
        var svg = d3.select('body')
                    .append('svg')
                    .attr('width',w)
                    .attr('height',h)
    》绘制矩形条
        //D3经典的select-data-enter-append-attr/style的编程套路
        svg.selectAll('rect')
           .data(dataset)
           .enter()
           .append('rect')
           //添加样式
    》矩形条的属性和样式
        //条宽 = 条实际宽度 + 间隙宽度 = w/dataset.length
                 间隙宽度 = barPadding
        //条高 = 条长 - 纵坐标(纵坐标是从上到下计算的) = h - ( d * 4(高度) )
        svg.selectAll('rect')
                   .data(dataset)
                   .enter()
                   .append('rect')
                   .attr('x',function(d,i){
                        return i * (w/dataset.length);
                   })
                   .attr('y',function(d){
                        return h -( d * 4 );
                   })
                   .attr('width',w / dataset.length - barPadding)
                   .attr('height',function(d){
                        return d * 4;
                   })
                   .attr('fill',function(d){
                        return "rgb(0,0,"+ (d * 10) +")"
                   })
    》文本标记
        x坐标：i * (w / dataset.length) + (w / dataset.length - barPadding) / 2;
        y坐标：h - (d * 4) + 14;
        svg.selectAll('text')
           .data(dataset)
           .enter()
           .append('text')
           .text(function(d){
                return d;
           })
           .attr('text-anchor','middle')
           .attr('x',function(d,i){
            return i * (w/dataset.length) + (w/dataset.length-barPadding)/2;
           })
           .attr('y',function(d){
            return h - (d*4)+14;
           })
           .attr("font-family",'sans-serif')
           .attr('font-size','11px')
           .attr('fill','white')
 10.散点图
    散点图的绘制思路：
        》准备输入数据，用二维数组表示每个点的坐标
        》绘制SVG 并绑定数据
        》绘制圆元素 并用绑定的数据设置圆的属性
        var w = 500,
            h = 100,
            dataset = [
                [5, 20], [480, 90], [250, 50], [100, 33], [330, 95],
                [410, 12], [475, 44], [25, 67], [85, 21], [220, 88]
            ],
            svg = d3.select('body')
                    .append('svg')
                    .attr('width',w)
                    .attr('height',h);
            svg.selectAll('circle')
               .data(dataset)
               .enter()
               .append('circle')
               .attr('cx',function(d){
                    return d[0];
               })
               .attr('cy',function(d){
                    return d[1];
               })
               .attr('r',function(d){
                    return Math.sqrt(h-d[1]);//绘制上面大 下面小的圆
               });
            //点的文本
            svg.selectAll("text")
               .data(dataset)
               .enter()
               .append('text')
               .text(function(d){
                    return d[0] + "," + d[1];
               })
               .attr(x,function(d){
                    return d[0];
               })
               .attr(y,function(d){
                    return d[1];
               })
               .attr("font-family", "sans-serif")
               .attr("font-size", "11px")
               .attr("fill", "red");
 11.比例尺
        比例尺就是一个数据映射函数，比如线性比例尺可以实现类似y=ax+b的变换。D3一共有三类九种比例尺。
        》分类
            》数量型
                线性比例尺
                恒等比例尺
                乘方比例尺
                对数比例尺
                量化比例尺
                分位数比例尺
                临界值比例尺
            》时间型
                时间比例尺
            》序数型
                序数比例尺
                颜色比例尺(特例)
            //一般采用线性比例尺
        》定义域 和 值域
            比例尺有两个重要的函数：
                》domain([100,500]) 定义域范围 对应轴的
                》range([10,350]) 值域范围 相应轴的
        》定义比例尺
            //4.x版本 d3.scaleLinear() -- d3.scale.linear()
            var scale = d3.scale.linear()
                          .domain([100,500])
                          .range([10,350]);
            //比例尺最终都会对定义域执行相应的函数变换，然后再把这个中间数据线性变换到值域范围上
        》坐标轴的缩放
            //获取最大的X
            d3.max(dataset,function(d){
                return d[0];//返回每个子数组的第一个元素
            })
            //X轴缩放
            var xScale = d3.scale.linear()
                         .domain([0,d3.max(dataset),function(d){ return d[0];}])
                         .range([0,w])
            //Y轴缩放
            var yScale = d3.scale.linear()
                                 .domain([0,d3.max(dataset,function(d){ return d[1]; })])
                                 .range([0,h])
            //自定义半径比例尺
            var rScale = d3.scale.linear()
                           .domain([0,d3.max(dataset,function(d){ return d[1]; })])
                           .range([2,5]);
        》设定圆心的坐标
            //需要使用和轴一致的比例尺
            .attr('cx',function(d){
                //return d[0];
                //使用缩放后的坐标x值
                return xScale(d[0]);
            })
            .attr('cy',function(d){
                //return d[1];
                //使用缩放后的坐标x值
                return yScale(d[1]);
            })
        》设定文本坐标值
            .attr('x',function(d){
                return xScale(d[0]);
            })
            .attr('y',function(d){
                return yScale(d[1]);
            })
        》设置半径
            .attr('r',function(d){
                return rScale(d[1]);
            })
 12.坐标轴
       》定义和创建X轴
            //定义x轴 d3.axisBottom(xScale);//4.x版本
            var xAxis = d3.svg.axis()
                          .scale(xScale)//指定坐标轴的比例尺
                          .orient('bottom');//制定坐标轴的方位  可取值：left  right  top  bottom
            //创建x轴
            svg.append('g').call(xAxis);//调用的时候任意选择器 call调用轴 或者xAxis选择器均可
       》调整X轴的样式
            .axis path,.axis line{
                fill:none;
                stroke:black;
                shape-rendering: crispEdges;//这个属性用来显示轴
            }
            .axis text {
                font-family:sans-serif;
                font-size:11px;
            }
            //设置上面样式 并 把坐标轴平移到下面
            svg.append('g')
                .attr('class','axis')
                .attr('transform','translate(0,'+(h-padding)+')')
                .class(xAxis)
       》设置刻度数
            var xAxis = d3.svg.axis()
                          .scale(xScale)
                          .orient('bottom')
                          .ticks(5);//设置刻度数
            //注意这个ticks函数指定的数字只是一个大概的数量，具体生成多少D3会自动调整
       》Y轴
            //定义Y轴
            var yAxis = d3.svg.axis()
                          .scale(yScale)
                          .orient('left')
                          .ticks(5);
            //同样设置样式
            svg.append('g')
                .attr('class','axis')
                .attr('transform','translate('+padding+',0)')
                .class(yAxis);
       》设置刻度的格式
            var format = d3.format('.1%');
            xAxis.tickFormat(format);
 13.有路径的文字
        》在svg中插入一个text
            var svg = d3.select('body').append('svg');
            var text = svg.append('text')
                .attr('x',10)
                .attr('y',20)
                .style('fill','steelblue')
                .style('font-size','24px')
                .style('font-weight','bold')
                .text('text加入文字测试！')
        》添加文字路径
            svg.append('path')//插入path
                .attr({
                    id:"mypath",
                    d:'M50 100Q350 50 350 250Q250 50 50 250'
                })
                .style({
                    fill:"none",
                    stroke:"green",
                    'stroke-width':10
                })
            //引用路径
            text.append('textPath').attr({
                'xlink:href':"#mypath"
            });
 14.SVG基本图形绘制
        svg的path标签被称为"可以组成任何形状的形状"，SVG的path可以绘制任何形状的图形包括矩形 圆形 椭圆 折线
    多边形 直线 曲线等。
        SVG的路径代表一个形状的轮廓，可以描边 填充 用作剪切路径或任何三者的结合。
    》SVG Path案例
        svg path元素的形状被一个属性所定义：d
            d这个属性包含一系列的方法与参数，因此我们可以把这个属性称作一个"微语言"。这些方法与参数其实就是
        告诉电脑如果在"纸上移动你的钢笔"。
        //绘制一个三角形
        <svg width="100" height="100">
            <path d="
                M 10 25//定义起点
                L 10 75//绘制起点到 10，75的直线
                L 60 75//绘制10，75到60，75的直线
                L 10 25//绘制60，75到10，25的直线
            " stroke="red" stroke-width="2" fill="none"></path>
        </svg>
        <svg width="100" height="100">
                    <path d="
                        M 10 25//定义起点
                        L 10 75//绘制起点到 10，75的直线
                        L 60 75//绘制10，75到60，75的直线
                        L 10 25//绘制60，75到10，25的直线
                    " stroke="blue" stroke-width="2" fill="none"></path>

                    <path d="
                                m 50 25
                                l 0  50
                                l 50 0
                                l -50 -50
                            " fill="none" stroke-width="2" stroke="blue"></path>
                </svg>
        //注意：M，L是大写的，表示绝对位置(相对于画布左上角)。当使用相对位置(相对于上一个点的位置)时，要小写。
    》SVG Path微语言
        命令          参数          能否重复            备注
        M/m           x，y           不能               把笔尖移动到新位置，但因为没有落笔，不会"描绘图形"。所有的path都需要以M/m开始
        L/l           x,y             能                从当前点画一条直线到坐标x,y
        H/h            x              能                画水平线，从当前点画一条水平线，到横坐标x处
        V/v            y              能                画垂直线，从当前点画一条垂线，到纵坐标为y处
        C/c     x1 y1 x2 y2 x y       能                绘制一条曲线 起点为当前点，终点为x,y
                                                        使用x1,y1作为开始阶段曲线的控制点
                                                        使用x2,y2作为结束阶段曲线的控制点
        S/s         x2 y2 x y         能                绘制一条平滑的曲线。 绘制一条以当前点为起点,x,y为终点绘制一条三次方贝塞尔曲线。
                                                        注意这是一个简写，这条曲线同样也有两个控制点，但此时x1 y1跟x2,y2是对称的，
                                                        可以直接写x2y2这一个。
        Q/q         x1 y1 x y         能                二次方贝塞尔曲线，绘制一条以当前点为起点 x,y为终点的二次方贝塞尔曲线 x1 y1为控制点
        T/t            x y            能                绘制二次方贝塞尔曲线的简写。绘制一条以当前点为起点,x,y为终点的二次方贝塞尔曲线。
                                                        控制点假定为前一个命令的控制点相对于当前点的反射。
                                                        如果前一个命令不存在，或者前一个命令不是二次贝塞尔曲线命令或平滑的二次贝塞尔曲线命令，则此控制点就是当前点。
        A/a    rx ry x-axis-rotation large-arc-flag sweep-flag x y  能  椭圆弧线命令在当前点与指定的终点 (x, y)之间创建一条椭圆弧线。
                                                                     rx ，ry 是椭圆弧的半长轴，半短轴长度
                                                                     x-axis-rotation 是此段弧所在的椭圆的 x 轴与水平方向的夹角，即 x 轴的旋转角度
                                                                     large-arc-flag 和 sweep-flag 决定了椭圆弧的绘制方向，值是 0 或 1
                                                                     x,y 是椭圆弧终端坐标
                                                                     椭圆圆心是计算出来的，不需要指定
                                                                     large-arc-flag 为1 表示大角度弧线，0 代表小角度弧线
                                                                     sweep-flag , 1 代表从起点到终点弧线绕椭圆中心顺时针方向，0 代表逆时针方向
        Z/z             none          不能             闭合路径 会有一条线链接路径最后一个点与起点
    》路径
        var svg = d3.select('body').append('svg')
        svg.append('path').attr(
            "d":"M50 150Q300 50 300 150T450 150"
        ).style('fill','none').style('stroke',"purple").style('stroke-width',5);
    》折线
        <polyline
            points:"x1,y1 x2,y2 ...."//折线组成的坐标点
            fill//填充颜色 none--无
            stroke//边框颜色
            stroke-width//边框宽度
            fill-opacity//透明度
            stroke-opacity//边框的透明度
        ></polyline>

        svg.append('polyline')
                .attr('points',"100,10 40,180 190,60 10,60 160,180 100,10")
                .style('fill','blue')
                .style('stroke','red')
                .style('stroke-width',5)
                .style('fill-opacity',.5)
                .style('stroke-opacity',.4);
    》多边形
        <polygon
            points//多边形组成的坐标点
            fill
            stroke
            stroke-width
            fill-opacity
            stroke-opacity
            fill-rule://属性值nonzero(默认值) evenodd
                //nonzero:本规则决定一个点是否在图形内部的方法是从该点向任意方向画直线，然后检查直线与图形的交叉。
                          如果该点左右与图形交叉点数相同，则该点在图形外，否则在图形内。
                  evenodd:本规则通过从一点向任意方向画直线然后计算该直线与图形的交叉电的数量来决定该点是否在图形内。
                          如果交叉点数为奇数，则该点在图形内，否则在图形外。
        ></polygon>

        svg.append('polygon')
                    .attr('points',"100,10 40,180 190,60 10,60 160,180 100,10")
                    .style('fill','yellow')
                    .style('stroke','red')
                    .style('stroke-width',5)
                    .style('fill-opacity',.5)
                    .style('stroke-opacity',.4)
                    .style('fill-rule',"evenodd");
    》直线
        <line
            x1
            y1
            x2
            y2
        ></line>

        svg.append('line')
                .attr('x1',50)
                .attr('y1',50)
                .attr('x2',100)
                .attr('y2',200)
                .style('stroke','red');
    》圆
        <circle
            cx
            cy
            r
        ></circle>

        svg.append('circle')
                .attr('cx',0)
                .attr('cy',0)
                .attr('r',100)
                .style('fill','none')
                .style('stroke','red')
                .style('stroke-width','5');
    》椭圆
        <ellipse
            cx//中心x坐标
            cy//中心y坐标
            rx//水平半径
            ry//垂直半径
        ></ellipse>

        svg.append('ellipse')
                .attr('cx',100)
                .attr('cy',60)
                .attr('rx',30)
                .attr('ry',50)
                .style('fill','block')
                .style('stroke','red')
                .style('fill-opacity',.5)
                .style('stroke-width',5);
 15.更新、过渡和动画
	http://blog.csdn.net/tianxuzhang/article/details/18456701
/***************************入门****************************/
   http://www.ourd3js.com/wordpress/2209/#more-2209
1.数据可视化
    数据可视化的目的是要对数据进行可视化处理，以使得能够 明确地 有效地 传递信息
2.数据可视化的构成要素
    坐标 -- 数值的位置被对应到直角坐标系或极坐标系上
    大小 -- 数据的大小被对应到图形的大小
    色彩 -- 数值的分类和界限等对应到颜色的不同
    标签 -- 数值的特征用标签来标记
    关联 -- 数值之间的联系 用关联线条等连接起来
3.数据可视化的适用范围
4.D3入门系列
    4.1 简介与安装
        》D3是什么
            D3全称 Data Driven Document 即被数据驱动的文档。
    4.2 选择元素和绑定数据
        》选择元素
            d3.select() 选择所有指定元素的第一个
            d3.selectAll() 选择指定元素的全部
        》绑定数据 -- 将数据绑定到DOM上，也就是绑定到文档上
            datum() 绑定一个数据到选择集上
                d3.select('#app').selectAll('p').datum('这是test').text(function(d,i){
                        return i + " : " + d;
                })
                //匿名函数function(d,i){}，当选择集需要使用被绑定的数据时，常需要这么使用
                    //d 代表数据 即与某元素绑定的数据
                    //i 代表索引 即数据的索引 从0开始
            data()  绑定一个数组到选择集上，数组的各项值分别与选择集的各元素绑定 -- 常用
                d3.select('#app').selectAll('p').data(["a","b","c"]).text(function(d,i){
                        return i + " : " + d;
                })
    4.3 选择 插入 删除元素
        》选择元素
            select(selector)
            selectAll(selector)
        》插入元素
            append() 在选择集**末尾**插入元素
                d3.select('#app').append('p').text('append p')
            insert(addElem,selector) 在选择集**前面**插入元素
                d3.select('#app').insert('p','p:first-child').text('insert p')
        》删除元素
            remove()
                d3.select('#app').select('p:first-child').remove()
    4.4 做一个简单的图表
        》画布
            SVG 与 Canvas
        》SVG
                scalable vector graphics 即可缩放矢量图形，用于描述二维矢量图形的一种图形格式，是由万维网联盟制定的开放标准。
            SVG使用XML格式来定义图形，除了IE8以前的版本外，大部分浏览器都支持SVG，可将SVG文本直接嵌入HTML中显示。
            》特点
                》SVG绘制的是矢量图，因此对图像进行放大不会失真
                》基于XML 可以为每个元素添加js事件处理器
                》每个图形均视为对象，更改对象的属性 图形也会改变
                》不适合游戏应用
        》Canvas
                Canvas是通过js来绘制2D图形，是html5中新增的元素
            》特点
                》绘制的是位图，图形放大会失真
                》不支持事件处理器
                》能够以.png 或 .jpg格式保存图形
                》适合游戏应用
        》添加画布
            D3虽然没有明文规定一定要在SVG中绘图，但是D3提供了众多的SVG图形生成器，它们都是只支持SVG的。因此建议使用SVG画布。
                    var w = 300,
                    h = 300,
                    svg = d3.select('d3')
                            .append('svg')
                            .attr('width',w)
                            .attr('height',h);
        》绘制矩形
            <rect x y width height></rect>

             var dataset = [250,210,170,130,90];
                svg.selectAll('rect')
                    .data(dataset)
                    .enter()
                    .append('rect')
                    .attr('x',20)
                    .attr('y',function(d,i){
                        return i * 25;//25 rect height
                    })
                    .attr('width',function(d){
                        return d;
                    })
                    .attr('height',25 - 2)
                    .attr('fill','steelblue');
    4.5 比例尺的使用
        》比例尺作用
            将某个区域的值映射到另一个区域，其大小比例关系不变 -- 比例尺 Scale
        》比例尺分类
                比例尺很像数学中的函数，如对于一个一元二次函数，有x 和 y两个未知数，当x的值确定时，y值也就确定了。
            在数学中，x的范围被称为定义域，y的范围被称为值域。

                D3中的比例尺也有定义域和值域，分别被称为 domain 和 range，开发者需要指定domain和range的范围，如此即可得到
            一个计算关系。
                D3提供了多种比例尺，最常用的两种如下：
            》线性比例尺
                线性比例尺能将一个连续的区间，映射到另一个区间。要解决柱形图宽度的问题就需要线性比例尺。
                //如以下数据
                var dataset = [1.2,2.3,.9,1.5,3.3]
                //要求
                将 dataset中的最小值 映射成0 将最大值 映射成300
                var linear = d3.scaleLinear()//返回线性比例尺
                                .domain([d3.min(dataset),d3.max(dataset)])//定义域
                                .range([0,300]);//值域
                console.log(linear(.9));//0
                console.log(linear(2.3));//175
                console.log(linear(3.3));//300
            》序数比例尺
                有时候，定义域和值域不一定是连续的。如有两个数组：
                var index = [0,1,2,3,4];
                var color = ["red","blue","green","yellow","black"];
                //我们希望0 对应 red 1对应blue 以此类推，但是这些值都是离散的，线性比例尺不合适，需要用到序数比例尺。
                    var ordinal = d3.scaleOrdinal(color)//返回序数比例尺 传入 range(值域)
                                    .domain(index);//指定定义域
                    console.log(ordinal(0));//red
                    console.log(ordinal(1));//blue
                    console.log(ordinal(4));//black
        》给柱形图添加比例尺
                var dataset = [1.2,2.3,.9,1.5,3.3];
                //定义比例尺
                var linear = d3.scaleLinear()
                                .domain([0,d3.max(dataset)])
                                .range([0,250]);
                //在给矩形设置宽度的时候，应用比例尺
                svg.selectAll('rect')
                        .data(dataset)
                        .enter()
                        .append('rect')
                        .attr('x',20)
                        .attr('y',function(d,i){
                            return i * 25;//25 rect height
                        })
                        .attr('width',function(d){
                            return linear(d);//使用比例尺
                        })
                        .attr('height',25 - 2)
                        .attr('fill','steelblue');
                //如此以来，所有的数值都按照同一个线性比例尺的关系来计算宽度，因此数值之间的大小关系不变
    4.6 坐标轴
            坐标轴，是可视化图表中经常出现的一种图形，由一些列线段和刻度组成。坐标轴在SVG中没有现成的图形元素的。需要用其他的元素
            组合构成。D3提供了坐标轴的组件，如此在SVG画布中绘制坐标轴变得像添加普通元素一样简单。
            》坐标轴的构成
                在SVG画布的预定义元素里，有六种基本图形：
                    》矩形 rect
                    》圆形 circle
                    》椭圆 ellipse
                    》线段 line
                    》折线 polyline
                    》多边形 polygon
                》比较特殊 功能最强的元素
                    路径 path
                //画布中的所有图形 都是由以上七种元素组成
            》定义坐标轴
                要生成坐标轴，需要用到比例尺，二者经常是一起使用的。
                //数据
                var dataset = [2.5,2.1,1.7,1.3,.9];
                //定义比例尺
                var linear = d3.scaleLinear()
                                    .domain([0,d3.max(dataset)])
                                    .range([0,250]);
                //定义坐标轴
                var axis = d3.axisBottom(linear)//刻度方向为下的坐标轴  参数：//比例尺
                                 .ticks(dataset.length);//指定刻度的数量
            》在svg中添加坐标轴
                定义坐标轴之后，只需要在SVG中添加一个分组元素<g>，在将坐标轴的其他元素添加到这个<g>中即可
                svg.append('g')
                    .call(axis);//在D3中，call()的参数是一个函数，调用之后，将当前的选择集作为参数传递给函数。
                    即：上面代码 和 axis(svg.append(g))//是相等的
            》定义坐标轴样式
                默认的坐标轴样式不太美观，提供最常见的样式：
                .axis path,.axis line{
                    fill: none;
                    stroke: black;
                    shape-rendering: crispEdges;
                }
                .axis text {
                    font-family: sans-serif;
                    font-size: 11px;
                }
                //坐标轴的位置，可以通过transform属性来设定
                添加元素样式与坐标轴位置
                svg.append('g')
                    .attr('class','axis')//添加样式
                    .attr('transform','translate(20,130)')//设置位置
                    .call(axis)
    4.7 完整的柱形图
        一个完整的柱形图包含三个部分：矩形 文字 坐标轴
        var w = 600,
                h = 600,
                padding = {left:30,right:30,top:30,bottom:30},//画布周边的空白
                reactPadding = 10,//矩形之间的空白
                //添加画布
                svg = d3.select('body')
                        .append('svg')
                        .attr('width',w)
                        .attr('height',h),
                dataset = [10, 20, 30, 40, 33, 24, 12, 5],//定义数据
                //定义比例尺
                xScale = d3.scaleBand()//和序数比例尺类型的比例尺
                            .domain(d3.range(dataset.length))//d3.range([开始值,]  结束值 [,步长])返回等差数列
                            .range([0,w - padding.left - padding.right])
                yScale = d3.scaleLinear()//线性比例尺
                            .domain([0,d3.max(dataset)])
                            .range([h - padding.top -padding.bottom ,0]),
                //定义坐标轴
                xAxis = d3.axisBottom(xScale),
                yAxis = d3.axisLeft(yScale);
            //添加矩形和文字元素
            var rects = svg.selectAll('rect')
                            .data(dataset)
                            .enter()
                            .append('rect')
                            .attr('class','rect')
                            .attr('x',function(d,i){
                                return xScale.step() * i + padding.left +reactPadding/2;
                            })
                            .attr('y',function(d){
                                return yScale(d) + padding.top - reactPadding/2;
                            })
                            .attr('width',xScale.step() - reactPadding)
                            .attr('height',function(d){
                                return h - padding.top - padding.bottom - yScale(d);
                            });
            //添加文字元素
            var texts = svg.selectAll('text')
                .data(dataset)
                .enter()
                .append('text')
                .attr('class','text')
                .attr('x',function(d,i){
                    return xScale.step()*i + padding.left +reactPadding/2;
                })
                .attr('y',function(d){
                    return yScale(d) + padding.top;
                })
                .attr('dx',function(){//移动的横坐标
                    return (xScale.step() - reactPadding)/2;
                })
                .attr('dy',function(){//移动的纵坐标
                    return 20;
                })
                .text(function(d){
                    return d;
                })
            //添加坐标轴的元素
                //添加x轴
                svg.append('g')
                    .attr('class','axis')
                    .attr('transform',"translate("+padding.left+","+ (h - padding.top) +")")
                    .call(xAxis);
                //添加y轴
                svg.append('g')
                    .attr('class','axis')
                    .attr('transform','translate('+padding.left+','+padding.top+')')
                    .call(yAxis);
    4.8 让图表动起来
            》什么是动态效果
                动态的图表是指图表在某一时间段会发生某种变化，可能是形状、颜色、位置等，而且用户是可以看到变化的过程的。
                D3里的动态效果 -- 过渡
            》实现动态的方法
                D3提供了4个方法用于实现图形的过渡：从状态A变为状态B。
                》transition() 启动过渡效果
                    其前后是图形变化前后的状态(形状 位置 颜色等)
                    .attr('fill','red')//变化前颜色
                    .transition()//启动过渡
                    .attr('fill','steelblue')//变化后颜色
                》duration() 指定过渡的持续时间 单位毫秒
                    duration(2000)
                》ease("linear") 指定过渡的方式
                    v4.x 通过d3.easeBounce等方式获对应的值
                    》linear 普通的线性变化
                    》circle 慢慢地到达变换的最终状态
                    》elastic 带有弹跳的到达最终状态
                    》bounce 在最终状态处弹跳几次
                》delay() 指定延迟的时间 表示一定时间后才开始转变 单位 毫秒
                    此函数可以对整体指定延迟 也可以对个别指定延迟
                    》整体延迟
                        .transition()
                        .duration(1000)
                        .delay(500)
                    》个别延迟
                        .transition()
                        .duration(1000)
                        .delay(function(d,i){
                            return 200 * i;
                        })
            》实现简单的动态效果
                //移动x坐标
                    svg.append('circle')
                        .attr('cx',100)
                        .attr('cy',100)
                        .attr('r',45)
                        .style('fill','green')
                        .transition()
                        .duration(1000)
                        .attr('cx',300)

                //移动x坐标 又改变颜色
                    svg.append('circle')
                        .attr('cx',100)
                        .attr('r',45)
                        .attr('cy',100)
                        .style('fill','green')
                        .transition()
                        .duration(1500)
                        .attr('cx',300)
                        .style('fill','red')

                //移动x坐标 又改变颜色 半径
                    svg.append('circle')
                        .attr('cx',100)
                        .attr('r',45)
                        .attr('cy',100)
                        .style('fill','green')
                        .transition()
                        .duration(2000)
                        .ease(d3.easeBounce)
                        .attr('r',25)
                        .attr('cx',300)
                        .style('fill','red')
            》给柱形图添加动态效果
                //添加矩形和文字元素
                    var rects = svg.selectAll('rect')
                                    .data(dataset)
                                    .enter()
                                    .append('rect')
                                    .attr('class','rect')
                                    .attr('x',function(d,i){
                                        return xScale.step() * i + padding.left +reactPadding/2;
                                    })
                                    .attr('y',function(d){
                                        return yScale(yScale.domain()[0]) + 2 * padding.top;
                                    })
                                    .attr('width',xScale.step() - reactPadding)
                                    .attr('height',function(d){
                                        return h - padding.top - padding.bottom - yScale(d);
                                    })
                                    .transition()
                                    .duration(1000)
                                    .ease(d3.easeBounce)
                                    .delay(function(d,i){
                                        return 100 * i;
                                    })
                                    .attr('y',function(d){
                                        return yScale(d) + padding.top - reactPadding/2;
                                    });
                    //添加文字元素
                    var texts = svg.selectAll('text')
                        .data(dataset)
                        .enter()
                        .append('text')
                        .attr('class','text')
                        .attr('x',function(d,i){
                            return xScale.step()*i + padding.left +reactPadding/2;
                        })
                        .attr('y',function(d){
                            return yScale(yScale.domain()[0]) + padding.top;
                        })
                        .attr('dx',function(){//移动的横坐标
                            return (xScale.step() - reactPadding)/2;
                        })
                        .attr('dy',function(){//移动的纵坐标
                            return 20;
                        })
                        .text(function(d){
                            return d;
                        })
                        .transition()
                        .duration(2000)
                        .ease(d3.easeBounce)
                        .delay(function(d,i){
                            return i * 200;
                        })
                        .attr('y',function(d){
                            return yScale(d) + padding.top;
                        });
    4.9 理解update enter exit的使用
            update enter exit处理的是当选择集和数据的数量关系不确定的情况
            》什么是update enter exit
                如果数组为 [3, 6, 9, 12, 15]，将此数组绑定到三个 p 元素的选择集上。可以想象，
                会有两个数据没有元素与之对应，这时候 D3 会建立两个空的元素与数据对应，这一部分就称为 Enter。
                而有元素与数据对应的部分称为 Update。如果数组为 [3]，则会有两个元素没有数据绑定，那么没有数据
                绑定的部分被称为 Exit。
            》update 和 enter的使用
                当绑定数据数量 > 对应元素时 ，需要添加元素 append
                案例：body中有三个p元素 要绑定一个长度大于3的数组到p的选择集上，然后分别处理update 和 enter两部分
                var dataset = [1,2,3,4,5]
                //选择p元素
                var p = d3.select('body').selectAll('p');
                //获取update部分
                var update = p.data(dataset);
                //获取enter部分
                var enter = update.enter();
                //update部分处理 更新属性值
                update.text(function(d){
                    return 'update'+d;
                })
                //enter部分的处理 添加元素后赋予属性值
                enter.append('p').text(function(d){
                    return 'enter'+d;
                })
                //update 部分的处理办法一般是：更新属性值
                //enter 部分的处理办法一般是：添加元素后 赋予属性值
            》update 和 exit的使用
                当绑定数据数量 < 对应元素，需要删除多余的元素
                案例：现在 body 中有三个 p 元素，要绑定一个长度小于 3 的数组到 p 的选择集上，
                然后分别处理 update 和 exit 两部分。
                    var dataset = [1];
                    var p = d3.select('body').selectAll('p');
                    //获取update部分
                    var update = p.data(dataset);
                    //获取exit部分
                    var exit = update.exit();
                    //update部分的处理：更新属性值
                    update.text(function(d){
                        return 'update' + d;
                    })
                    //exit部分的处理：删除元素
                    exit.remove();
                    //exit部分的处理办法一般是删除元素 remove
            》enter update exit
                    var dataset = [1,2,3,3]
                    var update = d3.selectAll('p')
                        .data(dataset)
                        .text(function(d){
                            return 'update'+d;
                        });
                        update.enter()
                        .append('p')
                        .text(function(d){
                            return 'enter'+d;
                        })
                        update.exit().remove();
    4.10 交互式操作
            与图表的交互，指再图形元素上设置一个或多个监听器，当事件发生时，做出相应的反应。
            》什么是交互
                交互指的是用户输入了某个指令，程序接受到指令之后必须做出某个响应。对可视化图表来说
                交互能使图表更加生动，能表现更多内容。如：拖动图表中某些图形，鼠标滑到图形上出现提示框
                用触屏放大或缩小图形等等。
                用户用于交互的工具一般有三种：鼠标、键盘、触屏。
            》如何添加交互
                对某个元素添加交互操作十分简单，代码如下：
                svg.append('circle')
                    .on('click',function(){
                        console.log(d3.event);
                        //事件内容
                    })
                //在D3中，每一个选择集都有on()函数，用于添加事件监听器
                on()的第一个参数是监听的事件，第二个参数是监听到事件后响应的内容，一个函数
                》鼠标常用的事件
                    click：鼠标单击某元素时，相当于 mousedown 和 mouseup 组合在一起。
                    mouseover：光标放在某元素上。
                    mouseout：光标从某元素上移出来时。
                    mousemove：鼠标被移动的时候。
                    mousedown：鼠标按钮被按下。
                    mouseup：鼠标按钮被松开。
                    dblclick：鼠标双击。
                》键盘常用事件
                    keydown：当用户按下任意键时触发，按住不放会重复触发此事件。该事件不会区分字母的大小写，
                             例如“A”和“a”被视为一致。
                    keypress：当用户按下字符键（大小写字母、数字、加号、等号、回车等）时触发，
                              按住不放会重复触发此事件。该事件区分字母的大小写。
                    keyup：当用户释放键时触发，不区分字母的大小写。
                》触屏常用的事件
                    touchstart：当触摸点被放在触摸屏上时。
                    touchmove：当触摸点在触摸屏上移动时。
                    touchend：当触摸点从触摸屏上拿开时。
            》带有交互的柱形图
                    var rects = svg.selectAll('rect')
                                        .data(dataset)
                                        .enter()
                                        .append('rect')
                                        .attr('class','rect')
                                        .attr('x',function(d,i){
                                            return xScale.step() * i + padding.left +reactPadding/2;
                                        })
                                        .attr('y',function(d){
                                            return yScale(yScale.domain()[0]) + 2 * padding.top;
                                        })
                                        .attr('width',xScale.step() - reactPadding)
                                        .attr('height',function(d){
                                            return h - padding.top - padding.bottom - yScale(d);
                                        })
                                        .on('mouseover',function(){
                                            d3.select(this)//当前元素
                                                .attr('class','active');
                                        })
                                        .on('mouseout',function(d,i){
                                            d3.select(this)
                                                .transition()
                                                .duration(500)
                                                .attr('class','rect');
                                        })
                                        .transition()
                                        .duration(1000)
                                        .ease(d3.easeBounce)
                                        .delay(function(d,i){
                                            return 100 * i;
                                        })
                                        .attr('y',function(d){
                                            return yScale(d) + padding.top - reactPadding/2;
                                        });
    4.11 布局
            布局，可以理解成"制作常见图形的函数"。
            》布局是什么
                布局 layout 。D3与其他很多可视化工具不同，相对来说较底层。
                D3与其他可视化工具的区别：
                        大部分可视化工具            D3
                               |                     |
                             数据                   数据
                               |                     |
                            绘图函数                布局
                               |                      |
                             图表                获取绘图所需要数据
                                                       |
                                               在画布上添加相应的图形
                                                       |
                                                     图表
                        //选择D3 -- 绘制任意想象的图表
                        //选择Highcharts Echarts等 -- 开发几种固定种类的，大众化的图表
            》理解布局
                布局的作用是：将不适合用于绘图的数据转换成了适合用于绘图的数据 -- 数据转换
            》D3的布局 12个布局
                》饼状图 Pie
                》力导向图 Force
                》弦图 Chord
                》树状图 Tree -- 由层级图扩展来的
                》集群图 Cluster -- 由层级图扩展来的
                》捆图 Bundle
                》打包图 Pack -- 由层级图扩展来的
                》直方图 Histogram
                》分区图 Partition -- 由层级图扩展来的
                》堆栈图 Stack
                》矩阵树图 Treemap -- 由层级图扩展来的
                》层级图 Hierarchy -- 不能直接使用
                //这些布局的作用都是将某种数据转换成另一种数据，而转换后的数据是利于可视化的
    4.12 饼状图的制作
            》数据
                var dataset = [30,10,43,55,13];
                //这些值是不能直接绘图的，例如绘制饼状图的一个部分，需要知道一段圆弧的起始角度和终止角度，这些
                //值都不存在于数组dataset中，因此需要用到布局，布局的作用就是*计算出适合于作图的数据*
            》布局 -- 数据转换
                //定义饼状图布局
                var pie = d3.pie();
                //数据转换
                var piedata = pie(dataset);
                //布局不是要直接绘图 而是为了得到绘图所需的数据
            》绘制图形
                为了根据转换后的数据piedata来作图，还需要一样工具：生成器。
                //这里要用到弧生成器，能够生成弧的路径。
                var outerRadius = 150 ;//外半径
                var innerRadius = 0 ;//内半径 0表示中间没有空白
                var arc = d3.arc()//弧生成器
                            .innerRadius(innerRadius)
                            .outerRadius(outerRadius);
                //arc可以当做一个函数使用，把piedata作为参数传入即可得到路径值(path的)
                //如：arc(piedata[0])

                //在SVG中添加图形元素
               var color = d3.scaleOrdinal(d3.schemeCategory10)
                             .domain(d3.range(piedata.length));//d3.schemeCategory10 有十种颜色的颜色比例尺
                   var arcs = d3.select('#app')
                                   .append('svg')
                                   .attr('width',600)
                                   .attr('height',600)
                                   .selectAll('g')
                                   .data(piedata)
                                   .enter()
                                   .append('g')
                                   .attr('transform','translate(300,300)');
                   arcs.append('path')
                       .attr('fill',function(d,i){
                           return color(i);//设置填充颜色
                       })
                       .attr('d',function(d){
                           return arc(d);//使用生成器 生成path路径
                       })
                   arcs.append('text')
                       .attr('transform',function(d){
                           return 'translate('+arc.centroid(d)+')';//弧线的中心
                       })
                       .attr('text-anchor','middle')
                       .text(function(d){
                           return d.data;//获取原始数据
                       })
    4.13 力导向图的制作
            力导向图中每一个节点都受到力的作用而运动，这种是一种非常绚丽的图表。
            力导向图 Force-Directed-Graph 是绘图的一种算法，在二维或三维空间里配置节点，节点之间用线连接，称为连线。
            各连线的长度几乎相等，且尽可能不相交。节点和连线都被施加了力的作用，力是根据节点和连线的相对位置计算的。
            根据力的作用，来计算节点和连线的运动轨迹，并不断降低它们的能量，最终达到一种能量很低的安定状态。

            力导向图能表示**节点之间的多对多的关系**
            》初始化数据
                var nodes = [ { name: "桂林" }, { name: "广州" },
                              { name: "厦门" }, { name: "杭州" },
                              { name: "上海" }, { name: "青岛" },
                              { name: "天津" } ];

                 var edges = [ { source : 0 , target: 1 } , { source : 0 , target: 2 } ,
                               { source : 0 , target: 3 } , { source : 1 , target: 4 } ,
                               { source : 1 , target: 5 } , { source : 1 , target: 6 } ]
                 //节点nodes 和 连线edges的数组，节点是城市名 连线的两端是节点的序号 从0开始
            》布局 -- 数据转换
                //定义一个力导向图的布局
                     //添加svg
                        var width = 400;
                        var height = 400;
                        var svg = d3.select('#app')
                                    .append('svg')
                                    .attr('width',width)
                                    .attr('height',height);
                        //定义力导向图
                        var force = d3.forceSimulation()//创建一个没有作用力的仿真
                                        .nodes(nodes)//指定node节点
                                        //通过force为仿真系统设置力的作用
                                        .force('charge',d3.forceManyBody())//节点间的作用力 forceManyBody构建一个多体作用力
                                        .force('link',d3.forceLink(edges).distance(150))//连线作用力 forceLink创建link作用力 distance表示连线距离
                                        .force('center',d3.forceCenter(width/2,height/2))//重力，布局有一个参数位置 不会跑偏 //创建centering作用力
                        //绘制
                            //添加连线
                            var svg_edges = svg.selectAll('line')
                                                .data(edges)
                                                .enter()
                                                .append('line')
                                                .style('stroke','#ccc')
                                                .style('stroke-width',1);
                            //添加节点
                            var color = d3.scaleOrdinal(d3.schemeCategory20).domain(d3.range(nodes.length));
                            var svg_nodes = svg.selectAll('circle')
                                .data(nodes)
                                .enter()
                                .append('circle')
                                .attr('r',20)
                                .style('fill',function(d,i){
                                    return color(i);
                                }).call(d3.drag()
                                    .on("start",dragstarted)
                                    .on("drag",dragged)
                                    .on("end",dragended));

                            //添加描述节点的文字
                            var svg_texts = svg.selectAll('text')
                                                .data(nodes)
                                                .enter()
                                                .append('text')
                                                .style('fill','black')
                                                .attr('dx',20)
                                                .attr('dy',8)
                                                .text(function(d){
                                                    return d.name;
                                                })

                        force.on('tick',function(){ //力导向图布局 force 有一个事件 tick，每进行到一个时刻，都要调用它，
                            //更新连线坐标
                            svg_edges.attr('x1',function(d){
                                    return d.source.x;
                                })
                                .attr('y1',function(d){
                                    return d.source.y
                                })
                                .attr('x2',function(d){
                                    return d.target.x;
                                })
                                .attr('y2',function(d){
                                    return d.target.y;
                                });
                            //更新节点坐标
                            svg_nodes.attr('cx',function(d){
                                    return d.x;
                                })
                                .attr('cy',function(d){
                                    return d.y;
                                })
                            //更新文字坐标
                            svg_texts.attr('x',function(d){
                                    return d.x;
                                })
                                .attr('y',function(d){
                                    return d.y;
                                });
                        })
                        //拖动节点的三个过程
                        function dragstarted(d){
                            //未激活 重启
                            if (!d3.event.active) force.alphaTarget(0.3).restart();
                            d.fx=d.x;
                            d.fy=d.y;
                        }

                        function dragged(d){
                            d.fx=d3.event.x;
                            d.fy=d3.event.y;
                        }

                        function dragended(d){
                            if(!d3.event.active) force.alphaTarget(0);
                            d.fx=null;
                            d.fy=null;
                        }
    4.14 弦图的制作
            弦图 Chord -- 主要用于表示两个节点之间的联系 ，两点之间的连线，表示谁和谁具有联系。线的粗细表示权重
            》数据
                var city_name = [ "北京" , "上海" , "广州" , "深圳" , "香港"  ];
                var population = [
                  [ 1000,  3045　 , 4567　, 1234 , 3714 ],
                  [ 3214,  2000　 , 2060　, 124  , 3234 ],
                  [ 8761,  6545　 , 3000　, 8045 , 647  ],
                  [ 3211,  1067  , 3214 , 4000  , 1006 ],
                  [ 2146,  1034　 , 6745 , 4764  , 5000 ]
                ];
                //数据是一些城市名和一些数字，数字表示城市人口的来源
                被统计人口城市\被统计的来源城市   北京       上海      ....
                       北京                       1000        3045
                       上海                       3214        2000
                        ...
                        //北京市的人口有 1000 个人来自本地，有 3045 人是来自上海的移民，总人口为 1000 + 3045 +...。
            》布局 -- 数据转换
                //定义弦图布局
                //布局
                    var chord = d3.chord()//创建弦图生成器 传入矩阵 数据
                                    .sortChords(d3.descending)//设置弦的排序规则
                                    .padAngle(.03)//相邻分组之间的间隔

                    var populationResult = chord(population);
                            //populationResult.groups -- 表示节点
                            // 其他数据表示连线 即弦 source target即连线的两端

                    //定义相关变量 添加svg
                    var width = 800,
                        height = 800,
                        innerRadius = width/2 * .6,
                        outerRadius = height/2 * .9,
                        color = d3.scaleOrdinal(d3.schemeCategory20).domain(d3.range(populationResult.length)),
                        svg = d3.select('#app')
                            .append('svg')
                            .attr('width',width)
                            .attr('height',height)
                            .append('g')
                            .attr('transform','translate('+width/2+','+height/2+')');

                    //绘制节点 -- 即分组 多少城市对应多少弧形 以及绘制城市名称
                    var outer_arc = d3.arc()//获取path路径
                                            .innerRadius(innerRadius)
                                            .outerRadius(outerRadius);

                    //分组
                    var g_outer = svg.append('g');
                    //添加节点
                    g_outer.selectAll('path')
                        .data(populationResult.groups)
                        .enter()
                        .append('path')
                        .style('fill',function(d){return color(d.index)})
                        .style('stroke',function(d){return color(d.index)})
                        .attr('d',function(d){
                            return outer_arc(d);
                        });//设置path路径
                    //添加文本
                    g_outer.selectAll('text')
                        .data(populationResult.groups)
                        .enter()
                        .append('text')
                        .each(function(d,i){//设置文本信息
                            d.angle = (d.startAngle + d.endAngle) / 2;
                            d.name = city_name[i];
                        })
                        .attr('dy','.5em')
                        .attr('transform',function(d){
                            return "rotate("+(d.angle * 180 /Math.PI)+")"+
                                    "translate(0,"+(-1.0 * (outerRadius+10))+")"+
                                    (( d.angle > Math.PI*3/4 && d.angle < Math.PI*5/4 ) ? "rotate(180)":"");
                        })
                        .text(function(d){
                            return d.name;
                        })

                    //绘制连线 -- 所有城市人口的来源 即 5*5=25条弧
                    svg.append('g')
                        .selectAll('path')
                        .data(populationResult)
                        .enter()
                        .append('path')
                        .attr('d',function(d){
                            return d3.ribbon()
                                      .radius(innerRadius)
                                      (d);//生成path
                        })
                        .style('fill',function(d){return color(d.source.index)})
                        .on('mouseover',function(){
                            d3.select(this).style('fill','yellow')
                        })
                        .on('mouseout',function(d,i){
                            d3.select(this)
                                .transition()
                                .duration(1000)
                                .style('fill',color(d.source.index));
                        });
    4.15 集群图的制作
            集群图是一种用于表示包含与被包含关系的图表。
            》数据
                通过D3读取json文件中的初始化数据
                {
                "name":"中国",
                "children":
                [
                    {
                      "name":"浙江" ,
                      "children":
                      [
                            {"name":"杭州" },
                            {"name":"宁波" },
                            {"name":"温州" },
                            {"name":"绍兴" }
                      ]
                    },

                    {
                        "name":"广西" ,
                        "children":
                        [
                            {"name":"桂林"},
                            {"name":"南宁"},
                            {"name":"柳州"},
                            {"name":"防城港"}
                        ]
                    },

                    {
                        "name":"黑龙江",
                        "children":
                        [
                            {"name":"哈尔滨"},
                            {"name":"齐齐哈尔"},
                            {"name":"牡丹江"},
                            {"name":"大庆"}
                        ]
                    },

                    {
                        "name":"新疆" ,
                        "children":
                        [
                            {"name":"乌鲁木齐"},
                            {"name":"克拉玛依"},
                            {"name":"吐鲁番"},
                            {"name":"哈密"}
                        ]
                    }
                ]
                }
            》布局 -- 数据转换
                //定义集群图布局
                var width = 600,
                        height = 600,
                        svg = d3.select('#app')
                                .append('svg')
                                .attr('width',width)
                                .attr('height',height)
                                .append('g')
                                .attr('transform','translate(300,300)');
                    //构建一个默认的群集布局
                    var cluster = d3.cluster().size([360,.4*width]);
                    //获取数据
                    d3.json('cluster.json?a=a',function(error,data){
                        //转换数据
                            //获取根节点
                        var node = d3.hierarchy(data);
                            //获取连线
                        //var links = node.links();
                        //传入根节点 集群布局
                        cluster(node);
                        //绘制
                        //D3准备好的绘制函数d3.svg.diagonal()，这是一个对角线生成器，只需要输入两个顶点坐标即可生成一条贝塞尔曲线
                //        //创建对角线生成器
                //        var link = d3.linkHorizontal()
                //                            .x(function(d) { return d.x; })
                //                            .y(function(d) { return d.y; });
                        function project(x, y) {
                            var angle = (x - 90) / 180 * Math.PI, radius = y;
                            return [radius * Math.cos(angle), radius * Math.sin(angle)];
                        }
                        //绘制连线
                        var lk = svg.selectAll('.link')
                                    .data(node.descendants().slice(1))
                                    .enter()
                                    .append('path')
                                    .attr('class','link')
                                    .attr('d',function(d){
                                        return "M" + project(d.x, d.y)
                                            + "C" + project(d.x, (d.y + d.parent.y) / 2)
                                            + " " + project(d.parent.x, (d.y + d.parent.y) / 2)
                                            + " " + project(d.parent.x, d.parent.y);
                                    });
                        //绘制节点组
                        var nodeG = svg.selectAll('g')
                                        .data(node.descendants())
                                        .enter()
                                        .append('g')
                                        .attr('class',function(d) {;return "node" + (d.children ? " node--internal" : " node--leaf"); })
                                        .attr('transform',function(d){
                                            return "translate("+project(d.x,d.y)+")";
                                        });
                //        //绘制节点
                        nodeG.append('circle')
                            .attr('r',4.5);
                //        //绘制文本
                        nodeG.append('text')
                            .attr("dx", function(d) { return d.children ? -8 : 8; })
                            .attr("dy", ".31em")
                            .style("text-anchor", function(d) { return d.children ? "end" : "start"; })
                            .attr("transform", function(d) { return "rotate(" + (d.x < 180 ? d.x - 90 : d.x + 90) + ")"; })
                            .text(function(d) { return d.data.name; });
                    })
    4.16 树状图的制作
            树状图Tree用于表示层级、上下级、包含与被包含的关系
            树状图与集群图的区别：
                树状图更突出层级关系，即同级节点之间的对齐方式不同。
            //树状图的绘制与集群图的绘制一样的，只需要改变cluster与tree的生成器构造函数即可
    4.17 打包图的制作
            打包图Pack用于表示包含与被包含的关系，也可以表示各对象的权重，通常用一圆套一圆来表示前者，用圆的大小来表示后者。
            》初始化数据
                使用cluster.json中的数据--各城市所属关系的数据
            》布局 -- 数据转换
                //添加svg
                    var width = 500,
                        height = 500,
                        svg = d3.select('#app')
                                .append('svg')
                                .attr('width',width)
                                .attr('height',height)
                                .append('g')
                                .attr('transform','translate(1,1)');
                    //创建pack生成器
                    var pack = d3.pack()
                                    .size([width,height])//设置转换数据的范围即[x,y]都在该范围之类
                                    .radius(function(d){
                                        return 8;//最低层级圆的半径
                                    })
                                    .padding(3);//节点之间的距离
                    //获取数据
                    d3.json('cluster.json?a=a',function(err,data){
                        //格式化数据
                        var node = d3.hierarchy(data);
                //        node.sum(function(d){return d.value;})//计算总和
                //            .sort(function(a, b) { return b.value - a.value; });//排序
                        //获取pack对应的数据
                        pack(node)
                        //获取连线数据
                        var links = node.links();//此处用不到该数据
                        console.log(links);
                        /********************绘制图形********************/
                        var a = svg.selectAll('g')
                            .data(
                                node.descendants()//生成所有的节点
                            )
                            .enter()
                            .append('g')
                            .attr('transform',function(d){return 'translate('+d.x+','+d.y+')'})
                            .append('circle')
                            .attr('fill','rgb(31,119,180)')
                            .attr('fill-opacity',.4)
                //            .attr('cx',function(d){
                //                //console.log(d);
                //                return d.x;
                //            })
                //            .attr('cy',function(d){
                //                return d.y;
                //            })
                            .attr('r',function(d){
                                return d.r;
                            })
                            .on('mouseover',function(d,i){
                                d3.select(this)
                                    .attr('fill','yellow');
                            })
                            .on('mouseout',function(d,i){
                                d3.select(this)
                                    .attr('fill','rgb(31,119,180)');
                            })
                    })
    4.18 地图的制作
        》地图数据的获取
            制作地图需要JSON文件，将JSON的格式应用于地理上的文件叫做GeoJSON文件。本文就是用这种文件绘制地图。
            》获取中国地图的GeoJSON文件
                参照https://github.com/clemsos/d3-china-map进行制作，这不仅需要安装一些东西，还要研究一下制作方法，
                对想直接下载获取中国地图的GeoJSON文件的朋友可能不爽。
                //china.geojson
        》绘制
            //添加画布
                var width = 600,
                    height = 600,
                    svg = d3.select('#app')
                        .append('svg')
                        .attr('width',width)
                        .attr('height',height);

                //投影函数
                var projection = d3.geoMercator()//由于GeoJson文件中的地图数据，都是经纬度的信息，它们都是三维的，
                                                 // 而要在网页上显示的是二维的，所以要设定一个投影函数来转换经纬度
                                    .center([107,31])//设定地图的中心位置,[107,31]指的是经度 纬度
                                    .scale(500)//设定放大的比例
                                    .translate([width/2,height/2]);//设定平移

                //地理路径生成器
                    //为了根据地图的地理数据生成svg中path元素的路径值，需要用到d3.geoPath -- 地理路径生成器
                    var path = d3.geoPath()
                                    .projection(projection);//设定投影函数

                //获取json数据并绘制地图
                d3.json('china.geojson',function(err,data){
                    if(err) return console.error(err);

                    //定义省份颜色生成器
                    var color = d3.scaleOrdinal(d3.schemeCategory20).domain(d3.range(data.features.length));

                    //绘制地图
                    svg.selectAll('path')
                        .data(data.features)
                        .enter()
                        .append('path')
                        .attr('stroke','#000')
                        .attr('stroke-width',1)
                        .attr('fill',function(d,i){
                            return color(i);
                        })
                        .attr('d',path)//使用地理路径生成器 function(d){return path(d);} //每个path表示一个省份
                        .on('mouseover',function(d,i){
                            d3.select(this)
                                .attr('fill','yellow');
                        })
                        .on('mouseout',function(d,i){
                            d3.select(this)
                                .attr('fill',color(i));
                        })
                })
    4.19 简化GeoJSON文件
            GeoJson文件有时候太大，读取很费时间，如果我们不需要那么精确，可以将其简化。
            》转换方法
                》http://mapshaper.org/
                》选择文件 select
                》缩小比例
                    simplify
                》输出模式  export -》 GeoJson自动下载
    4.20 可拖动的地图
            通过地图 和 力学图制作可拖动的地图，可通过鼠标拖动各个省份
            //添加画布
                var width = 800,
                    height = 800,
                    svg = d3.select('#app')
                            .append('svg')
                            .attr('width',width)
                            .attr('height',height)
                            .append('g')
                            .attr('transform','translate(0,0)');

                //定义投影函数--将三维地图经纬度坐标投影到二维所用的坐标
                var projection = d3.geoMercator()
                                    .center([107,31])//定义中心
                                    .scale(600)//定义缩放比例
                                    .translate([width/2,height/2]);//定义偏移量

                //定义地理路径生成器
                var path = d3.geoPath().projection(projection);

                //定义力导图
                var force = d3.forceSimulation();

                //定义颜色生成器
                var color = d3.scaleOrdinal(d3.schemeCategory20);

                //读取数据
                d3.json('china.geojson',function(err,data){
                    if(err)return console.error(err);

                    //转换数据
                    var nodes = [],
                        links = [];
                    data.features.forEach(function(d,i){
                        var centroid = path.centroid(d);//返回GeoJson对象投影面的几何中心
                        centroid.x = centroid[0];
                        centroid.y = centroid[1];
                        centroid.feature = d;
                        nodes.push(centroid);
                    });
                    //对nodes中的顶点进行三角剖分，即用三角形来连接各个顶点
                    var triangles = d3.voronoi()
                                        .triangles(nodes);
                    function edge(a,b){
                        var dx = a[0] - b[0],dy = a[1] -b[1];
                        return {
                            source:a,
                            target:b,
                            distance:Math.sqrt(dx*dx+dy*dy)
                        }
                    }
                    //将三角形各边存到links变量中
                    triangles.forEach(function(d,i){
                        links.push(edge(d[0],d[1]));
                        links.push(edge(d[1],d[2]));
                        links.push(edge(d[2],d[0]));
                    });

                    //绘制地图
                    force.nodes(nodes)
                        .force('charge',d3.forceManyBody())
                        .force('link',d3.forceLink(links).distance(function(d){return d.distance;}))
                        .force('center',d3.forceCenter(width/2,height/2));
                    var node = svg.selectAll('g')
                        .data(nodes)
                        .enter()
                        .append('g')
                        .attr('transform',function(d){return "translate("+(-d.x)+","+(-d.y)+")"})
                        .call(d3.drag()
                            .on("start",dragstarted)
                            .on("drag",dragged)
                            .on("end",dragended)
                        )
                        .append('path')
                        .attr('transform',function(d){return "translate("+d.x+","+d.y+")"})
                        .attr('stroke','#000')
                        .attr('stroke-width',1)
                        .attr('fill',function(d,i){
                            return color.domain(d3.range(nodes.length))(i);
                        })
                        .attr('d',function(d){
                            return path(d.feature);
                        })
                    var link = svg.selectAll('line')
                        .data(links)
                        .enter()
                        .append('line')
                        .attr('class','link')
                        .attr('x1',function(d){return d.source.x})
                        .attr('y1',function(d){return d.source.y})
                        .attr('x2',function(d){return d.target.x})
                        .attr('y2',function(d){return d.target.y});

                    //力学图的结合
                    force.on('tick',function(){
                        link.attr('x1',function(d){return d.source.x})
                            .attr('y1',function(d){return d.source.y})
                            .attr('x2',function(d){return d.target.x})
                            .attr('y2',function(d){return d.target.y});

                        node.attr('transform',function(d){
                            return 'translate('+ d.x +','+ d.y +')';
                        })
                    })
                });
                //拖动节点的三个过程
                function dragstarted(d){
                    //未激活 重启
                    if (!d3.event.active) force.alphaTarget(0.3).restart();
                    d.fx=d.x;
                    d.fy=d.y;
                }

                function dragged(d){
                    d.fx=d3.event.x;
                    d.fy=d3.event.y;
                }

                function dragended(d){
                    if(!d3.event.active) force.alphaTarget(0);
                    d.fx=null;
                    d.fy=null;
                }
    4.21 GeoJSON 与 TopoJSON文件的区别
            GeoJson与TopoJson文件都是描述地理信息的文件。
            》json格式
                json javascript object notation是一种轻量级的数据交换语言，以文字为基础，易于阅读。
                尽管json是javascript的一个子集，但json是独立于语言的文本格式。

                物件 object 一个物件的数据写在一组大括号内{...}

                名称/值 collection 每个物件都由一系列的名称/值collection组成，名称/值用逗号分隔。
                                    一个名称可以是字符串，值可以是字符串 数值 布尔值 有序列表 或null值
                值的有序列表 Array 列表写在[...]之间 [collection,...]
            》Geojson格式
                GeoJson是一种对地理数据格式进行编码的格式，它只是一个采用上述json格式的用于描述地理信息的格式，它的
                语法和json是一样，只是对各个名称做了规范
                如：
                {   "type": "FeatureCollection",
                    "features": [
                      { "type": "Feature",
                        "geometry": {"type": "Point", "coordinates": [102.0, 0.5]},
                        "properties": {"prop0": "value0"}
                        },
                      { "type": "Feature",
                        "geometry": {
                          "type": "LineString",
                          "coordinates": [
                            [102.0, 0.0], [103.0, 1.0], [104.0, 0.0], [105.0, 1.0]
                            ]
                          },
                        "properties": {
                          "prop0": "value0",
                          "prop1": 0.0
                          }
                        },
                      { "type": "Feature",
                         "geometry": {
                           "type": "Polygon",
                           "coordinates": [
                             [ [100.0, 0.0], [101.0, 0.0], [101.0, 1.0],
                               [100.0, 1.0], [100.0, 0.0] ]
                             ]
                         },
                         "properties": {
                           "prop0": "value0",
                           "prop1": {"this": "that"}
                           }
                         }
                       ]
                    }
            》TopoJson格式
                    TopoJson是GeoJson简化后的版本，可以说是GeoJson的小孩。D3的作者认为GeoJson不太好，推荐TopoJson格式。
                    TopoJson与GeoJson相比，文件大小缩小了80%因为：
                        》边界线只记录一次 如：广西和广东的交界线只记录一次
                        》不使用浮点数，只使用整数值
                        不过TopoJson似乎只在d3中比较广泛的使用，还不是世界范围内认可的格式。
                    注意：无论Geojson还是Topojson，它本质上都是json格式的文件，都遵循json的语法，只不过对变量的名称做了
                          不同的规范。
                     http://mapshaper.org/ 可以转换GeoJson与TopoJson的数据。
   /***************************进阶****************************/
5.1 csv表格文件的读取
    在入门系列的教程中，我们常用 d3.json() 函数来读取 json 格式的文件。json 格式很强大，但对于普通用户可能不太适合，
    普通用户更喜欢的是用 Microsoft Excel 或 OpenOffice Calc 等生成的表格文件，因为简单易懂，容易编辑。Microsoft Excel
    通常会保存为 xls 格式， OpenOffice Calc 通常会保存为 ods 格式。这些格式作为表格文件来说都很强大，但要读取它们是有些
    麻烦的，D3 中也没有提供这样的方法。但是表格软件都会支持生成 csv 格式，它是一种非常基本的、通用的、简单的表格文件。
    本文将会说明在 D3 中怎么读取和使用 csv 文件。

    》csv格式
        CSV Comma Separated Values，逗号分隔值，它是以纯文本形式存储表格数据的，每个单元格之间用逗号 Comma分隔。CSV格式没有
        一个通用的标准，通常使用RFC 4180 中所示的描述。
        如：
        省份,人口,GDP
        山东,9000,50000
        浙江,5000,20000
        //每个单元格之间用逗号隔开，如果想在单元格里面输入逗号需要用双引号框起来
        省份,人口,GDP
        山东,"9,000","50,000"
        浙江,"5,000","20,000"
        //有些软件保存CSV格式时，会选择使用什么符号来分隔单元格 尽量选择逗号。

    》读取CSV文件
        D3中，读取CSV文件的函数只支持用逗号分隔单元格
        d3.csv('csvtest.csv',function(err,data){
                if(err)return console.error(err);
                //处理数据
                console.log(data);
        })
    》将读入的数据转换为字符串
        d3.csv('csvtest.csv',function(err,data){
                if(err)return console.error(err);
                //处理数据
                console.log(data);
                //转换为字符串
                var str = d3.csvFormat(data);
                console.log(str);
        })
5.2 其他表格文件的读取
    CSV 表格文件是以逗号作为单元分隔符的，其他还有以制表符 Tab 作为单元分隔符的 TSV 文件，
    还有人为定义的其它分隔符的表格文件。本文将说明在 D3 中如何读取它们。
    》TSV 表格文件
        TSV Tab Separated Values ，制表分隔值，它和CSV文件仅仅是分隔符不一致。
        如：
        name	age
        张三	22
        李四	24
    》读取TSV文件
        d3.tsv("table.tsv",function(error,tsvdata){
                console.log(tsvdata);
                var str = d3.tsv.format( tsvdata );
                console.log(str.length);
                console.log(str);
        });
    》D3读取CSV与TSV的本质 -- 都是同一个函数 dsv
        //dsv可以读取以任意字符或字符串作为分隔符的表格文件
        d3.csv = d3.dsv(",", "text/csv");
        d3.tsv = d3.dsv("	", "text/tab-separated-values");
        如：
        name;age
        张三;22
        李四;24
            //定义分隔符为分号
			var dsv = d3.dsv(";", "text/plain");
			//调用函数读取文件
			dsv("table.dsv",function(error,dsvdata){
				if(error)
					console.log(error);
				console.log(dsvdata);
			});
5.3 读取CSV文件时乱码的解决方法
        个人认为尽量使用 UTF-8 编码，可以在同一编码内使用各国文字。如果需要保存excel等制表工具打开不会乱码，需以gb2312编码保存。
        》解决方式
            var csv = d3.dsv(",", "text/csv;charset=gb2312");
            var tsv = d3.dsv("	", "text/tab-separated-values;charset=gb2312");
            //使用自己定义的函数读取文件即可
            csv("xxx.csv",function(error,csvdata){

            }

            tsv("xxx.tsv",function(error,tsvdata){

            }
5.4 力学图 + 人物关系图
        阐述在力学图中如何插入外部图片和文字
        》SVG 图片
            <image
                xlink:href="image.png"//图片名称或图片网址
                x="200"//图片左上角x
                y="200"//图片左上角y
                width="100"//图片宽度
                height="100"//图片高度
            ></image>
            //在D3中插入图片
            svg.selectAll('image')
                .data(dataset)
                .enter()
                .append('image')
                .attr('x',200)
                .attr('y',200)
                .attr('width',100)
                .attr('height',100)
                .attr('xlink:href','image.png');
        》SVG文本
            <text
                x="250"
                y="150"
                dx="10"//x轴方向的文本平移量
                dy="10"//y轴方向的文本平移量
                font-family="Verdana"//字体
                font-size="55"
                fill="blue"//字体颜色
                >Hello</text>
                //d3中插入文本
                svg.selectAll("text")
                    .data(dataset)
                    .enter()
                    .append("text")
                    .attr("x",250)
                    .attr("y",150)
                    .attr("dx",10)
                    .attr("dy",10)
                    .text("Hello");
        》绘制图形
            forceRelation.html
5.5 力学图的事件 + 顶点的固定
        force//定义的布局layout
            .on("tick",//表示当运动进行中每更新一帧时的如何更新
              function(){}
            )；
        》布局的事件
            var force = d3.forceSimulation()
                                .force("charge",d3.forceManyBody().strength(-1500))
                                .force("link",d3.forceLink().distance(200))
                                .force('center',d3.forceCenter());

                //力学图布局force本身的事件：start  end  tick
                    //力学图运动开始时
                    force.on("start",function(){
                        console.log("开始");
                    });
                    //力学图运动结束时
                    force.on("end",function(){
                        console.log("结束");
                    });
                    //力学图每一帧
                    force.on("tick",function(){
                        console.log("进行中");
                    });
                //拖拽事件 start  end drag
                    var drag = d3.drag()
                        .on("start",function(){
                            console.log("拖拽开始");
                        })
                        .on("end",function(){
                            console.log("结束");
                        })
                        .on("drag",function(){
                            console.log("进行中");
                        });
                    //分别定义了三种事件后，将此拖拽函数赋值给变量drag,在调用时，只需要使用
                        X.call(drag);
                //顶点的固定
                    //使用布局转换数据之后顶点有一个属性fixed 当这个值为true时，顶点就是固定不动的，为false时，它就是运动的，默认false
                    //当拖拽开始时，被拖拽顶点设定为固定的
                    var drag = d3.drag()
                        .on("start",function(d){
                            d.fixed = true;//被拖拽对象固定
                        });
                    //当鼠标双击顶点时，对顶点解锁
                        nodes_img.on("dblclick",function(d){
                            d.fixed = false;
                        });
                    //v4.x  通过fx fy属性固定顶点
5.6 力学图的参数
        D3的力学图布局是使用 韦尔莱积分法 计算的，这是一种用于求解牛顿运动方程的数值方法，被广泛应用于分子动力学模拟以及视频游戏中。
        //定义布局
        var force = d3.forceSimulation();

        link.distance()//指定节点连线的距离 默认30 如果距离是一个常数，那么各连接线的长度总是固定的，如果是一个函数，那么这个函数是作用于
                       //各连接线 source target的。
        link.strength() //指定连接线的坚硬度 值越大越坚硬 值的范围[0,1]
                        // 值 1 拖动一个顶点A 与之相连的顶点会与A保持link.distance设定的距离运动
                        // 值 0 拖动一个顶点A 与之相连的顶点不会运动，连线会被拉长
        force.alphaDecay() //设置衰减系数 决定从当前alpha值到alphaTarget值的过渡快慢 ，系数越大 仿真过程越短 效果会越差，越小 仿真越长 效果越好。
                           // 想要仿真永远运行 设置为0 此时仿真的alpha保持不变。
        forceManyBody.strength() //设定顶点的电荷数 该参数决定是排斥(负数 绝对值越大 排斥力越大)还是吸引(正数 绝对值越大吸引力越大) 默认-30
        manyBody.distanceMax()//设置最大引力距离 超过这个距离 则没有引用的作用 默认无穷大

        d3.forceCenter(x, y)//围绕着 x y 创建中心作用力模拟重力，默认(0,0)

        manyBody.theta([theta]) //顶点数如果过多 计算的时间就会加大 该函数就是为了限制这个计算而存在的 值越小 计算限制的越紧 默认.9
        simulation.alpha([alpha]) //区间[0,1] 默认为1  设定动画的冷却系数，运动过程中该系数会不断减少 直到为0 动画就停止。
        simulation.restart()//等价于alpha(.1) 重启仿真内部的计时器
        simulation.stop();//等价于alpha(0) 停止仿真内部的计时器
5.7 分区图--表示包含与被包含的关系
    分区图Partition 也是D3的布局，这个布局可以做成方形的也可以做成圆形。
    》方形分区图
         var width = 1000,
                    height=800,
                    svg = d3.select(".app")
                        .append("svg")
                        .attr("width",width)
                        .attr('height',height);

                //颜色生成器
                var color = d3.scaleOrdinal(d3.schemeCategory20);

                //创建分区布局
                var partition = d3.partition()
                                    .size([width,height])
                                    .padding(1)
                                    .round(true);

                //获取数据
                d3.json("cluster.json",function(err,data){
                    if(err) return console.error(err);

                    //转换数据
                    var root = d3.hierarchy(data)
                                .sum(function(d){return d.value ? d.value : 1})//要生成正确的坐标 这是必须的
                                .sort(function(a,b){return b.height - a.height || b.value - a.value});
                    partition(root);

                    /************绘制************/
                    var cell = svg.selectAll("g")
                                    .data(root.descendants())
                                    .enter().append('g')
                                    .attr("transform",function(d){
                                        return "translate("+d.x0+","+d.y0+")";
                                    });

                    //绘制矩形
                    cell.append('rect')
                        .attr('width',function(d){ return d.x1 - d.x0;})
                        .attr('height',function(d){return d.y1 -d.y0})
                        .attr("id",function(d,i){return "rect-"+i})
                        .style('stroke',"#fff")
                        .style('fill',function(d){ return color((d.children ? d : d.parent).data.name)})
                        .on("mouseover",function(d){
                            d3.select(this).style("fill",'yellow');
                        })
                        .on("mouseout",function(d){
                            d3.select(this)
                                .transition()
                                .duration(200)
                                .style('fill',function(d){ return color((d.children ? d : d.parent).name)});
                        });

                    cell.append("clipPath")
                        .attr("id",function(d,i){return "clip-"+i})
                        .append('use').attr("xlink:href",function(d,i){return "#rect-"+i;});
                    //绘制文本
                    cell.append('text')
                        .attr('class','node-text')
                        .attr("clipPath",function(d,i){return "url(#clip-"+ i +")"})//引用裁剪路径
                        .attr('x',10)
                        .attr('y',10)
                        .text(function(d){
                            return d.data.name;
                        });
                });
    》圆形分区图
            分区图布局的size函数 即可用于制作矩形分区图 也可以用于制作圆形分区图。
             //圆形分区图
                    var width = 800,
                        height = 600,
                        radius = 300,
                         svg = d3.select(".app")
                                 .append("svg")
                                 .attr("width",width)
                                 .attr("height",height)
                                 .append("g")
                                 .attr("transform","translate("+width/2+","+height/2+")");

                    //创建颜色生成器
                    var color = d3.scaleOrdinal(d3.schemeCategory20);

                    //创建分区布局
                    var partition = d3.partition()
                                        .round(false)//不要四舍五入  否则数据不准确 有些图形无法显示
                                        .size([2*Math.PI,radius]);

                    //获取数据
                    d3.json("cluster.json",function(err,data){
                        if(err) return console.error(err);

                        //转换数据
                        var root = d3.hierarchy(data)
                                        .sum(function(d){return d.value ? d.value : 1;})
                                        .sort(function(a,b){return b.height - a.height || b.value - a.value});
                        partition(root);

                        /****************绘制***************/
                        //生成path路径
                        var arc = d3.arc()
                                    .startAngle(function(d){return d.x0})
                                    .endAngle(function(d){return d.x1})
                                    .innerRadius(function(d){return d.y0})
                                    .outerRadius(function(d){return d.y1})
                                    .padAngle(.01)

                        //绘制圆弧
                        var arcs = svg.selectAll("g")
                                        .data(root.descendants())
                                        .enter().append('g');

                        arcs.append('path')
                            //.attr("display",function(d){return d.depth ? null : "none"})
                            .attr("d",arc)
                            .style("stroke","#fff")
                            .style("fill",function(d){ return color((d.children ? d : d.parent).data.name);})
                            .on("mouseover",function(d){
                                d3.select(this).style("fill","yellow");
                            })
                            .on("mouseout",function(d){
                                d3.select(this)
                                    .transition()
                                    .duration(200)
                                    .style('fill',function(d){
                                        return color((d.children ? d : d.parent).data.name);
                                    })
                            });

                        //添加文本
                        arcs.append("text")
                            .style("font-size","12px")
                            .style("font-family","simsun")
                            .attr("text-anchor","middle")
                            .attr("transform",function(d,i){
                                //第一个元素 最中间的 只平移
                                if(i===0) return "translate("+arc.centroid(d)+")";

                                //其他的元素 即平移也旋转
                                var r = 0;
                                if(d.x1 / Math.PI * 180 < 180) r = 180 * (d.x1 + d.x0 - Math.PI)/ (2 * Math.PI);
                                else r = 180 * (d.x1 + d.x0 + Math.PI)/(2 * Math.PI);

                                return "translate("+ arc.centroid(d)+") rotate("+ r +")";
                            })
                            .text(function(d){return d.data.name;});
                    })
5.8 分区图的函数
        》分区图布局
            var partition = d3.partition()
        》转换数据
            partition(data);
        》获取当前节点所有的后代节点
            node.descendants()
        》获取所有的连接
            node.links()
        》子节点数组
            node.children
        》sort()指定同深度的节点进行排序的函数，如果不排序按照默认顺序显示
        》sum()  计算所有节点的总值 以及每个节点所占有的权值
        》size() 设置分区图的范围
            方形 size([width,height])
            圆形 size([2*Math.PI,radius])
5.9 绘制箭头
        》SVG中定义箭头的标识
            <defs>
                <marker
                    viewBox  //坐标系的区域
                    refX,refY //在viewBox内的基准点 绘制时此点在直线端点上
                    markerUnits //标识大小的基准 有两个值：strokeWidth(线宽度) userSpaceOnUse(图形最前端的大小)
                    markerWidth，markerHeight//标识的大小
                    orient //绘制方向 可设定为：auto(自动确认方向) 和 角度值
                    id  //标识的id号
                ></marker>
            </defs>

            <!--在直线上绘制-->
            <line x1="0" y1="0" x2="200" y2="50" stroke="red" stroke-width="2" marker-end="url(#arrow)"></line>
            <!--在曲线上绘制-->
            <path d="M20,70 T80,100 T160,80 T200,90" fill="white" stroke="red" stroke-width="2"
                 <!--路径起点处绘制箭头-->
                  marker-start="url(#arrow)"
                  <!--路径中间端点处绘制箭头-->
                  marker-mid="url(#arrow)"
                  <!--路径终点处绘制箭头-->
                  marker-end="url(#arrow)"
            ></path>

        》使用D3绘制箭头
                    var width = 600,
                        height = 500,
                        svg = d3.select('.app2')
                                .append('svg')
                                .attr('width',width)
                                .attr('height',height);

                    //定义箭头
                    var defs = svg.append('defs');
                    var arrow = defs.append('marker')
                                    .attr('id','arrow2')
                                    .attr('markerUnits','strokeWidth')
                                    .attr('markerWidth','12')
                                    .attr('markerHeight','12')
                                    .attr('viewBox','0 0 12 12')
                                    .attr('refX','6')
                                    .attr('refY','6')
                                    .attr('orient','auto')
                                    .append('path')
                                    .attr('d','M2,2 L10,6 L2,10 L6,6 L2,2')
                                    .attr('fill','#000');

                    //绘制直线
                    var line = svg.append('line')
                                    .attr('x1',10)
                                    .attr('y1',10)
                                    .attr('x2',200)
                                    .attr('y2',50)
                                    .attr('stroke','red')
                                    .attr('stroke-width',2)
                                    .attr('marker-start','url(#arrow2)')
                                    .attr('marker-end','url(#arrow2)');

                    //绘制曲线
                    var curve = svg.append('path')
                                    .attr('d',"M20,70 T80,100 T160,80 T200,90")
                                    .attr('fill','white')
                                    .attr('stroke','red')
                                    .attr('stroke-width',2)
                                    .attr('marker-start','url(#arrow2)')
                                    .attr('marker-mid','url(#arrow2)')
                                    .attr('marker-end','url(#arrow2)');
5.10 直方图
        直方图用于描述概率分布，D3提供了直方图的布局Histogram用于转换数据。
        var  width = 960,
                  height = 500,
                  svg = d3.select('.app')
                            .append('svg')
                            .attr('width',width)
                            .attr('height',height);

            //生成数据
            var data = d3.range(1000)//生成[0~1000]
                            .map(
                                d3.randomBates(10)//返回一个自变量10服从Bates distribution分布的随机数生成器
                            );

            //格式化数据
            var format = d3.format(',.0f');// of -- 0个小数

            //定义组
            var svg = d3.select('svg'),
                margin = {top:10,right:30,bottom:30,left:30},
                w = + svg.attr("width") - margin.left - margin.right,
                h = + svg.attr('height') - margin.top - margin.bottom,
                g = svg.append('g').attr('transform','translate('+margin.left+','+margin.top+')');

            //定义线性比例尺
            var x = d3.scaleLinear()
                        .rangeRound([0,w]);

            //定义直方图生成器
            var histogram = d3.histogram()
                            .domain(x.domain())//指定输入范围
                            .thresholds(x.ticks(20));

            //转换数据
            var bins = histogram(data);

            //定义y轴线性比例尺
            var y = d3.scaleLinear()
                        .domain([0,d3.max(bins,function(d){return d.length;})])//获取bins中length最大的值
                        .range([h,0]);

            /*************绘制***********/
            var bar = g.selectAll('.bar')
                        .data(bins)
                        .enter().append('g')
                        .attr('class','bar')
                        .attr('transform',function(d){return 'translate('+ x(d.x0) +','+ y(d.length) +')'});

            //绘制矩形
            bar.append('rect')
                .attr('x',1)
                .attr('width',x(bins[0].x1) - x(bins[0].x0) - 1)
                .attr('height',function(d){ return h - y(d.length);});

            //绘制文本
            bar.append('text')
                .attr('dy','.75em')
                .attr('y',6)
                .attr('x',(x(bins[0].x1 - x(bins[0].x0))/2))
                .attr('text-anchor','middle')
                .text(function(d){return format(d.length)});

            //绘制坐标系
            g.append('g')
                .attr('class','axis axis-x')
                .attr('transform','translate(0,'+ h +')')
                .call(d3.axisBottom(x));
5.11 拖拽的应用 Drag
             //drag的定义
                var drag = d3.drag()//创建一个新的拖拽操作，返回一个drag(对象方法) 一般通过selection.call将其应用到指定的选择集上。
                                .on("drag",dragmove);//指定监听
                function dragmove (d){
                    d3.select(this)
                        .attr('cx',d.cx = d3.event.x)//d3.event.x d3.event.y 鼠标当前的位置
                        .attr('cy',d.cy = d3.event.y);
                }

                /***绘制圆*******/
                var circles = [
                    {cx:150,cy:200,r:30},
                    {cx:250,cy:200,r:30}
                ]
                var svg = d3.select('body').append('svg')
                            .attr('width',500)
                            .attr('height',400);
                svg.selectAll('circle')
                    .data(circles)
                    .enter()
                    .append('circle')
                    .attr('cx',function(d){return d.cx;})
                    .attr('cy',function(d){return d.cy})
                    .attr('r',function(d){return d.r;})
                    .attr('fill','black')
                    .call(drag);//即选择集自身作为参数传递给drag函数。
5.12 缩放的应用Zoom
            缩放Zoom是另一种重要的可视化操作，主要是使用鼠标的滚轮进行。
            //zoom的定义
                var zoom = d3.zoom()//创建一个zoom操作，返回一个zoom对象方法 通常被传递给selection.call来调用
                                .scaleExtent([1,10])//设置缩放范围
                                .on('zoom',zoomed);//设置监听
                function zoomed(){
                    d3.select(this)
                        .attr('transform',
                            'translate('+
                                d3.event.transform.x//平移的坐标值
                            +','+
                                d3.event.transform.y
                            +') scale('+
                                d3.event.transform.k//缩放的值
                            +')');
                }

                /****************绘制圆*******************/
                var svg = d3.select('body').append('svg').attr('width',500).attr('height',400),
                    circles = [
                    {cx:150,cy:200,r:30},
                    {cx:250,cy:200,r:30}
                    ];

                var circles_group = svg.append('g').call(zoom);
                circles_group.selectAll('circle')
                    .data(circles)
                    .enter().append('circle')
                    .attr('cx',function(d){return d.cx})
                    .attr('cy',function(d){return d.cy})
                    .attr('r',function(d){return d.r})
                    .attr('fill','black');
5.13 饼状图的拖拽
                var width = 500,
                        height = 500,
                        dataset = [30,10,43,55,13],
                        svg = d3.select('body').append('svg').attr('width',width).attr('height',height),
                        innerRadius = width/8,
                        outerRadius = width/4,
                        arc = d3.arc().innerRadius(innerRadius).outerRadius(outerRadius);

                    //定义饼状图布局
                    var pie = d3.pie(),
                        data = pie(dataset);//数据转换
                    //定义颜色生成器
                    var color = d3.scaleOrdinal(d3.schemeCategory10);

                    //绘制
                    var gAll = svg.append('g').attr('transform','translate('+outerRadius+','+outerRadius+')');
                    var arcs = gAll.selectAll('.arcs-g')
                                    .data(data)
                                    .enter()
                                    .append('g')
                                    .each(function(d){
                                        d.dx = 0;
                                        d.dy = 0;
                                    })
                                    .call(//调用拖拽
                                        d3.drag().on('drag',dragmove)
                                    );
                    arcs.append('path')
                        .attr('fill',function(d,i){return color(i)})
                        .attr('d',arc);
                    arcs.append('text')
                        .attr('transform',function(d){return 'translate('+arc.centroid(d)+')'})
                        .attr('text-anchor','middle')
                        .text(function(d){return d.value});

                    function dragmove(d){
                        d.dx += d3.event.dx;
                        d.dy += d3.event.dy;
                        d3.select(this).attr('transform','translate('+d.dx+','+d.dy+')');
                    }
5.14 使用datum()绑定数据
            D3最大的特色是能够将数据绑定到DOM上。使用select或selectAll选择元素后，被选择的元素上是没有数据的。
            数据绑定就是***使被选择元素里面包含有数据***。
                》datum() 将指定数据赋值给被选择元素
                》data() 将数据数组与选择集的元素结合
            //datum()的工作过程
                <p>A</p>
                <p>B</p>
                var p =d3.selectAll("p");
                //绑定数值7到选择集上
                p.datum(7)//每个元素对应的__data__属性即为绑定的对应值 (7)
                    .text(function(d){//用于设置或获取被选择元素的文本
                        return d;
                    })

                即datum的工作原理：对于选择集中的每个元素都为其增加一个__data__属性，属性值为datum(value)的参数value，
                此处的value类型：number string boolean object等，如果使用undefined和null作为参数将不会创建__data__属性。

            //d3还有一个特性，能使被绑定的数据传递给子元素--在被绑定数据的选择集中添加元素后，新元素也会具有被绑定的数据。
                p.datum("a")
                 .append('span')
                 .text(function(d,i){
                   return d + " "+i;
                 });
5.15 使用data()绑定数据
            data()函数能够将数组各项**分别**绑定到各元素上，而且能够设置绑定的规则。data()还能够处理数组长度与元素数量不一致的情况。
            当数组长度大于元素数量，能为多余数据预留元素位置，以便将来插入新元素；
            当数组长度小于元素数量时，能提供指向多余元素的方法，以便将来删除。

            data()的工作过程：
            》data()与datum()区别
                datum是把值  同时绑定给选择集
                data是把数组的值分别绑定给选择集的各个元素
            》数组长度与元素数量
                update 数组长度=元素数量
                enter 数组长度>元素数量(多出的数据部分)
                exit  数组长度<元素数量(多出的元素部分)
            data()函数返回一个对象，对象里面包含了update部分和两个函数。
                一个是enter()函数，返回enter部分
                一个是exit()函数，返回exit部分。
5.16 绑定数据的顺序
            data()函数有两个参数，第一个是被绑定的数据，第二个参数用于指定绑定的顺序，在数据需要更新的时候常常用到。
            默认情况下，data()函数是按照**索引号**依次绑定数组各项的。
            也可以不按照此顺序进行绑定，这就需要data()的第二个参数，这个参数是一个函数 -- 键函数 key function
            注意：只有在选择集原来已经绑定有数据的情况下，才能使用健函数指定绑定的顺序。
                        var p = d3.selectAll("p"),
                            data = [{id:1,name:"a"},{id:2,name:"b"},{id:3,name:"c"}];
                        p.data(data).text(function(d){return d.name});

                        //更新数据
                        dt = [{id:3,name:"cc"},{id:1,name:"aa"},{id:2,name:"bb"}]
                        p.data(dt,
                            function(d){return d.id}//表示使用数组项的id属性作为键
                        ).text(function(d){return d.name});
5.17 enter和exit的处理方法以及处理模版
            》enter的处理方法
                如果没有足够的元素，那么处理方法通常是使用append()添加元素。
                var data = [3,6,9];
                var p = d3.selectAll("p");//d3的重要特性：可以选择一个空集
                //绑定数据后，分别获取update和enter部分
                var update = p.data(data);
                var enter = update.enter();
                //update部分处理方式：直接修改内容
                update.text(function(d){return d;});
                //enter部分处理方式：添加元素后再修改内容
                enter.append('p').text(function(d){return d;});
            》exit的处理方法
                有多出的元素，没有数据与之对应。对于这样的元素，通常的做法是使用remove()删除元素。
                var data = [1,2,3];
                var p = d3.selectAll('p');
                //绑定数据之后，分别获取update和exit部分
                var update = p.data(data);
                var exit = update.exit();
                //update部分：修改内容
                update.text(function(d){return d;});
                //exit部分处理方式：删除
                exit.remove();
            》处理模版
                对于不知道数组长度或元素数量的问题，定义处理模版统一处理。
                var data = [1,2,3];
                var p =d3.selectAll("p");
                //绑定数据后分别返回update enter exit部分。
                var update = p.data(data);
                var enter = update.enter();
                var exit = update.exit();

                //update处理
                update.text(function(d){return d;});
                //enter部分处理
                enter.append('p').text(function(d){return d;});
                //exit部分处理
                exit.remove();
5.18 处理模版的应用
            应用模版的场合：当数据需要更新(添加、删除、变更)的时候
            》应用该模版的柱形图
                <button onclick="mysort()">排序</button>
                <button onclick="myadd()">添加</button>
                function draw(){
                        //获取矩形的update部分
                        var updateRect = svg.selectAll('rect').data(dataset);
                        //获取矩形的enter部分
                        var enterRect = updateRect.enter();
                        //获取矩形的exit部分
                        var exitRect = updateRect.exit();
                        //会矩形的update enter exit的处理
                        updateRect.attr("fill",'steelblue')
                            .attr('x',function(d,i){return padding.left + i*rectStep;})
                            .attr('y',function(d){return height - padding.bottom -d;})
                            .attr('width',rectWidth)
                            .attr('height',function(d){return d;});
                        enterRect.append("rect")
                            .attr("fill",'steelblue')
                            .attr('x',function(d,i){return padding.left + i*rectStep;})
                            .attr('y',function(d){return height - padding.bottom -d;})
                            .attr('width',rectWidth)
                            .attr('height',function(d){return d;});
                        exitRect.remove();
                        //获取文字的update部分
                        var updateText = svg.selectAll('text').data(dataset);
                        //文字的enter部分
                        var enterText = updateText.enter();
                        //文字的exit部分
                        var exitText = updateText.exit();
                        //文字update enter exit的处理
                        updateText.attr('fill','white')
                            .attr('font-size','14px')
                            .attr('text-anchor','middle')
                            .attr('x',function(d,i){
                                return padding.left + i*rectStep;
                            })
                            .attr('y',function(d){return height - padding.bottom -d})
                            .attr('dx',rectWidth/2)
                            .attr('dy','1em')
                            .text(function(d){return d;});
                        enterText.append('text')
                            .attr('fill','white')
                            .attr('font-size','14px')
                            .attr('text-anchor','middle')
                            .attr('x',function(d,i){
                                return padding.left + i*rectStep;
                            })
                            .attr('y',function(d){return height - padding.bottom -d})
                            .attr('dx',rectWidth/2)
                            .attr('dy','1em')
                            .text(function(d){return d;});
                        exitText.remove();
                    }
                    var dataset = [50,43,120,87,99,167,147];
                    var width = 400;
                    var height = 400;
                    var svg = d3.select('body').append('svg').attr("width",width).attr('height',height);
                    var padding = {top:20,bottom:20,right:20,left:20};
                    var rectStep = 35;//矩形宽度 包括空白区域
                    var rectWidth = 30;//矩形宽度 不包括空白区域
                    function mysort(){
                        dataset.sort(d3.ascending);
                        draw();
                    }
                    function myadd(){
                        dataset.push(Math.floor(Math.random()*100));
                        draw();
                    }
                    draw();
/*************************高级系列***************************/
6.1 文本的换行
        在SVG中添加文本是使用text元素。但是这个元素不能够自动换行，超出的部分就显示不出来。
        var str = "云中谁寄锦书来，雁字回时，月满西楼";
            var width = 300;
            var height = 300;
            var svg = d3.select('body')
                        .append('svg')
                        .attr('width',width)
                        .attr('height',height);
            //不换行
        //    var text = svg.append('text')
        //                    .attr('x',30)
        //                    .attr('y',100)
        //                    .attr('font-size',30)
        //                    .attr('font-family','simsun')
        //                    .text(str);
            /***************换行************/
            //在text中添加tspan子元素
            //svg中的文本不支持自动换行，需要手动实现，其中一种方法就是使用tspan标签。
            //tspan是写在text中，作为其子元素存在，设置文本属性的时候，有一个dy属性，表示y轴的相对位置，dy的值通常
            //用10px 1em这类值，其中em是以行为单位的。
            //这样，我们在text中添加多个tspan，每个代表一行，每一个tspan属性都赋予一个1em值(即一行)，如此文本就会一行一行的显示了
            //注意tspan中的x属性是必要的，表示该行从什么位置开始显示
            var text = svg.append('text')
                    .attr('x',30)
                    .attr('y',100)
                    .attr('font-size',30)
                    .attr('font-family','simsun');
            //将str分段
            var strs = str.split('，');
            //填充数据
            text.selectAll('tspan')
                .data(strs)
                .enter()
                .append('tspan')
                .attr('x',text.attr('x'))
                .attr('dy','1em')
                .text(function(d){return d;});
6.2 封装文本自动换行
        //引入multext.js
        》函数的参数
            文件里只实现了一个函数appendMultiText(),其参数的意义：
            appendMultiText(
                container,//文本的容器，可以是svg或g
                str,//字符串
                posX,//文本的x坐标
                posY,//文本的y坐标
                width,//每一行的宽度，单位像素
                fontsize,//文本的大小 默认14
                fontfamily//文本字体 默认simsun, arial
            );
        》测试
            //添加多行文本测试
                var width = 300;
                var height = 300;
                var svg = d3.select('body')
                            .append('svg')
                            .attr('width',width)
                            .attr('height',height);
                var str = "青青子衿，悠悠我心，但为君故，沉吟至今。";
                var text = appendMultiText(svg,str,30,100,120,20);//appendMultiText返回值是被添加的<text>元素
                text.attr('transform','rotate(-20)');
6.3 捆图
        捆图Bundle是D3中比较奇特的一个布局，只有两个函数，而且需要与其他布局配合使用。
        捆图布局之所以函数少，是因为他常与其他层级布局一起使用。所谓层级布局是指采用嵌套结构(父子节点关系)来描述节点信息。
        根据层级布局扩展出来的布局即：集群图、打包图、分区图、树状图、矩阵树图。最常见的是与集群图一起使用，使用集群图布
        局计算节点位置，再用捆图布局计算连线路径。
        即捆图布局只干一件事：****计算连线的路径****。
        //数据
            var cities = {
                name:"",
                children:[
                    {name: "北京"},{name: "上海"},{name: "杭州"},
                    {name: "广州"},{name: "桂林"},{name: "昆明"},
                    {name: "成都"},{name: "西安"},{name: "太原"}
                ]
            }
            var railway = [
                {source: "北京", target: "上海"},
                {source: "北京", target: "广州"},
                {source: "北京", target: "杭州"},
                {source: "北京", target: "西安"},
                {source: "北京", target: "成都"},
                {source: "北京", target: "太原"},
                {source: "北京", target: "桂林"},
                {source: "北京", target: "昆明"},
                {source: "北京", target: "成都"},
                {source: "上海", target: "杭州"},
                {source: "昆明", target: "成都"},
                {source: "西安", target: "太原"}
            ];
            var size = 800,
                radius = size/2,
                innerRadius = radius - 50;
            //数据转换  捆图+集群图
            //创建集群图生成器
            var cluster = d3.cluster().size([360,innerRadius]);
            //构建连线生成器
            var line = d3.radialLine()
                            .curve(d3.curveBundle.beta(1))
                            .radius(function(d){return d.y;})
                            .angle(function(d){return d.x/180*Math.PI;});

            /*************数据转换****************/
            var nodesRoot = cluster(d3.hierarchy(cities));
            /********************开始绘制**************************/
            //其实捆图布局是生成连线的路径
            var svg = d3.select('body')
                        .append('svg')
                        .attr('width',size)
                        .attr('height',size)
                        .append('g')
                        .attr('transform','translate('+ size/2 +','+ size/2 +')');
            //颜色生成器
            var color = d3.scaleOrdinal(d3.schemeCategory20);

            //绘制连线
            var links = svg.selectAll('.link')
                            .data(function(){//生成link对应的数组 通过 path API
                                var data = [],
                                    map =[ ];
                                nodesRoot.descendants().forEach(function(curr){
                                    map[curr.data.name] = curr;
                                });
                                nodesRoot.descendants().forEach(function(d){
                                    railway.forEach(function(curr){
                                        if(curr.source === d.data.name){
                                            data.push(map[d.data.name].path(map[curr.target]));
                                        }
                                    })
                                });
                                return data;
                            })
                            .enter()
                            .each(function(d){ d.source = d[0],d.target = d[d.length -1]})
                            .append('path')
                            .attr('class','link')
                            .attr('d',line);
            //绘制节点
            var node = svg.selectAll('g')
                            .data(nodesRoot.descendants().filter(function(d){ return !d.children;}))
                            .enter()
                            .append('g')
                            .attr('transform',function(d){
                                return "rotate("+ (d.x - 90)+") translate("+ d.y +") rotate("+ (90 - d.x)+")";
                            })
                            .on("mouseover",function(d){
                                node.each(function(n){
                                    n.target = n.source = false;
                                });
                                links
                                    .classed("link-target",function(l){
                                        if(d === l.target) return l.source.source =true;
                                    })
                                    .classed('link-source',function(l){
                                        if( d === l.source) {
                                            return l.target.target = true;
                                        }
                                    });
                                node
                                    .classed('node-target',function(n){return n.target;})
                                    .classed('node-source',function(n){return n.source});
                            })
                            .on('mouseout',function(d){
                                node
                                    .classed('node-target',false)
                                    .classed('node-source',false);
                                links
                                    .classed('link-target',false)
                                    .classed('link-source',false);
                            });
            node.append('circle')
                .attr('r',20)
                .style('fill',function(d,i){return color(i);});
            node.append('text')
                .attr('dy','.2em')
                .style('text-anchor','middle')
                .text(function(d){return d.data.name;});
6.4 堆栈图
            堆栈图布局 Stack Layout 能够计算二维数组每一数据层的基线，以方便将各数据层叠加起来。
            //数据
                var dataset = [
                    {   name: "PC" ,
                        sales: [
                            { year:2005, profit: 3000 },
                            { year:2006, profit: 1300 },
                            { year:2007, profit: 3700 },
                            { year:2008, profit: 4900 },
                            { year:2009, profit: 700 }
                            ]
                    },
                    {   name: "SmartPhone" ,
                        sales: [
                            { year:2005, profit: 2000 },
                            { year:2006, profit: 4000 },
                            { year:2007, profit: 1810 },
                            { year:2008, profit: 6540 },
                            { year:2009, profit: 2820 }
                            ]
                    },
                    { name: "Software" ,
                        sales: [
                            { year:2005, profit: 1100 },
                            { year:2006, profit: 1700 },
                            { year:2007, profit: 1680 },
                            { year:2008, profit: 4000 },
                            { year:2009, profit: 4900 }
                            ]
                    }
                ];
                function dataFormat(data){
                    var resultData = [];
                    data[0].sales.forEach(function(curr){
                        resultData.push({
                            year:curr.year
                        });
                    });
                    resultData.forEach(function(curr){
                        var year = curr.year;
                        data.forEach(function(d){
                            d.sales.forEach(function(s){
                                if(s.year === year){
                                    curr[d.name] = s.profit;
                                    return false;
                                }
                            })
                        })
                    });
                    resultData.forEach(function(curr){
                        curr.total = curr.PC + curr.SmartPhone + curr.Software;
                    })
                    return resultData;
                }
                var data = dataFormat(dataset);
                var svg = d3.select('svg'),
                    margin = {top:20,bottom:20,left:60,right:20},
                    width = +svg.attr('width') - margin.left - margin.right,
                    height = +svg.attr('height') - margin.top - margin.bottom,
                    g = svg.append('g').attr('transform','translate('+ margin.left +','+ margin.top +')')
                //获取keys
                var keys = [];
                dataset.forEach(function(curr){
                    keys.push(curr.name);
                });
                /************定义比例尺*************/
                //定义x轴比例尺
                var x = d3.scaleBand()
                        .rangeRound([0,width])
                        .align(1)
                        .paddingInner(.2)
                        .paddingOuter(.1)
                        .domain(data.map(function(d){return d.year}));
                //定义y轴比例尺
                var y = d3.scaleLinear()
                            .rangeRound([height,0])
                            .domain([0,d3.max(data,function(d){return d.total})]);
                //定义颜色生成器
                var color = d3.scaleOrdinal()
                                .range(["#1F77B4", "#FF7F0E", "#31A231"])
                                .domain(keys);
                //定义堆叠图布局
                var stack = d3.stack()
                                .keys(keys);
                //数据转换
                var root = stack(data);
                /************绘制************/
                //绘制矩形
                g.append('g')
                    .selectAll('g')
                    .data(root)
                    .enter().append('g')
                    .attr('fill',function(d){return color(d.key)})
                    .selectAll('rect')
                    .data(function(d){return d;})
                    .enter().append('rect')
                    .attr('x',function(d){return x(d.data.year)})
                    .attr('y',function(d){return y(d[1])})
                    .attr('width',x.bandwidth())
                    .attr('height',function(d){return y(d[0]) - y(d[1])});
                //绘制坐标轴
                g.append('g')
                    .attr('transform','translate(0,'+ height +')')
                    .call(d3.axisBottom(x))
                    .append('text')
                    .text('年')
                    .attr('x',x.range()[1])
                    .attr('fill','#000')
                    .attr('dy','1.2em')
                    .attr('dx','-.5em')
                    .attr('font-weight','bold')
                    .attr('text-anchor','start')
                    .attr('font-size','14px')
                g.append('g')
                    .call(d3.axisLeft(y))
                    .append('text')
                    .attr('x',-36)
                    .attr('y',0)
                    .text('利润')
                    .attr('fill','#000')
                    .attr('dy','.36em')
                    .attr('font-weight','bold')
                    .attr('text-anchor','start')
                    .attr('font-size','14px')

                //绘制注释
                var legend = g.append('g')
                    .attr('font-size','10px')
                    .attr('text-anchor','end')
                    .selectAll('g')
                    .data(keys)
                    .enter()
                    .append('g')
                    .attr('transform',function(d,i){return 'translate('+ (width-20) +','+ 40*i +')'});
                legend.append('rect')
                    .attr('width',19)
                    .attr('height',39)
                    .attr('fill',color);
                legend.append('text')
                        .text(function(d){return d;})
                        .attr('dy','2.4em')
                        .attr('dx','-.5em');
6.5 矩阵树图
            矩阵树图 Treemap 也是层级布局的扩展，根据数据将区域划分为矩形的集合。矩形的大小和颜色都是数据的反映。
            var svg = d3.select('svg'),
                    margin = {top:20,bottom:20,left:20,right:20},
                    width =+svg.attr('width') - margin.left -margin.right,
                    height =+svg.attr('height') - margin.top -margin.bottom,
                    g = svg.append('g').attr('transform','translate(' + margin.left + ','+ margin.top +')');
                //定义矩阵树布局
                var treemap = d3.treemap()
                                .size([width,height])
                                .padding(2)
                                .round(true);

                //颜色生成器
                var color = d3.scaleOrdinal(d3.schemeCategory20);
                //获取数据
                d3.json('citygdp.json',function(err,data){
                    if(err) return console.error(err);

                    //数据转换
                    var root = d3.hierarchy(data)
                        .sum(function(d){return d.gdp;})
                        .sort(function(a,b){return b.height - a.height || b.value - a.value;});
                    treemap(root);

                    /****************绘制****************/
                    var groups = g.selectAll('g')
                                    .data(root.leaves())
                                    .enter()
                                    .append('g');

                    var rects = groups.append('rect')
                                        .attr('class','nodeRect')
                                        .attr('x',function(d){return d.x0;})
                                        .attr('y',function(d){return d.y0;})
                                        .attr('width',function(d){return d.x1 - d.x0;})
                                        .attr('height',function(d){return d.y1 - d.y0})
                                        .style('fill',function(d,i){return color(d.parent.data.name)});

                    var texts = groups.append('text')
                                        .attr('class','nodeName')
                                        .attr('x',function(d){return d.x0;})
                                        .attr('y',function(d){return d.y0})
                                        .attr('dx','.5em')
                                        .attr('dy','1.5em')
                                        .text(function(d){return d.data.name + " " + d.data.gdp;});
                })
            //布局的作用是将某种数据转换成另一种数据，而转换后的数据是利于可视化的。
6.6 颜色
            常用的标准有RGB和HSL，D3提供了创建颜色对象的方法，能够相互转换和插值。
                RGB色彩模式是通过对红red、绿green、蓝blue三个颜色通道相互叠加来得到各种各样的颜色，三个通道的值的范围
            都为0~255，总共有256^3种。
                HSL色彩模式是通过对色相Hue、饱和度Saturation、明暗Lightness三个通道的相互叠加来得到各种颜色。
            其中，色相的范围为0°~360°，饱和度的范围为0~1，明度的范围为0~1。
            色相的取值是一个角度，每个角度可以代表之中颜色，需要记住的是0°或360°代表红色，120°代表绿色，240°代表蓝色。
            饱和度的数值越大，颜色越鲜艳，灰色越少。
            明度值用于控制色彩的明暗变化，值越大，越明亮，越接近于白色；值越小，越暗，越接近黑色。
            注：RGB颜色和HSL颜色是可以相互转换的。
            》RGB
                》RGB颜色的创建：
                    d3.rgb(r,g,b)//分别输出r、g、b值来创建颜色
                    d3.rgb(color)//输入相应的字符串来创建颜色
                        color类型：
                            》RGB的十进制值：“rgb(255, 255, 255)”
                            》HSL的十进制值：“hsl(120, 0.5, 0.5)”
                            》RGB的十六进制值：“#ffeeaa”
                            》RGB的十六进制值的缩写形式：“#fea”
                            》颜色名称：“red”、“white”
                》rgb.brighter([k]) 颜色变得更明亮
                    RGB各通道的值乘以  .7^-k ,如果k省略，k的值为1。只有当某通道的值范围在30~255之间时，才进行相应的计算。
                》rgb.darker([k]) 颜色变得更暗
                    RGB各通道的值乘以 .7^k。
                》d3.hsl(rgb) 返回该颜色对应的HSL值。
                》rgb.toString() 以字符串形式返回该颜色值如"#ffeeaa"
                注意：brighter()与darker()并不会改变当前颜色本身，而是返回一个新的颜色，新的颜色值发生了相应的变化。
                函数brighter() darker() hsl()返回的都是对象，不是字符串，前两个函数返回的是RGB对象，最后一个函数返回的是HSL对象。
            》HSL
                》d3.hsl(h,s,l)//根据h、s、l的值来创建HSL颜色
                》d3.hsl(color)//根据字符串来创建HSL颜色
                》hsl.brighter([k])//变得更亮
                》hsl.darker([k])//变得更暗
                》hsl.rgb();//返回对应的RGB颜色
                》hsl.toString();以RGB字符串形式输出该颜色
            》插值
                要得到两个颜色值之间的值，这种时候就要用到插值(Interpolation)。
                D3提供了d3.interpolateRgb()来处理RGB颜色之间的插值运算，
                d3.interpolateHsl()来处理HSL颜色之间的运算。更方便的是使用d3.interpolate(),
                它会自动判断调用那个函数，d3.interpolate()也可以处理数值、字符串等之间的插值。
                 d3.interpolate(startColor1,endColor2)([0~1]);
6.7 颜色插值和线性渐变
            颜色插值指的是：给出两个RGB颜色值，两个颜色之间的值通过插值函数计算得到。
            线性渐变是添加到SVG图形上的过滤器，只需要给出两端的颜色值即可。
            》颜色插值
                var a = d3.rgb(255,0,0);
                    var b = d3.rgb(0,255,0);
                    var compute = d3.interpolate(a,b);
                    console.log(compute(.5));//参数的范围[0,1]//0返回开始值即a //1返回结束值即b //0~1返回a~b之间的插值颜色
                    //当某个值域的饭我并不在0到1之间，需要用到线性比例尺 如：0~150;
                    var linear = d3.scaleLinear().domain([0,150]).range([0,1]);
                    //在计算颜色值时，只要compute(linear(x))即可，x的范围是0到150

                    //下面绘制150个矩形，分为10行，每行15个，用颜色插值函数分别计算每个矩形的填充色。
                    var svg = d3.select('svg');
                    var rects = svg.selectAll('rect')
                        .data(d3.range(150))
                        .enter().append('rect')
                        .attr('x',function(d,i){
                            return i%15*15;
                        })
                        .attr('y',function(d,i){
                            return Math.floor(i/15)*15;
                        })
                        .attr('width',15)
                        .attr('height',15)
                        .style('fill',function(d){
                            return compute(linear(d));
                        });
            》线性渐变过滤器
                    渐变表示一种颜色平滑过渡到另一种颜色。
                    SVG中有线性渐变<linearGradient>和放射性渐变<radialGradient>。
                    渐变定义在<defs>标签中，然后给渐变定义一个id，在需要使用的图形上调用此id即可
                    <defs>
                        <linearGradient id='gradient' x1='0%' y1='0%' x2='100%' y2='0%'>
                            <stop offset='0%' stop-color='#f00'/>
                            <stop offset='100%' stop-color='#0ff'/>
                        </linearGradient>
                    </defs>
                    //x1 y1 x2 y2用于定义渐变的方向，此处表示水平渐变，offset定义渐变的位置 stop-color定义该位置处的颜色
                    //使用渐变
                    <rect fill='url(#gradient)' x='10' y='10' width='300' height='100'></rect>

                    //d3中的实现
                        //定义线性渐变
                            var linearGradient = d3.select('.linear-gradient')
                                                    .append('defs')
                                                    .append('linearGradient')
                                                    .attr('id','linearColor')
                                                    .attr('x1','0%')
                                                    .attr('y1','0%')
                                                    .attr('x2','100%')
                                                    .attr('y2','0%');
                            linearGradient.append('stop')
                                            .attr('offset','0%')
                                            .attr('stop-color',a.toString());
                            linearGradient.append('stop')
                                            .attr('offset','100%')
                                            .attr('stop-color',b.toString());
                            //使用渐变
                            d3.select('.linear-gradient').append('rect')
                                .attr('x',10)
                                .attr('y',10)
                                .attr('width',400)
                                .attr('height',300)
                                .style('fill','url(#'+ linearGradient.attr('id') +')');
6.8 值域和颜色 -- 利用颜色的变化来表示值的变化 (地图完整案例)
         var width = 600,
                height = 600,
                svg = d3.select('body')
                    .append('svg')
                    .attr('width', width)
                    .attr('height', height);

            //投影函数
            var projection = d3.geoMercator()
                .center([107, 31])
                .scale(500)
                .translate([width / 2, height / 2]);
            //路径生成
            var path = d3.geoPath().projection(projection);
            //绘制完整的中国地图
            //读取TogoJson地图文件
            d3.json("china.geojson", function (err, topoData) {
                if (err) return console.error(err);

                //将TogoJson(文件较小)对象转换成GeoJson(信息详细,直接读取文件较大)
                //使用ogr2ogr即可
                var geoData = topoData;
                /*************绘制************/
                var china = svg.append('g');
                //绘制
                var provinces = china.selectAll('path')
                    .data(geoData.features)
                    .enter()
                    .append('path')
                    .attr('class', 'province')
                    .style('fill', '#ccc')
                    .attr('d', path);

                //为各省市添加颜色
                //tourism.json:各省份旅游业发展数据
                d3.json('tourism.json', function (err, tourismData) {
                    if (err) return console.error(err);

                    //创建颜色插值函数
                    var maxvalue = d3.max(tourismData.provinces, function (d) {
                        return d.value;
                    });
                    var minvalue = 0;
                    var colorLinear = d3.scaleLinear()
                                        .domain([minvalue,maxvalue])
                                        .range([0,1]);
                    var a = d3.rgb(0,255,255);
                    var b = d3.rgb(0,0,255);
                    //颜色插值函数
                    var computeColor = d3.interpolate(a,b);
                    var values = [];
                    tourismData.provinces.forEach(function(curr){
                        values[curr.name] = curr.value;
                    })

                    //设定个省份填充色
                    provinces.style('fill',function(d,i){
                        return computeColor(colorLinear(values[d.properties.name])).toString();
                    });

                    //添加颜色标志
                    //定义一个线性渐变
                    var linearGradient = svg.append('defs').append('linearGradient')
                                            .attr('id','linear')
                                            .attr('x1','0%')
                                            .attr('y1','0%')
                                            .attr('x2','100%')
                                            .attr('y2','0%');
                    linearGradient.append('stop').attr('offset','0%').style('stop-color',a.toString());
                    linearGradient.append('stop').attr('offset','100%').style('stop-color',b.toString());
                    //添加矩形
                    var colorRect = svg.append('rect')
                                        .attr('x',20)
                                        .attr('y',490)
                                        .attr('width',140)
                                        .attr('height',30)
                                        .style('fill','url(#'+ linearGradient.attr('id') +')');
                    //添加文字
                    var minValueText = svg.append('text')
                                            .attr('class','valueText')
                                            .attr('x',20)
                                            .attr('y',490)
                                            .attr('dy','-.3em')
                                            .text(minvalue);
                    var maxValueText = svg.append('text')
                                            .attr('class','valueText')
                                            .attr('x',160)
                                            .attr('y',490)
                                            .attr('dy','-.3em')
                                            .text(maxvalue);
                })

            })
            /**
             * 此外，南海诸岛的地图是不包含在地图文件里的。但是，中国的南海诸岛，
             * 一般只是显示在右下角，用一个方框框起来而已，不一定要做成GeoJSON格式。
             * 直接制作一个SVG格式的文件即可。
             */
            //绘制南海诸岛
            d3.xml('southchinasea.svg', function (err, xmlDom) {
                if (err) return console.error(err);
                svg.html(function (d) {
                    return d3.select(this).html() + xmlDom.getElementsByTagName('g')[0].outerHTML;//outerHTML 包含对象本身
                });
                //移动位置
                d3.select('#southsea')
                    .attr('transform', 'translate(480,350) scale(.5)')
                    .attr('class', 'southsea');
            })
6.9 标注地点
        标注(点元素)：地图上只需要一个坐标(经纬度)即可表示的元素
        http://www.ourd3js.com/wordpress/1201/
























































































